<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=5">
  <meta name="theme-color" content="#1e5aa8">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ELS Search">
  <meta name="description" content="Search for Equidistant Letter Sequences (ELS) in the Hebrew Bible">
  <link rel="icon" type="image/png" href="img/favicon.png">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">
  <link rel="manifest" href="manifest.json">
  <title>Bible Codes - ELS Search</title>
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').then(reg => {
          reg.addEventListener('updatefound', () => {
            const newSW = reg.installing;
            newSW.addEventListener('statechange', () => {
              if (newSW.state === 'activated') location.reload();
            });
          });
          reg.update();
        });
      });
    }
  </script>
  <style>
    :root {
      --blue: #1e5aa8;
      --blue-light: #e8f0f8;
      --blue-dark: #174a8a;
      --gray: #555;
      --gray-light: #f5f5f5;
      --border: #ccc;
      --green: #2e7d32;
      --red: #c62828;
      --orange: #e65100;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--gray-light);
      color: #333;
      line-height: 1.5;
    }
    .header {
      background: var(--blue);
      color: white;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .header a { color: white; text-decoration: none; }
    .header img { width: 32px; height: 32px; }
    .header h1 { font-size: 18px; font-weight: 600; }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px; }

    /* Mode Tabs */
    .mode-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 16px;
      background: white;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .mode-tab {
      flex: 1;
      padding: 14px 20px;
      border: none;
      background: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 600;
      color: var(--gray);
      transition: all 0.2s;
      text-align: center;
    }
    .mode-tab:not(:last-child) { border-left: 1px solid var(--border); }
    .mode-tab:hover { background: var(--blue-light); }
    .mode-tab.active {
      background: var(--blue);
      color: white;
    }
    .mode-tab .mode-desc {
      font-size: 11px;
      font-weight: normal;
      opacity: 0.8;
      display: block;
      margin-top: 2px;
    }

    /* Sections */
    .section {
      background: white;
      border-radius: 6px;
      padding: 20px;
      margin-bottom: 16px;
      border: 1px solid var(--border);
    }
    .section h2 {
      color: var(--blue);
      font-size: 16px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .section p { margin-bottom: 12px; color: var(--gray); font-size: 14px; }

    /* Mode content */
    .mode-content { display: none; }
    .mode-content.active { display: block; }

    /* Form elements */
    .input-row {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    input[type="text"], input[type="number"] {
      padding: 10px 12px;
      font-size: 16px;
      border: 1px solid var(--border);
      border-radius: 4px;
      min-width: 120px;
    }
    input:focus { border-color: var(--blue); outline: none; }
    .btn {
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      background: var(--blue);
      color: white;
      border: none;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .btn:hover { background: var(--blue-dark); }
    .btn:active { transform: scale(0.98); }
    .btn-secondary { background: var(--gray); }
    .btn-success { background: var(--green); }
    .btn-danger { background: var(--red); }
    .btn-small { padding: 8px 12px; font-size: 13px; }

    /* Term entries */
    .term-entries { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .term-entry { display: flex; gap: 10px; align-items: center; }
    .term-entry input { flex: 1; }
    .term-entry .remove-btn {
      background: var(--red);
      color: white;
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      cursor: pointer;
      font-size: 16px;
    }

    /* Results */
    .results {
      background: #fafafa;
      border-radius: 4px;
      padding: 15px;
      margin-top: 15px;
      border: 1px solid var(--border);
    }
    .results h3 { color: var(--blue); margin-bottom: 10px; font-size: 15px; }
    .results-scrollable { max-height: 500px; overflow-y: auto; }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .results-table th, .results-table td {
      border: 1px solid var(--border);
      padding: 8px;
      text-align: right;
    }
    .results-table th {
      background: var(--blue);
      color: white;
      position: sticky;
      top: 0;
    }
    .results-table tr:nth-child(even) { background: #f5f5f5; }
    .results-table tr:hover { background: var(--blue-light); }

    /* Stats grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .stat-box {
      background: var(--blue);
      color: white;
      padding: 14px;
      border-radius: 4px;
      text-align: center;
    }
    .stat-box .value { font-size: 20px; font-weight: bold; }
    .stat-box .label { font-size: 11px; opacity: 0.9; }

    /* Proximity matrix */
    .proximity-matrix { overflow-x: auto; margin-top: 15px; }
    .proximity-matrix table { border-collapse: collapse; font-size: 13px; width: 100%; }
    .proximity-matrix th, .proximity-matrix td {
      border: 1px solid var(--border);
      padding: 8px 12px;
      text-align: center;
    }
    .proximity-matrix th { background: var(--blue); color: white; }
    .cell-close { background: #d4edda; }
    .cell-medium { background: #fff3cd; }
    .cell-far { background: #f8d7da; }

    /* Clickable rows */
    .clickable-row { cursor: pointer; transition: background 0.15s; }
    .clickable-row:hover { background: #d0e4f7 !important; }
    .clickable-row.selected { background: var(--blue) !important; color: white; }
    .clickable-row.selected td { color: white; }

    /* Matrix view */
    .matrix-view {
      margin-top: 20px;
      padding: 20px;
      background: #2a2a3d;
      border-radius: 6px;
      color: white;
    }
    .matrix-view h3 { color: #8bb8e8; margin-bottom: 10px; }
    .matrix-view .hint { color: #999; font-size: 13px; }
    .els-matrix {
      font-family: 'Courier New', monospace;
      font-size: 16px;
      line-height: 1.8;
      direction: rtl;
      background: #1a1a28;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      white-space: pre;
      margin: 15px 0;
    }
    .els-matrix .hl1 { background: var(--red); color: white; padding: 2px; border-radius: 2px; }
    .els-matrix .hl2 { background: var(--green); color: white; padding: 2px; border-radius: 2px; }
    .els-matrix .hl-both { background: var(--orange); color: white; padding: 2px; border-radius: 2px; }
    .matrix-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }
    .matrix-stat {
      background: #3a3a4d;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    .matrix-stat .value { font-size: 16px; font-weight: bold; color: #8bb8e8; }
    .matrix-stat .label { font-size: 10px; color: #999; }

    /* Save/Load panel */
    .save-panel {
      background: var(--blue-light);
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 15px;
      border: 1px solid #c8dae8;
    }
    .saved-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: white;
      border-radius: 4px;
      margin-top: 8px;
      border: 1px solid var(--border);
    }
    .saved-item .name { font-weight: bold; color: var(--blue); }
    .saved-item .meta { font-size: 11px; color: #666; }

    /* Loading */
    .loading { text-align: center; padding: 40px; color: #666; }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #eee;
      border-top-color: var(--blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Action buttons */
    .action-row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px; }

    /* Scan mode specific */
    .range-row {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 15px;
      font-size: 14px;
    }
    .range-row label { display: flex; align-items: center; gap: 6px; }
    .range-row input[type="number"] { width: 80px; }
    .result-item {
      padding: 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }
    .result-item:hover { background: var(--blue-light); }
    .result-item .term { font-weight: bold; color: var(--blue); font-size: 18px; }
    .result-item .info { font-size: 13px; color: var(--gray); margin-top: 4px; }

    .matrix-container {
      background: #1a1a2e;
      border-radius: 8px;
      padding: 20px;
      overflow: auto;
      max-width: 100vw;
      max-height: calc(100vh - 150px);
    }
    .matrix-grid {
      display: grid;
      gap: 2px;
      direction: rtl;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      min-width: max-content;
    }
    .matrix-cell {
      width: 26px;
      height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #2d2d44;
      color: #e0e0e0;
      border-radius: 3px;
    }
    .matrix-cell.term1 { background: #ffc107; color: #000; font-weight: bold; }
    .matrix-cell.term2 { background: #00bcd4; color: #000; font-weight: bold; }
    .matrix-cell.term1.term2 { background: #9c27b0; color: #fff; }
    /* N-term color palette for scan mode */
    .matrix-cell.term-color-0 { background: #ffc107; color: #000; font-weight: bold; }
    .matrix-cell.term-color-1 { background: #00bcd4; color: #000; font-weight: bold; }
    .matrix-cell.term-color-2 { background: #ff5722; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-3 { background: #4caf50; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-4 { background: #e91e63; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-5 { background: #3f51b5; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-6 { background: #795548; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-7 { background: #607d8b; color: #fff; font-weight: bold; }
    .matrix-cell.multi-term { background: #9c27b0; color: #fff; font-weight: bold; }
    /* (scan-term-entries removed — replaced by unified textarea input) */
    .cluster-row { padding: 14px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; }
    .cluster-row:hover { background: var(--blue-light); }
    .cluster-span { font-weight: bold; color: var(--green); font-size: 16px; }
    .cluster-terms { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .cluster-term-tag { padding: 4px 10px; border-radius: 4px; font-size: 13px; border: 1px solid; }
    .cluster-verses { font-size: 12px; color: #666; margin-top: 6px; }
    .matrix-legend {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      color: white;
      font-size: 13px;
      flex-wrap: wrap;
    }
    .legend-item { display: flex; align-items: center; gap: 6px; }
    .legend-color { width: 18px; height: 18px; border-radius: 3px; }
    .legend-color.t1 { background: #ffc107; }
    .legend-color.t2 { background: #00bcd4; }
    .legend-color.both { background: #9c27b0; }

    /* Info text */
    .info-text {
      background: #e8f5e9;
      border-radius: 4px;
      padding: 10px 14px;
      border-right: 3px solid var(--green);
      font-size: 13px;
      color: var(--green);
      margin-bottom: 15px;
    }

    /* Batch loader */
    .batch-panel {
      background: #f0f4ff;
      border: 1px solid #b0c4de;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 15px;
    }
    .batch-panel h3 { color: var(--blue-dark); font-size: 14px; margin-bottom: 10px; }
    .batch-textarea {
      width: 100%;
      height: 120px;
      font-size: 14px;
      font-family: inherit;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      direction: rtl;
      resize: vertical;
    }
    /* Hebrew virtual keyboard */
    .heb-kb-toggle {
      background: none;
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-size: 14px;
      color: var(--gray);
      transition: background 0.15s, border-color 0.15s;
      line-height: 1;
    }
    .heb-kb-toggle:hover { border-color: var(--blue); color: var(--blue); }
    .heb-kb-toggle.active { background: var(--blue); color: #fff; border-color: var(--blue); }
    .heb-kb-panel {
      display: none;
      background: #f8f9fb;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 12px;
      direction: ltr;
    }
    .heb-kb-panel.open { display: block; }
    .heb-kb-row { display: flex; gap: 4px; justify-content: center; margin-bottom: 4px; }
    .heb-kb-row:last-child { margin-bottom: 0; }
    .heb-kb-key {
      min-width: 32px; height: 36px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
      font-size: 18px;
      font-family: 'SBL Hebrew', 'David', 'Noto Sans Hebrew', serif;
      display: flex; align-items: center; justify-content: center;
      transition: background 0.1s, box-shadow 0.1s;
      user-select: none;
      padding: 0 6px;
    }
    .heb-kb-key:hover { background: #e3ecf7; box-shadow: 0 1px 3px rgba(0,0,0,0.12); }
    .heb-kb-key:active { background: var(--blue); color: #fff; }
    .heb-kb-key.wide { min-width: 56px; font-size: 12px; color: var(--gray); }
    @media (max-width: 500px) {
      .heb-kb-key { min-width: 26px; height: 32px; font-size: 16px; padding: 0 3px; }
      .heb-kb-key.wide { min-width: 42px; font-size: 10px; }
    }
    .batch-progress {
      width: 100%;
      height: 24px;
      background: #ddd;
      border-radius: 12px;
      overflow: hidden;
      margin: 10px 0;
    }
    .batch-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--blue), var(--green));
      border-radius: 12px;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      color: white;
      min-width: 40px;
    }
    .batch-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      margin-top: 12px;
    }
    .batch-table th, .batch-table td {
      border: 1px solid var(--border);
      padding: 8px 10px;
      text-align: right;
    }
    .batch-table th {
      background: var(--blue);
      color: white;
      position: sticky;
      top: 0;
      cursor: pointer;
    }
    .batch-table th:hover { background: var(--blue-dark); }
    .batch-table tr:nth-child(even) { background: #f5f5f5; }
    .batch-table tr:hover { background: var(--blue-light); }
    .batch-table tr.batch-selected { background: #c8e6c9 !important; }
    .batch-status-cell { font-size: 11px; }
    .batch-status-done { color: var(--green); font-weight: bold; }
    .batch-status-active { color: var(--orange); }
    .batch-status-pending { color: #999; }
    .batch-actions {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .batch-select-info {
      font-size: 12px;
      color: var(--gray);
      padding: 8px 0;
    }

    /* Verse hover highlight */
    .matrix-cell.verse-glow {
      box-shadow: 0 0 0 2px #fff, 0 0 8px 3px rgba(255,255,255,0.7);
      z-index: 2;
      position: relative;
    }
    .verse-ref-hover {
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 3px;
    }
    .verse-ref-hover:hover { text-decoration-style: solid; }
    #verseTooltip {
      position: fixed;
      background: rgba(0,0,0,0.92);
      color: #e0e0e0;
      padding: 10px 14px;
      border-radius: 6px;
      font-size: 15px;
      font-family: 'Courier New', monospace;
      direction: rtl;
      max-width: 500px;
      line-height: 1.8;
      pointer-events: none;
      display: none;
      z-index: 100;
      border: 1px solid #555;
    }
    #verseTooltip .verse-tooltip-ref {
      font-size: 11px;
      color: #8bb8e8;
      font-family: sans-serif;
      margin-bottom: 4px;
    }

    /* 3D Matrix View */
    .matrix-3d-container {
      height: 450px;
      background: #1a1a2e;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    .matrix-3d-container canvas { display: block; width: 100% !important; height: 100% !important; }
    #btn3DToggle.active { background: #9c27b0; }
    .btn-3d-ctrl { padding: 6px 12px; font-size: 12px; font-weight: 600; cursor: pointer; background: #555; color: #fff; border: none; border-radius: 4px; }
    .btn-3d-ctrl:hover { background: #777; }
    #matrix3DInfo {
      background: #2a2a3d;
      color: #aaa;
      font-size: 12px;
      padding: 8px 14px;
      border-radius: 0 0 8px 8px;
      display: flex;
      gap: 18px;
      flex-wrap: wrap;
    }
    #matrix3DInfo .info-val { color: #8bb8e8; font-weight: bold; }
    #matrix3DTooltip {
      position: absolute;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      z-index: 10;
      white-space: nowrap;
      direction: rtl;
    }

    /* 3D Video Capture Controls */
    #videoControlPanel {
      background: #1e1e30;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 10px 14px;
      margin-top: 8px;
      display: none;
    }
    #videoControlPanel .vid-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 6px;
    }
    #videoControlPanel .vid-row:last-child { margin-bottom: 0; }
    .vid-btn {
      padding: 5px 12px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      color: #fff;
    }
    .vid-btn-rec { background: #c62828; }
    .vid-btn-rec:hover { background: #e53935; }
    .vid-btn-rec.recording { background: #f44336; animation: rec-pulse 1s infinite; }
    @keyframes rec-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.6; } }
    .vid-btn-stop { background: #555; }
    .vid-btn-stop:hover { background: #777; }
    .vid-btn-frame { background: #37474f; }
    .vid-btn-frame:hover { background: #546e7a; }
    .vid-btn-dl { background: #2e7d32; }
    .vid-btn-dl:hover { background: #43a047; }
    #vidTimeline {
      flex: 1;
      min-width: 120px;
      height: 6px;
      appearance: none;
      background: #333;
      border-radius: 3px;
      outline: none;
    }
    #vidTimeline::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #8bb8e8;
      cursor: pointer;
    }
    #vidTimeline::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #8bb8e8;
      cursor: pointer;
      border: none;
    }
    #vidStatus {
      font-size: 12px;
      color: #aaa;
      min-width: 140px;
    }
    #vidStatus .rec-dot { color: #f44336; }
    .vid-label {
      font-size: 11px;
      color: #888;
      white-space: nowrap;
    }
    #vidSpeedSlider {
      width: 80px;
      height: 4px;
      appearance: none;
      background: #444;
      border-radius: 2px;
      outline: none;
    }
    #vidSpeedSlider::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ce93d8;
      cursor: pointer;
    }
    #vidSpeedSlider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ce93d8;
      cursor: pointer;
      border: none;
    }
    #vidFPSSelect {
      background: #2a2a3d;
      color: #ccc;
      border: 1px solid #555;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 11px;
    }

    @media (max-width: 600px) {
      .mode-tab .mode-desc { display: none; }
      .matrix-cell { width: 22px; height: 22px; font-size: 14px; }
      .matrix-3d-container { height: 300px; }
    }
  </style>
</head>
<body>
  <header class="header">
    <a href="bible-codes.html"><img src="img/favicon.png" alt=""></a>
    <h1>Bible Codes</h1>
  </header>

  <main class="container">
    <!-- Mode Tabs -->
    <div class="mode-tabs">
      <button class="mode-tab" data-mode="index" style="opacity:0.5;">
        Index Lookup
        <span class="mode-desc">Instant search (110K words)</span>
      </button>
      <button class="mode-tab active" data-mode="scan">
        Full Scan
        <span class="mode-desc">Search any term</span>
      </button>
      <button class="mode-tab" data-mode="dict" style="opacity:0.5;">
        References
        <span class="mode-desc">Dictionary & Texts</span>
      </button>
      <button class="mode-tab" data-mode="wrr">
        WRR 1994
        <span class="mode-desc">Famous experiment</span>
      </button>
    </div>

    <!-- INDEX MODE -->
    <div id="index-mode" class="mode-content">
      <div id="indexLoading" class="loading">
        <div class="spinner"></div>
        <div>Loading ELS Index...</div>
        <div id="loadProgress" style="margin-top: 10px; font-size: 12px;"></div>
      </div>

      <div id="indexContent" style="display: none;">
        <!-- Stats -->
        <section class="section">
          <h2>Index Statistics</h2>
          <div class="stats-grid" id="statsGrid"></div>
        </section>

        <!-- Multi-term search -->
        <section class="section">
          <h2>Search Terms</h2>

          <div class="save-panel">
            <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
              <input type="text" id="sessionName" placeholder="Session name..." style="flex: 1; min-width: 150px;">
              <button class="btn btn-success btn-small" onclick="saveSession()">Save</button>
              <button class="btn btn-secondary btn-small" onclick="exportResults()">Export</button>
              <button class="btn btn-secondary btn-small" onclick="clearSession()">Clear</button>
            </div>
            <div id="savedSessions"></div>
          </div>

          <div class="term-entries" id="termEntries">
            <div class="term-entry">
              <input type="text" class="term-input" placeholder="Term 1" dir="rtl">
              <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
            </div>
            <div class="term-entry">
              <input type="text" class="term-input" placeholder="Term 2" dir="rtl">
              <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
            </div>
          </div>

          <div class="action-row">
            <button class="btn btn-secondary" onclick="addTerm()">+ Add Term</button>
            <button class="btn" onclick="searchIndex()">Search</button>
          </div>

          <div id="indexResults"></div>
        </section>
      </div>
    </div>

    <!-- SCAN MODE -->
    <div id="scan-mode" class="mode-content active">
      <section class="section">
        <h2>Real-time ELS Scan</h2>
        <p>Scans the entire Torah text for any term. Use this for words not in the index.</p>

        <div class="info-text">
          Text: Koren Edition (Rips et al., 1994) - 304,805 letters
        </div>

        <!-- Search terms input -->
        <div class="batch-panel">
          <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;margin-bottom:10px;">
            <h3 style="margin:0;">Search Terms</h3>
            <div style="display:flex;gap:8px;align-items:center;">
              <button class="heb-kb-toggle" id="hebKbToggle" onclick="toggleHebrewKeyboard()" title="Hebrew Keyboard">⌨ אב</button>
              <input type="file" id="batchFileInput" accept=".txt" onchange="loadBatchFile(this)" style="font-size:13px;max-width:180px;">
              <button class="btn btn-small btn-secondary" onclick="clearBatchInput()">Clear</button>
            </div>
          </div>

          <!-- Hebrew virtual keyboard -->
          <div class="heb-kb-panel" id="hebKbPanel">
            <div class="heb-kb-row">
              <button class="heb-kb-key" data-char="ק">ק</button>
              <button class="heb-kb-key" data-char="ר">ר</button>
              <button class="heb-kb-key" data-char="א">א</button>
              <button class="heb-kb-key" data-char="ט">ט</button>
              <button class="heb-kb-key" data-char="ו">ו</button>
              <button class="heb-kb-key" data-char="ן">ן</button>
              <button class="heb-kb-key" data-char="ם">ם</button>
              <button class="heb-kb-key" data-char="פ">פ</button>
            </div>
            <div class="heb-kb-row">
              <button class="heb-kb-key" data-char="ש">ש</button>
              <button class="heb-kb-key" data-char="ד">ד</button>
              <button class="heb-kb-key" data-char="ג">ג</button>
              <button class="heb-kb-key" data-char="כ">כ</button>
              <button class="heb-kb-key" data-char="ע">ע</button>
              <button class="heb-kb-key" data-char="י">י</button>
              <button class="heb-kb-key" data-char="ח">ח</button>
              <button class="heb-kb-key" data-char="ל">ל</button>
              <button class="heb-kb-key" data-char="ך">ך</button>
              <button class="heb-kb-key" data-char="ף">ף</button>
            </div>
            <div class="heb-kb-row">
              <button class="heb-kb-key" data-char="ז">ז</button>
              <button class="heb-kb-key" data-char="ס">ס</button>
              <button class="heb-kb-key" data-char="ב">ב</button>
              <button class="heb-kb-key" data-char="ה">ה</button>
              <button class="heb-kb-key" data-char="נ">נ</button>
              <button class="heb-kb-key" data-char="מ">מ</button>
              <button class="heb-kb-key" data-char="צ">צ</button>
              <button class="heb-kb-key" data-char="ת">ת</button>
              <button class="heb-kb-key" data-char="ץ">ץ</button>
            </div>
            <div class="heb-kb-row">
              <button class="heb-kb-key wide" data-action="newline">↵ New Line</button>
              <button class="heb-kb-key wide" data-action="space">Space</button>
              <button class="heb-kb-key wide" data-action="backspace">⌫</button>
            </div>
          </div>

          <div style="font-size:13px;color:var(--gray);margin-bottom:10px;line-height:1.6;">
            <strong>One term per line.</strong> Names are auto-cleaned to Hebrew consonants.<br>
            <strong>Alternate spellings:</strong> put variants on the <em>same line</em> separated by spaces.<br>
            <span style="font-size:12px;color:#999;">
              All alternates are searched but only the best-matching one is used per cluster/matrix.<br>
              Example: <code style="background:#f0f0f0;padding:1px 4px;border-radius:2px;direction:rtl;">גוטרי גות'רי</code> &larr; two spellings of Guthrie
            </span>
          </div>
          <textarea id="batchTextarea" class="batch-textarea" placeholder="Enter terms, one per line...&#10;Alternate spellings: same line, space-separated&#10;e.g.&#10;משה&#10;אברהם אבראהם&#10;ירושלים"></textarea>
          <div style="margin-top:8px;">
            <span id="batchParseStatus" style="font-size:13px;color:var(--gray);"></span>
          </div>

          <!-- Parsed preview (shown after search parses terms) -->
          <div id="batchPreview" style="display:none;margin-top:12px;">
            <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
              <strong id="batchPreviewCount" style="color:var(--blue);"></strong>
              <div style="font-size:12px;color:var(--gray);" id="batchTimeEstimate"></div>
            </div>
            <div id="batchPreviewList" class="results-scrollable" style="max-height:200px;margin:10px 0;font-size:13px;border:1px solid var(--border);border-radius:4px;background:white;padding:8px;direction:rtl;"></div>
          </div>

          <!-- Batch results table (populated during search) -->
          <div id="batchResults" style="display:none;margin-top:15px;">
            <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;margin-bottom:8px;">
              <strong style="color:var(--blue);">Batch Results</strong>
              <button class="btn btn-secondary btn-small" id="batchExportBtn" onclick="exportBatchResults()">Export CSV</button>
            </div>
            <div class="results-scrollable" style="max-height:500px;">
              <table class="batch-table" id="batchTable">
                <thead>
                  <tr>
                    <th onclick="sortBatchTable(0)">#</th>
                    <th onclick="sortBatchTable(1)">Original</th>
                    <th onclick="sortBatchTable(2)">Search Term</th>
                    <th onclick="sortBatchTable(3)">Letters</th>
                    <th onclick="sortBatchTable(4)">Hits</th>
                    <th onclick="sortBatchTable(5)">Best Skip</th>
                    <th class="batch-status-cell" onclick="sortBatchTable(6)">Status</th>
                  </tr>
                </thead>
                <tbody id="batchTableBody"></tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="save-panel">
          <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
            <input type="text" id="scanSessionName" placeholder="Session name..." style="flex: 1; min-width: 150px;">
            <button class="btn btn-success btn-small" onclick="saveScanSession()">Save</button>
            <button class="btn btn-secondary btn-small" onclick="exportScanResults()">Export JSON</button>
            <button class="btn btn-secondary btn-small" onclick="clearScanSession()">Clear</button>
          </div>
          <div id="savedScanSessions"></div>
        </div>

        <div class="range-row">
          <label>Skip range: <input type="number" id="minSkip" value="-500"> to <input type="number" id="maxSkip" value="500"></label>
          <span style="font-size: 12px; color: #666;">Skip 0 excluded, ±1 = open text</span>
        </div>

        <div class="action-row">
          <button class="btn" id="scanBtn" onclick="startScan()">Search</button>
          <button class="btn btn-danger" id="scanCancelBtn" onclick="cancelScan()" style="display:none;">Cancel</button>
          <span id="scanStatus" style="font-size: 13px; color: #666;"></span>
        </div>

        <div class="batch-progress" id="scanProgress" style="display:none;">
          <div class="batch-progress-bar" id="scanProgressBar" style="width:0%;">0%</div>
        </div>

        <div id="scanResults"></div>

        <!-- Inline Matrix View -->
        <div id="scanMatrixView" class="matrix-view" style="display:none;">
          <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
            <h3 id="scanMatrixTitle">Matrix View</h3>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="btn btn-small" id="btn3DToggle" onclick="toggle3DView()">3D View</button>
              <button class="btn-3d-ctrl" id="btn3DPause" onclick="toggle3DAutoRotate()" style="display:none;">Pause Rotation</button>
              <button class="btn-3d-ctrl" id="btn3DReset" onclick="reset3DCamera()" style="display:none;">Reset Camera</button>
              <button class="btn-3d-ctrl" id="btn3DVideo" onclick="vidShowPanel()" style="display:none;background:#c62828;">Video</button>
              <button class="btn btn-small" onclick="downloadMatrixPNG()" style="background:#666;">Download PNG</button>
              <button class="btn btn-small" id="btnDiscoverTerms" onclick="discoverMatrixTerms()" style="background:#2e7d32;" title="Find all dictionary-validated ELS terms in this matrix region">Discover Terms</button>
              <span style="display:inline-flex;gap:8px;align-items:center;font-size:11px;color:#333;margin-left:4px;">
                <label style="cursor:pointer;" title="Show all dictionary terms"><input type="checkbox" id="discFilterAll" checked onchange="applyDiscoverFilter()"> All</label>
                <label style="cursor:pointer;" title="Show only names"><input type="checkbox" id="discFilterNames" onchange="applyDiscoverFilter()"> Names</label>
                <label style="cursor:pointer;" title="Show only dates/numbers"><input type="checkbox" id="discFilterDates" onchange="applyDiscoverFilter()"> Dates</label>
              </span>
            </div>
          </div>
          <div id="scanMatrixStats" class="matrix-stats"></div>
          <div id="scanMatrix2D">
            <div class="matrix-container" style="max-height:400px;">
              <div class="matrix-grid" id="scanMatrixGrid"></div>
            </div>
          </div>
          <div id="scanMatrix3D" style="display:none;">
            <div class="matrix-3d-container" id="matrix3DCanvas">
              <div id="matrix3DTooltip"></div>
            </div>
            <div id="matrix3DInfo" style="display:none;"></div>
            <div id="videoControlPanel">
              <div class="vid-row">
                <button class="vid-btn vid-btn-rec" id="vidRecBtn" onclick="vidToggleRecord()">Record</button>
                <button class="vid-btn vid-btn-frame" onclick="vidCaptureFrame()" title="Capture single frame">+ Frame</button>
                <button class="vid-btn vid-btn-frame" onclick="vidStepRotation(-1)" title="Step back 5 degrees">&#9664; Step</button>
                <button class="vid-btn vid-btn-frame" onclick="vidStepRotation(1)" title="Step forward 5 degrees">Step &#9654;</button>
                <span id="vidStatus">Ready</span>
              </div>
              <div class="vid-row">
                <span class="vid-label">Timeline:</span>
                <input type="range" id="vidTimeline" min="0" max="100" value="0" step="1" oninput="vidSeekTimeline(this.value)" disabled>
                <span class="vid-label" id="vidTimeDisplay">0:00 / 0:00</span>
              </div>
              <div class="vid-row">
                <span class="vid-label">Rotation speed:</span>
                <input type="range" id="vidSpeedSlider" min="0" max="5" value="1" step="0.1" oninput="vidSetSpeed(this.value)">
                <span class="vid-label" id="vidSpeedLabel">1.0x</span>
                <span class="vid-label" style="margin-left:12px;">FPS:</span>
                <select id="vidFPSSelect">
                  <option value="24">24</option>
                  <option value="30" selected>30</option>
                  <option value="60">60</option>
                </select>
                <span class="vid-label" style="margin-left:12px;">Format:</span>
                <select id="vidFormatSelect" title="Select format BEFORE recording">
                  <option value="webm">WebM (default)</option>
                  <option value="gif">GIF (universal)</option>
                </select>
                <span class="vid-label" style="font-size:.7em;color:#888" id="vidFormatNote">Select before recording</span>
                <button class="vid-btn vid-btn-dl" id="vidDownloadBtn" onclick="vidDownload()" style="margin-left:auto;display:none;">Download Video</button>
              </div>
            </div>
          </div>
          <div class="matrix-legend" id="scanMatrixLegend"></div>
          <div id="discoverTermsPanel" style="display:none;margin-top:12px;border:1px solid #ddd;border-radius:8px;padding:12px;background:#f9f9f9;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
              <h4 style="margin:0;font-size:14px;">Discovered ELS Terms in Matrix Region</h4>
              <span id="discoverTermsStatus" style="font-size:12px;color:#666;"></span>
            </div>
            <div id="discoverTermsResults" style="max-height:300px;overflow-y:auto;"></div>
          </div>
        </div>
      </section>
    </div>

    <!-- DICTIONARY MODE -->
    <div id="dict-mode" class="mode-content">
      <section class="section">
        <h2>References & Texts</h2>

        <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px;margin-bottom:20px;">
          <a href="test-dictionaries.html" style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--green);text-decoration:none;display:block;cursor:pointer;">
            <strong style="color:var(--blue);">Hebrew Dictionary</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">BDB, Strong's, 260K words</p>
            <span style="font-size:11px;color:var(--green);">Active</span>
          </a>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Mikraot Gedolot</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Rashi, Ibn Ezra, Ramban, etc.</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Talmud Bavli</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Babylonian Talmud full text</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Mishna</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Six orders, full text</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Zohar</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Mystical commentary</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Midrash</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Midrash Rabbah, Tanchuma</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
        </div>

        <p style="font-size:13px;color:var(--gray);">Cross-reference and search across classical Hebrew texts. Data sourced from Sefaria and open-access repositories.</p>
      </section>
    </div>

    <!-- WRR 1994 MODE -->
    <div id="wrr-mode" class="mode-content">
      <section class="section">
        <h2 style="display:flex;align-items:center;gap:10px;">
          WRR 1994 Experiment
          <span style="font-size:12px;padding:3px 8px;background:linear-gradient(135deg,#667eea,#764ba2);color:white;border-radius:12px;">Academic Replication</span>
        </h2>
        <p style="font-size:14px;color:var(--gray);margin-bottom:16px;">
          Replication of the famous experiment by Witztum, Rips &amp; Rosenberg published in
          <em>Statistical Science</em> (1994). 32 rabbis from the <em>Encyclopedia of Great Men in Israel</em>,
          each paired with Hebrew death dates. The proximity of name-date ELS pairs in Genesis was found to be
          statistically significant at <strong>p = 0.000016</strong> (1 in 62,500).
        </p>

        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:20px;">
          <div style="background:linear-gradient(135deg,#667eea22,#764ba222);padding:14px;border-radius:8px;text-align:center;">
            <div style="font-size:28px;font-weight:bold;color:var(--blue);" id="wrrStatRabbis">32</div>
            <div style="font-size:12px;color:var(--gray);" id="wrrStatRabbisLabel">Rabbis (List 2)</div>
          </div>
          <div style="background:linear-gradient(135deg,#667eea22,#764ba222);padding:14px;border-radius:8px;text-align:center;">
            <div style="font-size:28px;font-weight:bold;color:var(--blue);">78,064</div>
            <div style="font-size:12px;color:var(--gray);" id="wrrStatTextLabel">Letters in Genesis</div>
          </div>
          <div style="background:linear-gradient(135deg,#667eea22,#764ba222);padding:14px;border-radius:8px;text-align:center;">
            <div style="font-size:28px;font-weight:bold;color:var(--blue);">p &lt; 1/62,500</div>
            <div style="font-size:12px;color:var(--gray);">Published P-value (List 2)</div>
          </div>
        </div>

        <!-- List & Text selectors -->
        <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;align-items:center;">
          <label style="font-size:13px;color:var(--gray);display:flex;align-items:center;gap:4px;">
            Rabbi list:
            <select id="wrrListSelect" onchange="wrrSwitchList(this.value)" style="padding:4px 8px;border:1px solid var(--border);border-radius:4px;font-size:13px;">
              <option value="list2" selected>List 2 (32 rabbis)</option>
              <option value="list1">List 1 (34 rabbis)</option>
            </select>
          </label>
          <label style="font-size:13px;color:var(--gray);display:flex;align-items:center;gap:4px;">
            Text:
            <select id="wrrTextSelect" onchange="wrrSwitchText(this.value)" style="padding:4px 8px;border:1px solid var(--border);border-radius:4px;font-size:13px;">
              <option value="genesis" selected>Genesis (Koren)</option>
              <option value="tolstoy">War and Peace (Tolstoy)</option>
            </select>
          </label>
          <span id="wrrTextNote" style="font-size:11px;color:#999;"></span>
        </div>

        <!-- Controls -->
        <div style="display:flex;gap:10px;margin-bottom:16px;flex-wrap:wrap;align-items:center;">
          <button class="btn" id="wrrRunBtn" onclick="runWRRExperiment()" style="background:linear-gradient(135deg,#667eea,#764ba2);font-size:15px;padding:10px 24px;">
            Quick Run
          </button>
          <button class="btn" id="wrrFullBtn" onclick="wrrRunFullExperiment()" style="background:linear-gradient(135deg,#1b5e20,#388e3c);font-size:15px;padding:10px 24px;color:#fff;border:none;border-radius:6px;cursor:pointer;" title="Full WRR replication with c(w,w') perturbation statistic, P&#8321;-P&#8324;">
            Run Full WRR (c statistic)
          </button>
          <button class="btn btn-secondary" id="wrrCancelBtn" onclick="cancelWRR()" style="display:none;">Cancel</button>
          <label style="font-size:13px;color:var(--gray);display:flex;align-items:center;gap:4px;" title="Maximum |skip| searched per term. Higher = more thorough but slower.">
            Skip cap:
            <input type="number" id="wrrSkipCap" value="1000" min="100" max="10000" step="100"
              style="width:80px;padding:4px 6px;border:1px solid var(--border);border-radius:4px;font-size:13px;">
          </label>
          <span id="wrrProgress" style="font-size:13px;color:var(--gray);"></span>
        </div>

        <!-- Progress bar -->
        <div id="wrrProgressBar" style="display:none;margin-bottom:16px;">
          <div style="background:#eee;border-radius:4px;height:8px;overflow:hidden;">
            <div id="wrrProgressFill" style="background:linear-gradient(90deg,#667eea,#764ba2);height:100%;width:0%;transition:width 0.3s;border-radius:4px;"></div>
          </div>
          <div id="wrrProgressText" style="font-size:12px;color:var(--gray);margin-top:4px;"></div>
        </div>

        <!-- Results summary -->
        <div id="wrrSummary" style="display:none;margin-bottom:16px;padding:16px;background:linear-gradient(135deg,#e8f5e9,#c8e6c9);border-radius:8px;border:1px solid #a5d6a7;">
        </div>

        <!-- Rabbi table -->
        <div style="margin-bottom:8px;font-weight:600;color:var(--blue);" id="wrrTableLabel">Rabbi List (WRR List 2)</div>
        <div style="overflow-x:auto;max-height:500px;overflow-y:auto;border:1px solid var(--border);border-radius:6px;">
          <table id="wrrTable" style="width:100%;border-collapse:collapse;font-size:13px;">
            <thead style="position:sticky;top:0;background:var(--blue);color:white;z-index:1;">
              <tr>
                <th style="padding:8px 4px;text-align:center;font-weight:600;">#</th>
                <th style="padding:8px 4px;text-align:left;font-weight:600;">Rabbi</th>
                <th style="padding:8px 4px;text-align:right;font-weight:600;direction:rtl;">Appellations</th>
                <th style="padding:8px 4px;text-align:right;font-weight:600;direction:rtl;">Date</th>
                <th style="padding:8px 4px;text-align:center;font-weight:600;">Pairs</th>
                <th style="padding:8px 4px;text-align:center;font-weight:600;" title="Dynamic max |skip| searched (based on expected ELS occurrences)">D(w)</th>
                <th style="padding:8px 4px;text-align:center;font-weight:600;" title="Quick Run: Δ = min 2D distance. Full WRR: c(w,w') = perturbation rank (0..1, lower = more significant)" id="wrrColHeader">&Delta;</th>
              </tr>
            </thead>
            <tbody id="wrrTableBody"></tbody>
          </table>
        </div>

        <!-- Methodology -->
        <details style="margin-top:16px;">
          <summary style="cursor:pointer;font-weight:600;color:var(--blue);font-size:14px;">Methodology Details</summary>
          <div style="padding:12px;font-size:13px;color:#555;line-height:1.7;">
            <p><strong>Source:</strong> Witztum, Rips &amp; Rosenberg, &ldquo;Equidistant Letter Sequences in the Book of Genesis&rdquo;,
            <em>Statistical Science</em>, Vol. 9, No. 3, August 1994, pp. 429&ndash;438.</p>
            <p><strong>Text:</strong> Genesis (Koren edition), 78,064 consonantal Hebrew letters. Final letter forms (sofiot)
            normalized to standard forms for matching.</p>
            <p><strong>ELS Definition:</strong> For skip value d (|d| &ge; 2), letters at positions h, h+d, h+2d, &hellip;, h+(n&minus;1)d.
            Skip &plusmn;1 (open text) is excluded per the WRR protocol.</p>
            <p><strong>Skip Range D(w):</strong> Dynamic per term. For word w of length k with letter probabilities p<sub>i</sub>,
            expected ELS count at skip d: E(w,d) = (L &minus; (k&minus;1)d) &sdot; &prod;p<sub>i</sub>.
            D(w) is the smallest d where &sum;<sub>d=2..D</sub> E(w,d) &ge; 10, capped at user maximum.</p>
            <p><strong>Distance &Delta;:</strong> Text arranged as 2D array with |d| columns. Position p maps to
            row&nbsp;=&nbsp;&lfloor;p/|d|&rfloor;, col&nbsp;=&nbsp;p&nbsp;mod&nbsp;|d|.
            &Delta; = min Euclidean distance between any name-ELS letter and any date-ELS letter.
            Both array widths (|d<sub>name</sub>| and |d<sub>date</sub>|) tested; smaller distance reported.</p>
            <p><strong>Original significance:</strong> 999,999 random permutations of name-date assignments tested.
            Actual assignment ranked 4th of 1,000,000, yielding <strong>p &lt; 1/62,500</strong>.</p>
            <p><strong>This replication:</strong> Two modes available:
            <em>Quick Run</em> uses the 2D cylindrical proximity measure with dynamic D(w) and
            both forward and backward ELS (|d|&nbsp;&ge;&nbsp;2).
            <em>Full WRR</em> additionally computes the <strong>c(w,w&prime;) perturbation statistic</strong>:
            125 spatial perturbations (triples (x,y,z) &isin; {&minus;2..2}&sup3;) shift the last 3 ELS letter positions
            by cumulative (x, x+y, x+y+z). Proximity &omega; = max(1/&delta;) across 10 row lengths
            h<sub>i</sub>&nbsp;=&nbsp;round(|d|/i). Then P&#8321; (binomial tail on c&lt;0.2 count) and
            P&#8322; (Gamma CDF on &prod;c) yield the overall statistic P&nbsp;=&nbsp;2&middot;min(P&#8321;,P&#8322;).</p>
            <p><strong>Data:</strong> Appellations and dates from WRR Table 3 (Appendix). Rabbis #4 and #8
            excluded&mdash;no recorded death dates.</p>
          </div>
        </details>
      </section>
    </div>
  </main>

  <footer style="max-width:900px;margin:20px auto;padding:12px 20px;font-size:13px;color:#888;text-align:center;border-top:1px solid #ddd;">
    <span>Other Tools:</span>
    <a href="text-search.html" style="color:#1e5aa8;margin:0 6px;">Text Search</a> |
    <a href="gematria.html" style="color:#1e5aa8;margin:0 6px;">Gematria</a> |
    <a href="acronym.html" style="color:#1e5aa8;margin:0 6px;">Acronyms</a> |
    <a href="tsirufim.html" style="color:#1e5aa8;margin:0 6px;">Tsirufim</a> |
    <a href="matrix-view.html" style="color:#1e5aa8;margin:0 6px;">Matrix View</a> |
    <a href="book-view.html" style="color:#1e5aa8;margin:0 6px;">Book View</a> |
    <a href="other-resources.html" style="color:#1e5aa8;margin:0 6px;">Other Resources</a>
  </footer>

  <div id="verseTooltip"></div>

  <script type="module">
    import { getElsIndexService, initElsIndex } from './engines/els-index.js';
    import { getDictionaryService, initDictionaries } from './engines/dictionary-service.js';

    let elsService = null;
    let dictService = null;
    let torahText = null;
    let currentResults = null;

    // ============= MODE SWITCHING =============
    document.querySelectorAll('.mode-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.mode + '-mode').classList.add('active');
      });
    });

    // ============= INIT =============
    async function init() {
      try {
        document.getElementById('loadProgress').textContent = 'Loading Torah text...';
        const resp = await fetch('data/torahNoSpaces.txt');
        torahText = await resp.text();

        document.getElementById('loadProgress').textContent = 'Loading ELS index (32MB)...';
        const metadata = await initElsIndex('data/els-index/els-index-50-min4.json.gz');
        elsService = getElsIndexService();

        document.getElementById('indexLoading').style.display = 'none';
        document.getElementById('indexContent').style.display = 'block';

        displayStats(metadata);
        loadSavedSessions();

      } catch (error) {
        console.error('Init failed:', error);
        document.getElementById('indexLoading').innerHTML =
          `<div style="color: red;">Error loading index: ${error.message}</div>`;
      }
    }

    function displayStats(meta) {
      document.getElementById('statsGrid').innerHTML = `
        <div class="stat-box"><div class="value">${meta.total_words?.toLocaleString() || '?'}</div><div class="label">Words</div></div>
        <div class="stat-box"><div class="value">${meta.total_occurrences?.toLocaleString() || '?'}</div><div class="label">Occurrences</div></div>
        <div class="stat-box"><div class="value">±${meta.skip_range?.[1] || '?'}</div><div class="label">Skip Range</div></div>
        <div class="stat-box"><div class="value">${meta.torah_length?.toLocaleString() || '?'}</div><div class="label">Letters</div></div>
      `;
    }

    // ============= INDEX MODE: TERM MANAGEMENT =============
    window.addTerm = function() {
      const container = document.getElementById('termEntries');
      const n = container.querySelectorAll('.term-entry').length + 1;
      const div = document.createElement('div');
      div.className = 'term-entry';
      div.innerHTML = `<input type="text" class="term-input" placeholder="Term ${n}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
      container.appendChild(div);
    };

    window.removeTerm = function(btn) {
      const container = document.getElementById('termEntries');
      if (container.querySelectorAll('.term-entry').length > 1) {
        btn.parentElement.remove();
      }
    };

    // ============= INDEX MODE: SEARCH =============
    window.searchIndex = function() {
      const inputs = document.querySelectorAll('.term-input');
      const terms = Array.from(inputs).map(i => i.value.trim()).filter(t => t);

      if (terms.length < 1) { alert('Enter at least one term'); return; }

      const termData = {};
      for (const term of terms) {
        const occs = elsService.findWord(term);
        termData[term] = { occurrences: occs, count: occs.length };
      }

      // Compute proximity pairs if multiple terms
      const proximityPairs = [];
      if (terms.length > 1) {
        for (let i = 0; i < terms.length; i++) {
          for (let j = i + 1; j < terms.length; j++) {
            const prox = elsService.pairProximity(terms[i], terms[j]);
            if (prox) {
              proximityPairs.push({
                term1: terms[i], term2: terms[j],
                distance: prox.distance,
                pos1: prox.word1.pos, skip1: prox.word1.skip,
                pos2: prox.word2.pos, skip2: prox.word2.skip
              });
            }
          }
        }
        proximityPairs.sort((a, b) => a.distance - b.distance);
      }

      currentResults = { terms, termData, proximityPairs, timestamp: new Date().toISOString() };
      displayIndexResults(currentResults);
    };

    function displayIndexResults(results) {
      const { terms, termData, proximityPairs } = results;

      let html = '<div class="results"><h3>Term Occurrences</h3>';
      html += '<table class="results-table"><tr><th>Term</th><th>Count</th><th>First Pos</th></tr>';
      for (const term of terms) {
        const d = termData[term];
        const firstPos = d.occurrences[0]?.pos ?? 'N/A';
        html += `<tr><td><strong>${term}</strong></td><td>${d.count.toLocaleString()}</td><td>${typeof firstPos === 'number' ? firstPos.toLocaleString() : firstPos}</td></tr>`;
      }
      html += '</table>';

      if (terms.length > 1) {
        // Proximity matrix
        const { matrix } = elsService.computeProximityMatrix(terms);
        html += '<h3 style="margin-top:20px;">Proximity Matrix</h3><div class="proximity-matrix"><table><tr><th></th>';
        terms.forEach(t => html += `<th>${t}</th>`);
        html += '</tr>';
        for (let i = 0; i < terms.length; i++) {
          html += `<tr><th>${terms[i]}</th>`;
          for (let j = 0; j < terms.length; j++) {
            const d = matrix[i][j];
            const cls = d === 0 ? '' : d < 500 ? 'cell-close' : d < 2000 ? 'cell-medium' : 'cell-far';
            html += `<td class="${cls}">${d === Infinity ? '∞' : d.toLocaleString()}</td>`;
          }
          html += '</tr>';
        }
        html += '</table></div>';

        // Pair details
        html += `<h3 style="margin-top:20px;">Proximity Pairs (${proximityPairs.length})</h3>`;
        html += '<div class="results-scrollable"><table class="results-table">';
        html += '<tr><th>#</th><th>Term 1</th><th>Term 2</th><th>Distance</th><th>Pos 1</th><th>Skip 1</th><th>Pos 2</th><th>Skip 2</th></tr>';
        proximityPairs.forEach((p, idx) => {
          const cls = p.distance < 500 ? 'cell-close' : p.distance < 2000 ? 'cell-medium' : 'cell-far';
          html += `<tr class="clickable-row" onclick="showIndexMatrix(${idx})" data-idx="${idx}">
            <td>${idx + 1}</td><td>${p.term1}</td><td>${p.term2}</td>
            <td class="${cls}">${p.distance.toLocaleString()}</td>
            <td>${p.pos1.toLocaleString()}</td><td>${p.skip1}</td>
            <td>${p.pos2.toLocaleString()}</td><td>${p.skip2}</td>
          </tr>`;
        });
        html += '</table></div>';

        // Matrix view area
        html += `<div id="indexMatrixView" class="matrix-view">
          <h3>Matrix View</h3>
          <p class="hint">Click a row above to view the matrix.</p>
          <div id="indexMatrixDisplay"></div>
        </div>`;
      }

      html += '</div>';
      document.getElementById('indexResults').innerHTML = html;
    }

    window.showIndexMatrix = function(idx) {
      if (!currentResults || !torahText) return;
      const pair = currentResults.proximityPairs[idx];
      if (!pair) return;

      document.querySelectorAll('.clickable-row').forEach(r => r.classList.remove('selected'));
      document.querySelector(`.clickable-row[data-idx="${idx}"]`)?.classList.add('selected');

      // Use skip value as width for proper alignment, or default to 30
      const width = Math.max(Math.abs(pair.skip1), Math.abs(pair.skip2), 30);

      const t1Pos = new Set();
      const t2Pos = new Set();
      for (let i = 0; i < pair.term1.length; i++) t1Pos.add(pair.pos1 + i * pair.skip1);
      for (let i = 0; i < pair.term2.length; i++) t2Pos.add(pair.pos2 + i * pair.skip2);

      // Compute row range from actual term positions (with context padding)
      const allTermPositions = [...t1Pos, ...t2Pos];
      const padding = 3;
      const startRow = Math.max(0, Math.floor(Math.min(...allTermPositions) / width) - padding);
      const endRow = Math.floor(Math.max(...allTermPositions) / width) + padding;

      // Build grid-based matrix like the popup
      let gridHtml = '';
      for (let row = startRow; row <= endRow; row++) {
        const rowStart = row * width;
        if (rowStart < 0) continue;
        for (let col = 0; col < width; col++) {
          const pos = rowStart + col;
          if (pos >= torahText.length) break;
          const ch = torahText[pos];
          const in1 = t1Pos.has(pos), in2 = t2Pos.has(pos);
          let cls = 'matrix-cell';
          if (in1 && in2) cls += ' term1 term2';
          else if (in1) cls += ' term1';
          else if (in2) cls += ' term2';
          gridHtml += `<div class="${cls}">${ch}</div>`;
        }
      }

      const statsHtml = `
        <div class="matrix-stats" style="margin-bottom:15px;">
          <div class="matrix-stat"><div class="value" style="color:#ffc107;">${pair.term1}</div><div class="label">Term 1</div></div>
          <div class="matrix-stat"><div class="value" style="color:#00bcd4;">${pair.term2}</div><div class="label">Term 2</div></div>
          <div class="matrix-stat"><div class="value">${pair.distance.toLocaleString()}</div><div class="label">Distance</div></div>
          <div class="matrix-stat"><div class="value">${pair.skip1}</div><div class="label">Skip 1</div></div>
          <div class="matrix-stat"><div class="value">${pair.skip2}</div><div class="label">Skip 2</div></div>
          <div class="matrix-stat"><div class="value">${pair.pos1.toLocaleString()}</div><div class="label">Pos 1</div></div>
          <div class="matrix-stat"><div class="value">${pair.pos2.toLocaleString()}</div><div class="label">Pos 2</div></div>
        </div>
        <div class="matrix-container" style="max-height:400px;">
          <div class="matrix-grid" style="grid-template-columns:repeat(${width}, 26px);">${gridHtml}</div>
        </div>
        <div class="matrix-legend" style="margin-top:15px;">
          <div class="legend-item"><div class="legend-color t1"></div><span>${pair.term1}</span></div>
          <div class="legend-item"><div class="legend-color t2"></div><span>${pair.term2}</span></div>
          <div class="legend-item"><div class="legend-color both"></div><span>Overlap</span></div>
        </div>
      `;

      document.getElementById('indexMatrixDisplay').innerHTML = statsHtml;

      // Set current3DHits for index mode (convert pair to hits format)
      current3DHits = [
        { pos: pair.pos1, skip: pair.skip1, term: pair.term1, termIdx: 0 },
        { pos: pair.pos2, skip: pair.skip2, term: pair.term2, termIdx: 1 }
      ];
    };

    // ============= INDEX MODE: SESSIONS =============
    window.saveSession = function() {
      if (!currentResults) { alert('No results to save'); return; }
      const name = document.getElementById('sessionName').value.trim() || `Search ${new Date().toLocaleTimeString()}`;
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      sessions.unshift({ name, results: currentResults, savedAt: new Date().toISOString() });
      if (sessions.length > 20) sessions.length = 20;
      localStorage.setItem('elsSearchSessions', JSON.stringify(sessions));
      loadSavedSessions();
      document.getElementById('sessionName').value = '';
    };

    window.loadSession = function(idx) {
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      if (!sessions[idx]) return;
      const session = sessions[idx];
      currentResults = session.results;
      const container = document.getElementById('termEntries');
      container.innerHTML = '';
      session.results.terms.forEach(term => {
        const div = document.createElement('div');
        div.className = 'term-entry';
        div.innerHTML = `<input type="text" class="term-input" value="${term}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
        container.appendChild(div);
      });
      displayIndexResults(currentResults);
    };

    window.deleteSession = function(idx) {
      if (!confirm('Delete session?')) return;
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      sessions.splice(idx, 1);
      localStorage.setItem('elsSearchSessions', JSON.stringify(sessions));
      loadSavedSessions();
    };

    function loadSavedSessions() {
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      const container = document.getElementById('savedSessions');
      if (sessions.length === 0) {
        container.innerHTML = '<p style="font-size: 12px; color: #666; margin-top: 10px;">No saved sessions</p>';
        return;
      }
      let html = '';
      sessions.forEach((s, i) => {
        html += `<div class="saved-item">
          <div><span class="name">${s.name}</span><br><span class="meta">${s.results.terms.join(', ')}</span></div>
          <div><button class="btn btn-small btn-secondary" onclick="loadSession(${i})">Load</button>
          <button class="btn btn-small btn-danger" onclick="deleteSession(${i})">×</button></div>
        </div>`;
      });
      container.innerHTML = html;
    }

    window.exportResults = function() {
      if (!currentResults) { alert('No results'); return; }
      const blob = new Blob([JSON.stringify(currentResults, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = `els-search-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    };

    window.clearSession = function() {
      if (!confirm('Clear all?')) return;
      document.getElementById('termEntries').innerHTML = `
        <div class="term-entry"><input type="text" class="term-input" placeholder="Term 1" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button></div>
        <div class="term-entry"><input type="text" class="term-input" placeholder="Term 2" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button></div>`;
      document.getElementById('indexResults').innerHTML = '';
      currentResults = null;
    };

    // ============= SCAN MODE =============
    const TERM_COLORS = ['#ffc107','#00bcd4','#ff5722','#4caf50','#e91e63','#3f51b5','#795548','#607d8b'];
    const BOOK_NAMES = {
      1:'Genesis',2:'Exodus',3:'Leviticus',4:'Numbers',5:'Deuteronomy',
      6:'Joshua',7:'Judges',8:'1 Samuel',9:'2 Samuel',10:'1 Kings',
      11:'2 Kings',12:'Isaiah',13:'Jeremiah',14:'Ezekiel',15:'Hosea',
      16:'Joel',17:'Amos',18:'Obadiah',19:'Jonah',20:'Micah',
      21:'Nahum',22:'Habakkuk',23:'Zephaniah',24:'Haggai',25:'Zechariah',
      26:'Malachi',27:'Psalms',28:'Proverbs',29:'Job',30:'Song of Songs',
      31:'Ruth',32:'Lamentations',33:'Ecclesiastes',34:'Esther',35:'Daniel',
      36:'Ezra',37:'Nehemiah',38:'1 Chronicles',39:'2 Chronicles'
    };
    const TORAH_BOOKS = ['genesis','exodus','leviticus','numbers','deuteronomy'];

    // --- Hebrew virtual keyboard ---
    let hebKbTarget = null; // the textarea/input that receives keyboard chars

    window.toggleHebrewKeyboard = function() {
      const panel = document.getElementById('hebKbPanel');
      const btn = document.getElementById('hebKbToggle');
      const isOpen = panel.classList.toggle('open');
      btn.classList.toggle('active', isOpen);
      if (isOpen) {
        hebKbTarget = document.getElementById('batchTextarea');
        hebKbTarget.focus();
      }
    };

    // Prevent keyboard keys from stealing focus from textarea
    document.addEventListener('mousedown', function(e) {
      if (e.target.closest('.heb-kb-key')) e.preventDefault();
    });

    // Keyboard click handler — insert character at cursor position in target
    document.addEventListener('click', function(e) {
      const key = e.target.closest('.heb-kb-key');
      if (!key) return;
      e.preventDefault();
      const target = hebKbTarget || document.getElementById('batchTextarea');
      const action = key.dataset.action;
      const ch = key.dataset.char;
      const start = target.selectionStart;
      const end = target.selectionEnd;
      const val = target.value;

      if (action === 'backspace') {
        if (start > 0 || start !== end) {
          const delStart = start === end ? start - 1 : start;
          target.value = val.slice(0, delStart) + val.slice(end);
          target.selectionStart = target.selectionEnd = delStart;
        }
      } else if (action === 'newline') {
        target.value = val.slice(0, start) + '\n' + val.slice(end);
        target.selectionStart = target.selectionEnd = start + 1;
      } else if (action === 'space') {
        target.value = val.slice(0, start) + ' ' + val.slice(end);
        target.selectionStart = target.selectionEnd = start + 1;
      } else if (ch) {
        target.value = val.slice(0, start) + ch + val.slice(end);
        target.selectionStart = target.selectionEnd = start + 1;
      }
      target.focus();
    });

    // --- Character database for verse attribution ---
    let charDatabase = null;

    async function loadCharDB() {
      if (charDatabase) return;
      try {
        const allChars = [];
        for (const book of TORAH_BOOKS) {
          const resp = await fetch(`data/${book}-chars.json.gz`);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const ds = new DecompressionStream('gzip');
          const text = await new Response(blob.stream().pipeThrough(ds)).text();
          allChars.push(...JSON.parse(text));
        }
        if (allChars.length > 0) charDatabase = allChars;
      } catch (e) {
        console.log('Character database not available:', e.message);
      }
    }

    function getVerseForPosition(pos) {
      if (!charDatabase || pos < 0 || pos >= charDatabase.length) return null;
      const ch = charDatabase[pos];
      if (!ch) return null;
      const bookName = BOOK_NAMES[ch.book] || `Book ${ch.book}`;
      return `${bookName} ${ch.chapter}:${ch.verse}`;
    }

    function getVersesForHit(pos, skip, termLen) {
      if (!charDatabase) return [];
      const seen = new Set();
      const verses = [];
      for (let i = 0; i < termLen; i++) {
        const p = pos + i * skip;
        const v = getVerseForPosition(p);
        if (v && !seen.has(v)) { seen.add(v); verses.push(v); }
      }
      return verses;
    }

    // --- Verse hover: text reconstruction + matrix highlight ---
    let verseTextCache = new Map();

    function getVerseKey(pos) {
      if (!charDatabase || pos < 0 || pos >= charDatabase.length) return null;
      const ch = charDatabase[pos];
      if (!ch) return null;
      return `${ch.book}:${ch.chapter}:${ch.verse}`;
    }

    function getVerseTextByKey(key) {
      if (verseTextCache.has(key)) return verseTextCache.get(key);
      if (!charDatabase) return null;
      const [bookStr, chapStr, verseStr] = key.split(':');
      const book = +bookStr, chap = +chapStr, verse = +verseStr;
      let text = '';
      let lastWordIdx = -1;
      for (let i = 0; i < charDatabase.length; i++) {
        const ch = charDatabase[i];
        if (ch.book === book && ch.chapter === chap && ch.verse === verse) {
          if (ch.word_index !== undefined && ch.word_index !== lastWordIdx && lastWordIdx !== -1) {
            text += ' ';
          }
          text += ch.base_char || torahText[i];
          if (ch.word_index !== undefined) lastWordIdx = ch.word_index;
        } else if (ch.book > book || (ch.book === book && ch.chapter > chap) ||
                   (ch.book === book && ch.chapter === chap && ch.verse > verse)) {
          break; // past our verse, stop early
        }
      }
      if (text) verseTextCache.set(key, text);
      return text || null;
    }

    // Positions of current hits by verse key: Map<verseKey, Set<pos>>
    let currentHitVerseMap = null;

    function buildHitVerseMap(hits) {
      currentHitVerseMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          const vk = getVerseKey(p);
          if (vk) {
            if (!currentHitVerseMap.has(vk)) currentHitVerseMap.set(vk, new Set());
            currentHitVerseMap.get(vk).add(p);
          }
        }
      }
    }

    window.onVerseHover = function(verseKey, verseLabel, event) {
      // 1. Show tooltip with verse text
      const tooltip = document.getElementById('verseTooltip');
      const text = getVerseTextByKey(verseKey);
      if (text) {
        tooltip.innerHTML = `<div class="verse-tooltip-ref">${verseLabel}</div>${text}`;
        tooltip.style.display = 'block';
        // Position near cursor — use requestAnimationFrame so offsetHeight is computed
        const x = event.clientX, y = event.clientY;
        requestAnimationFrame(() => {
          const th = tooltip.offsetHeight || 60;
          const maxLeft = Math.max(0, window.innerWidth - tooltip.offsetWidth - 20);
          tooltip.style.left = Math.min(x + 15, maxLeft) + 'px';
          tooltip.style.top = (y > window.innerHeight / 2 ? Math.max(0, y - th - 10) : y + 20) + 'px';
        });
      } else if (verseLabel) {
        // Fallback: show just the reference even without verse text
        tooltip.innerHTML = `<div class="verse-tooltip-ref">${verseLabel}</div><em style="color:#888;">Verse text not available</em>`;
        tooltip.style.display = 'block';
        tooltip.style.left = (event.clientX + 15) + 'px';
        tooltip.style.top = (event.clientY + 20) + 'px';
      }

      // 2. Highlight matching cells in matrix
      if (currentHitVerseMap && currentHitVerseMap.has(verseKey)) {
        const positions = currentHitVerseMap.get(verseKey);
        const grid = document.getElementById('scanMatrixGrid');
        if (grid) {
          for (const cell of grid.children) {
            const pos = parseInt(cell.dataset.pos);
            if (positions.has(pos)) cell.classList.add('verse-glow');
          }
        }
      }
    };

    window.onVerseLeave = function() {
      document.getElementById('verseTooltip').style.display = 'none';
      const grid = document.getElementById('scanMatrixGrid');
      if (grid) {
        for (const cell of grid.children) cell.classList.remove('verse-glow');
      }
    };

    // Helper to create hoverable verse span HTML
    function makeVerseSpans(versesArray) {
      if (!versesArray || versesArray.length === 0) return '';
      return versesArray.map(v => {
        // Parse "BookName chapter:verse" to get key
        // We need to reverse-map: find a position with this verse label to get the key
        const verseKey = findVerseKeyByLabel(v);
        if (!verseKey) return v;
        const escaped = v.replace(/"/g, '&quot;');
        return `<span class="verse-ref-hover" onmouseenter="onVerseHover('${verseKey}','${escaped}',event)" onmouseleave="onVerseLeave()">${v}</span>`;
      }).join(', ');
    }

    function findVerseKeyByLabel(label) {
      // label is like "Genesis 1:1" — reverse lookup through BOOK_NAMES
      if (!charDatabase) return null;
      for (const [num, name] of Object.entries(BOOK_NAMES)) {
        if (label.startsWith(name + ' ')) {
          const ref = label.substring(name.length + 1);
          const [chap, verse] = ref.split(':').map(Number);
          if (chap && verse) return `${num}:${chap}:${verse}`;
        }
      }
      return null;
    }

    // --- ELS search ---
    // Uses normalized text (sofiot → regular) for matching, original text for display
    let torahTextNorm = null; // normalized version (sofiot replaced)

    function findELS(normText, term, skip) {
      const results = [];
      const len = normText.length;
      const termLen = term.length;

      if (skip === 1) {
        // Optimized forward open-text search using indexOf
        let idx = 0;
        while ((idx = normText.indexOf(term, idx)) !== -1) {
          results.push(idx);
          idx++;
        }
      } else {
        // General ELS search for all other skip values (including negative)
        for (let start = 0; start < len; start++) {
          let match = true;
          for (let i = 0; i < termLen; i++) {
            const pos = start + i * skip;
            if (pos < 0 || pos >= len || normText[pos] !== term[i]) { match = false; break; }
          }
          if (match) results.push(start);
        }
      }
      return results;
    }

    // --- N-term scan ---
    let scanAbort = false;
    let scanAllResults = {};  // { term: [{pos, skip}, ...] }
    let scanTerms = [];
    let scanClusters = [];
    let clusterPermRunning = false;
    let discoveredResults = []; // stored for filter toggling

    window.cancelScan = function() { scanAbort = true; batchAbort = true; };

    window.startScan = async function() {
      if (!torahText) {
        const resp = await fetch('data/torahNoSpaces.txt');
        torahText = await resp.text();
      }
      // Build normalized Torah text (sofiot → regular) once
      if (!torahTextNorm) {
        torahTextNorm = normalizeSofiot(torahText);
      }

      // Always parse from textarea (auto-parse on search)
      parseBatchInput();

      // Build term list: one entry per line (primary form), with alternates
      const seen = new Set();
      const terms = [];       // primary cleaned forms (for clustering)
      const termAlts = {};    // primary -> [all alternate forms]
      for (const bt of batchTerms) {
        if (bt.alternates.length === 0) continue;
        const primary = bt.cleaned;
        if (seen.has(primary)) continue;
        seen.add(primary);
        terms.push(primary);
        termAlts[primary] = bt.alternates;
      }
      if (terms.length < 1) { alert('Enter at least one Hebrew search term (one per line)'); return; }

      const minSkip = parseInt(document.getElementById('minSkip').value) || -500;
      const maxSkip = parseInt(document.getElementById('maxSkip').value) || 500;

      const btn = document.getElementById('scanBtn');
      const cancelBtn = document.getElementById('scanCancelBtn');
      const status = document.getElementById('scanStatus');
      const progressDiv = document.getElementById('scanProgress');
      const progressBar = document.getElementById('scanProgressBar');
      btn.disabled = true;
      btn.textContent = 'Scanning...';
      cancelBtn.style.display = '';
      progressDiv.style.display = '';
      progressBar.style.width = '0%';
      progressBar.textContent = '0%';
      scanAbort = false;

      // Load character database for verse attribution
      status.textContent = 'Loading verse database...';
      await loadCharDB();

      scanAllResults = {};
      scanTerms = terms;
      for (const term of terms) scanAllResults[term] = [];

      // Reset batch term statuses if batch is active
      const hasBatch = batchTerms.length > 0;
      if (hasBatch) {
        for (const t of batchTerms) { t.hits = 0; t.bestSkip = null; t.bestPos = null; t.status = 'pending'; }
        batchAllResults = {};
        document.getElementById('batchResults').style.display = '';
        renderBatchTable();
      }

      // Count total search forms (including alternates) for progress
      const totalForms = terms.reduce((s, t) => s + (termAlts[t] || [t]).length, 0);
      let formsSearched = 0;
      const startTime = performance.now();

      // Scan per-term: search all alternates, merge results under primary key
      for (let ti = 0; ti < terms.length; ti++) {
        if (scanAbort) break;

        const primary = terms[ti];
        const alts = termAlts[primary] || [primary];
        const mergedResults = [];

        for (const form of alts) {
          if (scanAbort) break;
          for (let skip = minSkip; skip <= maxSkip; skip++) {
            if (scanAbort) break;
            if (skip === 0) continue;
            const found = findELS(torahTextNorm, form, skip);
            for (const pos of found) mergedResults.push({ pos, skip, form });
          }
          formsSearched++;
          // Progress based on total forms searched
          const pct = Math.round((formsSearched / totalForms) * 100);
          progressBar.style.width = pct + '%';
          progressBar.textContent = pct + '%';
          await new Promise(r => setTimeout(r, 0));
        }

        // Store merged results under primary key
        scanAllResults[primary] = mergedResults;

        // Update batch table row
        if (hasBatch) {
          const bt = batchTerms.find(b => b.cleaned === primary);
          if (bt) {
            batchAllResults[primary] = mergedResults;
            bt.hits = mergedResults.length;
            if (mergedResults.length > 0) {
              const sorted = [...mergedResults].sort((a, b) => Math.abs(a.skip) - Math.abs(b.skip));
              bt.bestSkip = sorted[0].skip;
              bt.bestPos = sorted[0].pos;
            }
            bt.status = 'done';
            const btIdx = batchTerms.indexOf(bt);
            updateBatchRow(btIdx);
          }
        }

        // Progress (keep pct updated even if no alternates)
        const pct = Math.round((formsSearched / totalForms) * 100);
        progressBar.style.width = pct + '%';
        progressBar.textContent = pct + '%';

        const elapsed = (performance.now() - startTime) / 1000;
        const perForm = elapsed / formsSearched;
        const remaining = Math.round(perForm * (totalForms - formsSearched));
        const remMin = Math.floor(remaining / 60);
        const remSec = remaining % 60;
        const altInfo = alts.length > 1 ? ` (${alts.length} forms)` : '';
        status.textContent = `Term ${ti + 1}/${terms.length}: "${primary}"${altInfo} — ${mergedResults.length} hits` +
          (remaining > 0 ? ` | ~${remMin}m ${remSec}s remaining` : '');

        await new Promise(r => setTimeout(r, 0));
      }

      btn.disabled = false;
      btn.textContent = 'Search';
      cancelBtn.style.display = 'none';
      progressDiv.style.display = 'none';

      const totalTime = Math.round((performance.now() - startTime) / 1000);
      const totalHits = Object.values(scanAllResults).reduce((s, r) => s + r.length, 0);
      status.textContent = scanAbort
        ? 'Cancelled.'
        : `Done! ${terms.length} terms (${totalForms} forms), ${totalHits.toLocaleString()} hits in ${Math.floor(totalTime/60)}m ${totalTime%60}s`;

      // Auto-cluster all terms with hits (if 2+)
      scanClusters = [];
      const termsWithHits = terms.filter(t => scanAllResults[t].length > 0);
      if (termsWithHits.length >= 2) {
        status.textContent += ' — Finding clusters...';
        await new Promise(r => setTimeout(r, 0));
        scanClusters = findClusters(termsWithHits, scanAllResults, 10000);
        // Update scanTerms to only include terms with hits for display
        scanTerms = termsWithHits;
      }

      displayScanResults(scanTerms, scanAllResults, scanClusters);

      if (hasBatch) {
        renderBatchTable();
        document.getElementById('batchExportBtn').style.display = '';
      }
    };

    // --- Sliding window cluster finder ---
    function findClusters(terms, allResults, maxSpan) {
      // Merge all hits tagged by term index
      const merged = [];
      terms.forEach((term, idx) => {
        for (const hit of allResults[term]) {
          // Use actual matched form if available (alternate spellings), else primary
          merged.push({ pos: hit.pos, skip: hit.skip, termIdx: idx, term: hit.form || term });
        }
      });
      if (merged.length === 0) return [];

      merged.sort((a, b) => a.pos - b.pos);

      const clusters = [];
      const termCount = terms.length;
      // Count of each term in current window
      const counts = new Array(termCount).fill(0);
      let presentTerms = 0;
      let left = 0;

      for (let right = 0; right < merged.length; right++) {
        const rHit = merged[right];
        if (counts[rHit.termIdx] === 0) presentTerms++;
        counts[rHit.termIdx]++;

        // Shrink window from left while all terms still present
        while (presentTerms === termCount) {
          const span = merged[right].pos - merged[left].pos;
          if (span <= maxSpan) {
            // Record cluster: pick one hit per term (closest to center)
            const centerPos = (merged[left].pos + merged[right].pos) / 2;
            const hits = [];
            for (let t = 0; t < termCount; t++) {
              // Find best hit for this term in window
              let best = null, bestDist = Infinity;
              for (let k = left; k <= right; k++) {
                if (merged[k].termIdx === t) {
                  const d = Math.abs(merged[k].pos - centerPos);
                  if (d < bestDist) { bestDist = d; best = merged[k]; }
                }
              }
              if (best) hits.push({ ...best });
            }
            clusters.push({ span, hits, minPos: merged[left].pos, maxPos: merged[right].pos });
          }

          const lHit = merged[left];
          counts[lHit.termIdx]--;
          if (counts[lHit.termIdx] === 0) presentTerms--;
          left++;
        }
      }

      // Sort by span ascending
      clusters.sort((a, b) => a.span - b.span);

      // Deduplicate overlapping clusters (keep smallest span variant)
      const deduped = [];
      const usedKeys = new Set();
      for (const c of clusters) {
        // Key = sorted positions of chosen hits
        const key = c.hits.map(h => `${h.termIdx}:${h.pos}:${h.skip}`).sort().join('|');
        if (!usedKeys.has(key)) {
          usedKeys.add(key);
          deduped.push(c);
          if (deduped.length >= 200) break;
        }
      }

      return deduped;
    }

    // --- Display scan results ---
    function displayScanResults(terms, allResults, clusters) {
      let html = '<div class="results">';

      // Clusters section (2+ terms)
      if (terms.length >= 2 && clusters.length > 0) {
        html += `<div style="background:#fff3e0;padding:16px;border-radius:8px;border-right:4px solid #ff9800;margin-bottom:20px;">`;
        html += `<div style="display:flex;align-items:center;flex-wrap:wrap;gap:10px;margin-bottom:12px;">`;
        html += `<h3 style="color:#e65100;margin:0;">Clusters (${clusters.length}) — sorted by smallest region</h3>`;
        html += `<button onclick="runClusterPermTest()" id="clusterPermBtn" style="background:linear-gradient(135deg,#7b1fa2,#9c27b0);color:#fff;border:none;padding:6px 14px;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;">Significance Test</button>`;
        html += `<label style="font-size:12px;color:#666;">N=<input id="clusterPermN" type="number" value="1000" min="100" max="100000" step="100" style="width:70px;margin-left:4px;padding:2px 4px;border:1px solid #ccc;border-radius:4px;font-size:12px;"></label>`;
        html += `</div>`;
        html += `<div id="clusterPermResults" style="display:none;margin-bottom:12px;"></div>`;
        html += `<p style="font-size:13px;color:#666;margin-bottom:12px;">Click to view matrix with all terms</p>`;
        html += '<div class="results-scrollable" style="max-height:500px;">';
        clusters.forEach((c, idx) => {
          html += `<div class="cluster-row" onclick="showClusterMatrix(${idx})">`;
          html += `<div><span class="cluster-span">${c.span.toLocaleString()} chars</span></div>`;
          html += `<div class="cluster-terms">`;
          c.hits.forEach(h => {
            const color = TERM_COLORS[h.termIdx % 8];
            const verses = getVersesForHit(h.pos, h.skip, h.term.length);
            const verseStr = verses.length > 0 ? ` [${verses.join(', ')}]` : '';
            html += `<span class="cluster-term-tag" style="background:${color}20;border-color:${color};color:#333;">
              "${h.term}" pos:${h.pos.toLocaleString()} skip:${h.skip}${verseStr}
            </span>`;
          });
          html += `</div></div>`;
        });
        html += '</div></div>';
      } else if (terms.length >= 2) {
        html += `<div style="background:#fff3e0;padding:16px;border-radius:8px;border-right:4px solid #ff9800;margin-bottom:20px;">`;
        html += `<h3 style="color:#e65100;margin-bottom:12px;">Clusters</h3>`;
        html += `<p>No clusters found — some terms may have no results.</p></div>`;
      }

      // Individual term results
      terms.forEach((term, tIdx) => {
        const results = allResults[term];
        const color = TERM_COLORS[tIdx % 8];
        // Count unique forms
        const forms = new Set(results.map(r => r.form || term));
        const formLabel = forms.size > 1 ? ` (${[...forms].join(' / ')})` : '';
        html += `<h3 style="margin-top:20px;border-right:4px solid ${color};padding-right:10px;">${term}${formLabel}: ${results.length.toLocaleString()} occurrences</h3>`;
        if (results.length > 0) {
          html += '<div class="results-scrollable" style="max-height:300px;">';
          results.forEach((r, i) => {
            const actualForm = r.form || term;
            const verses = getVersesForHit(r.pos, r.skip, actualForm.length);
            const verseStr = verses.length > 0 ? `<span style="color:#888;font-size:12px;"> — ${verses.join(', ')}</span>` : '';
            const formNote = actualForm !== term ? `<span style="color:#999;font-size:11px;">[${actualForm}]</span> ` : '';
            html += `<div class="result-item" onclick="showSingleTermMatrix(${tIdx}, ${i})">
              <span class="term" style="color:${color};">${formNote}${actualForm}</span>
              <span class="info">Position: ${r.pos.toLocaleString()} | Skip: ${r.skip}${verseStr}</span>
            </div>`;
          });
          html += '</div>';
        }
      });

      html += '</div>';
      document.getElementById('scanResults').innerHTML = html;
    }

    // --- Cluster significance permutation test ---
    window.runClusterPermTest = async function() {
      if (clusterPermRunning) { clusterPermRunning = false; return; }
      if (scanTerms.length < 2 || scanClusters.length === 0) return;

      const numTrials = parseInt(document.getElementById('clusterPermN')?.value) || 1000;
      const btn = document.getElementById('clusterPermBtn');
      const resDiv = document.getElementById('clusterPermResults');
      clusterPermRunning = true;
      btn.textContent = 'Cancel';
      btn.style.background = 'linear-gradient(135deg,#c62828,#e53935)';
      resDiv.style.display = 'block';
      resDiv.innerHTML = `<div style="background:#f3e5f5;padding:10px;border-radius:6px;">
        <div style="font-size:13px;color:#6a1b9a;margin-bottom:6px;">Running permutation test...</div>
        <div style="background:#e1bee7;border-radius:4px;height:8px;overflow:hidden;">
          <div id="clusterPermBar" style="height:100%;width:0%;background:linear-gradient(90deg,#7b1fa2,#ab47bc);transition:width 0.2s;"></div>
        </div>
        <div id="clusterPermProgress" style="font-size:11px;color:#888;margin-top:4px;"></div>
      </div>`;

      // Pool all hits from all terms
      const termCount = scanTerms.length;
      const pooled = [];
      for (const term of scanTerms) {
        const results = scanAllResults[term];
        if (!results) continue;
        const tIdx = scanTerms.indexOf(term);
        for (const hit of results) {
          pooled.push({ pos: hit.pos, termIdx: tIdx });
        }
      }
      pooled.sort((a, b) => a.pos - b.pos);
      const M = pooled.length;
      if (M < termCount) {
        resDiv.innerHTML = '<div style="color:#c62828;padding:8px;">Not enough hits for permutation test.</div>';
        btn.textContent = 'Significance Test';
        btn.style.background = 'linear-gradient(135deg,#7b1fa2,#9c27b0)';
        clusterPermRunning = false;
        return;
      }

      // Actual best (smallest) cluster span
      const actualBestSpan = scanClusters[0].span;

      // Sliding-window minimum-span finder for given labels
      function findMinSpan(labels) {
        const counts = new Array(termCount).fill(0);
        let present = 0, left = 0, minSpan = Infinity;
        for (let right = 0; right < M; right++) {
          const rLabel = labels[right];
          if (counts[rLabel] === 0) present++;
          counts[rLabel]++;
          while (present === termCount) {
            const span = pooled[right].pos - pooled[left].pos;
            if (span < minSpan) minSpan = span;
            const lLabel = labels[left];
            counts[lLabel]--;
            if (counts[lLabel] === 0) present--;
            left++;
          }
        }
        return minSpan;
      }

      // Build label array preserving count-per-term
      const labels = pooled.map(h => h.termIdx);

      // Fisher-Yates shuffle (in-place)
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
        }
      }

      const permSpans = [];
      let betterCount = 0;
      const bar = document.getElementById('clusterPermBar');
      const progText = document.getElementById('clusterPermProgress');

      for (let t = 0; t < numTrials; t++) {
        if (!clusterPermRunning) break;

        shuffle(labels);
        const span = findMinSpan(labels);
        permSpans.push(span);
        if (span <= actualBestSpan) betterCount++;

        if (t % 50 === 0) {
          const pct = ((t + 1) / numTrials * 100).toFixed(1);
          bar.style.width = pct + '%';
          const runningP = (betterCount / (t + 1)).toFixed(4);
          progText.textContent = `Trial ${t + 1}/${numTrials} — running P ≈ ${runningP}`;
          await new Promise(r => setTimeout(r, 0));
        }
      }

      btn.textContent = 'Significance Test';
      btn.style.background = 'linear-gradient(135deg,#7b1fa2,#9c27b0)';
      const wasAborted = !clusterPermRunning;
      clusterPermRunning = false;

      if (wasAborted) {
        progText.textContent = 'Cancelled.';
        return;
      }

      const completed = permSpans.length;
      const pValue = betterCount / completed;
      permSpans.sort((a, b) => a - b);
      const median = permSpans[Math.floor(completed / 2)];
      const mean = permSpans.reduce((s, v) => s + v, 0) / completed;
      showClusterPermResults({
        pValue, betterCount, numTrials: completed,
        actualSpan: actualBestSpan, median, mean,
        distribution: permSpans
      });
    };

    function showClusterPermResults(msg) {
      const resDiv = document.getElementById('clusterPermResults');
      const pVal = msg.pValue;
      const pColor = pVal < 0.01 ? '#1b5e20' : pVal < 0.05 ? '#2e7d32' : pVal < 0.1 ? '#f57f17' : '#c62828';
      const sigLabel = pVal < 0.001 ? 'Highly significant' :
                       pVal < 0.01  ? 'Very significant' :
                       pVal < 0.05  ? 'Significant' :
                       pVal < 0.1   ? 'Marginally significant' : 'Not significant';
      const ratio = pVal > 0 ? Math.round(1 / pVal) : msg.numTrials;

      // Mini histogram
      let histHTML = '';
      if (msg.distribution && msg.distribution.length > 10) {
        const dist = msg.distribution;
        const minV = dist[0], maxV = dist[dist.length - 1];
        const bins = 30;
        const binW = (maxV - minV) / bins || 1;
        const counts = new Array(bins).fill(0);
        for (const v of dist) {
          const bi = Math.min(bins - 1, Math.floor((v - minV) / binW));
          counts[bi]++;
        }
        const maxCount = Math.max(...counts);
        const actualBin = Math.min(bins - 1, Math.floor((msg.actualSpan - minV) / binW));

        histHTML = '<div style="margin-top:8px;"><div style="font-size:11px;color:#555;margin-bottom:4px;">Distribution of permuted minimum spans:</div>';
        histHTML += '<div style="display:flex;align-items:flex-end;height:60px;gap:1px;">';
        for (let b = 0; b < bins; b++) {
          const h = maxCount > 0 ? Math.round((counts[b] / maxCount) * 56) : 0;
          const isActual = b === actualBin;
          const bg = isActual ? '#c62828' : '#ce93d8';
          const title = `${(minV + b * binW).toLocaleString()}\u2013${(minV + (b + 1) * binW).toLocaleString()}: ${counts[b]}`;
          histHTML += `<div style="width:${Math.max(4, Math.floor(200 / bins))}px;height:${Math.max(1, h)}px;background:${bg};border-radius:1px 1px 0 0;" title="${title}"></div>`;
        }
        histHTML += '</div>';
        histHTML += `<div style="font-size:10px;color:#999;display:flex;justify-content:space-between;"><span>${minV.toLocaleString()}</span><span>Red = actual (${msg.actualSpan.toLocaleString()})</span><span>${maxV.toLocaleString()}</span></div>`;
        histHTML += '</div>';
      }

      resDiv.innerHTML = `
        <div style="background:#f3e5f5;padding:12px;border-radius:6px;border:1px solid #ce93d8;">
          <div style="font-weight:bold;color:#6a1b9a;font-size:14px;margin-bottom:8px;">Cluster Significance Test Results</div>
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:6px;font-size:13px;">
            <div>P-value: <strong style="color:${pColor};font-size:15px;">${pVal === 0 ? '< ' + (1/msg.numTrials).toFixed(6) : pVal.toFixed(6)}</strong></div>
            <div>Significance: <strong style="color:${pColor};">${sigLabel}</strong></div>
            <div>Rank: <strong>${msg.betterCount}</strong> / ${msg.numTrials.toLocaleString()} (1/${ratio.toLocaleString()})</div>
            <div>Actual best span: <strong>${msg.actualSpan.toLocaleString()} chars</strong></div>
            <div>Permuted median: <strong>${msg.median.toLocaleString()} chars</strong></div>
            <div>Permuted mean: <strong>${Math.round(msg.mean).toLocaleString()} chars</strong></div>
          </div>
          ${histHTML}
          <div style="margin-top:6px;font-size:11px;color:#777;">
            ${msg.numTrials.toLocaleString()} random shuffles of term labels across ${scanTerms.length} terms.
            P = fraction of shuffled arrangements producing a minimum span \u2264 actual best span (${msg.actualSpan.toLocaleString()}).
          </div>
        </div>`;
    }

    // --- Show cluster matrix ---
    window.showClusterMatrix = function(idx) {
      const cluster = scanClusters[idx];
      if (!cluster || !torahText) return;

      const view = document.getElementById('scanMatrixView');
      view.style.display = 'block';
      document.getElementById('scanMatrixTitle').textContent =
        `Cluster — ${cluster.hits.map(h => `"${h.term}"`).join(' + ')}`;

      // Stats
      let statsHtml = `<div class="matrix-stat"><div class="value">${cluster.span.toLocaleString()}</div><div class="label">Span</div></div>`;
      cluster.hits.forEach(h => {
        const color = TERM_COLORS[h.termIdx % 8];
        statsHtml += `<div class="matrix-stat">
          <div class="value" style="color:${color};">${h.term}</div>
          <div class="label">pos ${h.pos.toLocaleString()} skip ${h.skip}</div>
        </div>`;
      });
      document.getElementById('scanMatrixStats').innerHTML = statsHtml;

      // Legend with hoverable verse references
      buildHitVerseMap(cluster.hits);
      let legendHtml = '';
      cluster.hits.forEach(h => {
        const color = TERM_COLORS[h.termIdx % 8];
        const verses = getVersesForHit(h.pos, h.skip, h.term.length);
        const verseSpans = makeVerseSpans(verses);
        const verseStr = verseSpans ? ` (${verseSpans})` : '';
        legendHtml += `<div class="legend-item"><div class="legend-color" style="background:${color};"></div><span>${h.term}${verseStr}</span></div>`;
      });
      if (cluster.hits.length > 1) {
        legendHtml += `<div class="legend-item"><div class="legend-color" style="background:#9c27b0;"></div><span>Overlap</span></div>`;
      }
      document.getElementById('scanMatrixLegend').innerHTML = legendHtml;

      current3DHits = cluster.hits;
      renderScanMatrix(cluster.hits);

      if (is3DActive && THREE) {
        const { W, H } = findOptimalDimensions(current3DHits);
        render3DMatrix(current3DHits, W, H);
      }

      view.scrollIntoView({ behavior: 'smooth' });
    };

    // --- Show single term matrix ---
    window.showSingleTermMatrix = function(termIdx, resultIdx) {
      const primaryTerm = scanTerms[termIdx];
      const results = scanAllResults[primaryTerm];
      if (!results || !results[resultIdx] || !torahText) return;

      const r = results[resultIdx];
      const actualForm = r.form || primaryTerm;
      const hit = { pos: r.pos, skip: r.skip, term: actualForm, termIdx };

      const view = document.getElementById('scanMatrixView');
      view.style.display = 'block';
      const titleSuffix = actualForm !== primaryTerm ? ` [alt: ${primaryTerm}]` : '';
      document.getElementById('scanMatrixTitle').textContent = `"${actualForm}"${titleSuffix}`;

      const color = TERM_COLORS[termIdx % 8];
      const verses = getVersesForHit(r.pos, r.skip, actualForm.length);

      document.getElementById('scanMatrixStats').innerHTML = `
        <div class="matrix-stat"><div class="value" style="color:${color};">${actualForm}</div><div class="label">Term</div></div>
        <div class="matrix-stat"><div class="value">${r.pos.toLocaleString()}</div><div class="label">Position</div></div>
        <div class="matrix-stat"><div class="value">${r.skip}</div><div class="label">Skip</div></div>
      `;

      // Legend with hoverable verse references
      buildHitVerseMap([hit]);
      const verseSpans = makeVerseSpans(verses);
      const verseStr = verseSpans ? ` — ${verseSpans}` : '';
      document.getElementById('scanMatrixLegend').innerHTML = `
        <div class="legend-item"><div class="legend-color" style="background:${color};"></div><span>${actualForm}${verseStr}</span></div>
      `;

      current3DHits = [hit];
      renderScanMatrix([hit]);

      if (is3DActive && THREE) {
        const { W, H } = findOptimalDimensions(current3DHits);
        render3DMatrix(current3DHits, W, H);
      }

      view.scrollIntoView({ behavior: 'smooth' });
    };

    // --- Discover dictionary-validated ELS terms within current matrix region ---
    window.discoverMatrixTerms = async function() {
      if (!current3DHits || current3DHits.length === 0) {
        alert('No matrix displayed. Click a cluster first.');
        return;
      }
      if (!elsService) {
        alert('ELS index not loaded yet.');
        return;
      }

      const panel = document.getElementById('discoverTermsPanel');
      const resultsDiv = document.getElementById('discoverTermsResults');
      const statusSpan = document.getElementById('discoverTermsStatus');
      panel.style.display = 'block';
      resultsDiv.innerHTML = '<div style="text-align:center;padding:20px;color:#333;font-weight:600;">Searching...</div>';
      statusSpan.textContent = '';

      // Compute the bounding region of the current matrix hits
      const allPositions = [];
      const searchTermSet = new Set();
      for (const h of current3DHits) {
        searchTermSet.add(h.term);
        for (let i = 0; i < h.term.length; i++) {
          allPositions.push(h.pos + i * h.skip);
        }
      }
      const minPos = Math.min(...allPositions);
      const maxPos = Math.max(...allPositions);
      const center = Math.round((minPos + maxPos) / 2);
      const radius = Math.max(Math.round((maxPos - minPos) / 2) + 100, 500);

      // Load dictionary if not yet loaded
      if (!dictService) {
        statusSpan.textContent = 'Loading dictionaries...';
        try {
          await initDictionaries(['unified', 'bdb', 'strongs', 'wiktionary', 'names', 'wikipedia-fulltext']);
          dictService = getDictionaryService();
        } catch (e) {
          // Try minimal fallback
          try {
            await initDictionaries(['unified']);
            dictService = getDictionaryService();
          } catch (e2) {
            dictService = null;
          }
        }
      }

      statusSpan.textContent = `Searching ±${radius} around position ${center}...`;

      // Use setTimeout to allow UI to update before heavy computation
      await new Promise(r => setTimeout(r, 50));

      // Find all ELS-indexed words near the cluster
      const nearby = elsService.findNearby(center, radius, {
        minWordLength: 2,
        maxResults: 500
      });

      // Filter: exclude the search terms themselves, validate against dictionary
      const discovered = [];
      for (const item of nearby) {
        // Skip the original search terms
        if (searchTermSet.has(item.word)) continue;

        // Check dictionary
        let inDict = false;
        let definition = '';
        let root = '';
        let dictSource = '';
        if (dictService) {
          // Check if word exists in any dictionary
          const lookups = dictService.lookup(item.word);
          if (lookups && lookups.length > 0) {
            inDict = true;
            // Get source names (e.g. "BDB, Wiktionary")
            const srcNames = [...new Set(lookups.map(l => l.sourceName || l.source || ''))].filter(Boolean);
            dictSource = srcNames.join(', ');
            // Get best definition
            for (const l of lookups) {
              if (l.definitions && l.definitions.length > 0) {
                definition = l.definitions[0];
                break;
              }
            }
          }
          const rootInfo = dictService.getRoot(item.word);
          if (rootInfo) root = rootInfo.root;
        }

        // Get significance
        const sig = elsService.significanceScore(item.word);

        // Categorize: is it a name?
        const isName = dictSource.includes('Names') || dictSource.includes('names');

        // Categorize: is it a date-related term? (Hebrew months, days, years)
        const isDate = /^(ניסן|אייר|סיון|תמוז|אלול|תשרי|חשון|חשוון|כסלו|טבת|שבט|אדר|יום|חדש|שנה|שנת|נולד|נפטר)$/.test(item.word);

        discovered.push({
          word: item.word,
          minDistance: item.minDistance,
          occurrences: item.occurrences.length,
          totalOccurrences: item.totalOccurrences,
          zScore: sig.zScore,
          inDict,
          definition,
          root,
          dictSource,
          isName,
          isDate,
          bestOcc: item.occurrences[0] // closest occurrence
        });
      }

      // Sort: dictionary words first, then by z-score descending
      discovered.sort((a, b) => {
        if (a.inDict !== b.inDict) return a.inDict ? -1 : 1;
        return b.zScore - a.zScore;
      });

      // Store for filter toggling
      discoveredResults = discovered;

      // Render with current filter
      renderDiscoveredResults();
      panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    };

    // --- Render discovered results with active filter ---
    function renderDiscoveredResults() {
      const resultsDiv = document.getElementById('discoverTermsResults');
      const statusSpan = document.getElementById('discoverTermsStatus');
      if (!resultsDiv || discoveredResults.length === 0) {
        if (resultsDiv) resultsDiv.innerHTML = '<div style="text-align:center;padding:20px;color:#333;">No additional terms found in this region.</div>';
        return;
      }

      // Determine active filter
      const fAll = document.getElementById('discFilterAll');
      const fNames = document.getElementById('discFilterNames');
      const fDates = document.getElementById('discFilterDates');
      let filtered = discoveredResults;
      let filterLabel = '';
      if (fNames && fNames.checked) {
        filtered = discoveredResults.filter(d => d.isName);
        filterLabel = ' (Names only)';
      } else if (fDates && fDates.checked) {
        filtered = discoveredResults.filter(d => d.isDate);
        filterLabel = ' (Dates only)';
      }

      const dictCount = filtered.filter(d => d.inDict).length;
      const totalAll = discoveredResults.length;
      statusSpan.textContent = `${dictCount} dict / ${filtered.length} shown / ${totalAll} total${filterLabel}`;

      if (filtered.length === 0) {
        resultsDiv.innerHTML = `<div style="text-align:center;padding:20px;color:#333;">No ${fNames && fNames.checked ? 'names' : 'date terms'} found. Try "All" filter.</div>`;
        return;
      }

      let html = `<div style="display:flex;gap:6px;align-items:center;margin-bottom:6px;flex-wrap:wrap;">
        <button class="btn btn-small" style="padding:3px 10px;font-size:11px;background:#1565c0;" onclick="discSelectAll(true)">Check All</button>
        <button class="btn btn-small" style="padding:3px 10px;font-size:11px;background:#666;" onclick="discSelectAll(false)">Clear All</button>
        <button class="btn btn-small" style="padding:3px 10px;font-size:11px;background:#2e7d32;" onclick="addSelectedTerms()">Add Selected</button>
        <span id="discSelectedCount" style="font-size:11px;color:#555;">0 selected</span>
      </div>
      <table style="width:100%;border-collapse:collapse;font-size:13px;color:#000;">
        <thead><tr style="background:#d0d0d0;text-align:left;color:#000;font-weight:bold;">
          <th style="padding:5px 4px;width:28px;"><input type="checkbox" id="discCheckAllHeader" onchange="discSelectAll(this.checked)" title="Check/uncheck all"></th>
          <th style="padding:5px 6px;">#</th>
          <th style="padding:5px 6px;">Term</th>
          <th style="padding:5px 6px;">Root</th>
          <th style="padding:5px 6px;">Distance</th>
          <th style="padding:5px 6px;">Skip</th>
          <th style="padding:5px 6px;">z-Score</th>
          <th style="padding:5px 6px;">Source</th>
          <th style="padding:5px 6px;">Definition</th>
        </tr></thead><tbody>`;

      for (let i = 0; i < filtered.length; i++) {
        const d = filtered[i];
        const bgColor = d.isName ? '#e3f2fd' : d.isDate ? '#fff3e0' : d.inDict ? '#dcedc8' : '#fff';
        const zColor = d.zScore > 3 ? '#b71c1c' : d.zScore > 2 ? '#bf360c' : '#000';
        const defText = d.definition ? d.definition.substring(0, 60) : '';
        const catBadge = d.isName ? '<span style="font-size:9px;background:#1565c0;color:#fff;padding:1px 4px;border-radius:3px;margin-left:3px;">Name</span>' :
                         d.isDate ? '<span style="font-size:9px;background:#e65100;color:#fff;padding:1px 4px;border-radius:3px;margin-left:3px;">Date</span>' : '';
        const safeWord = d.word.replace(/'/g, "\\'");
        html += `<tr style="background:${bgColor};border-bottom:1px solid #ccc;color:#000;" title="Position: ${d.bestOcc.pos}, Total ELS occurrences: ${d.totalOccurrences}">
          <td style="padding:4px 4px;text-align:center;"><input type="checkbox" class="disc-term-cb" data-word="${safeWord}" data-pos="${d.bestOcc.pos}" data-skip="${d.bestOcc.skip}" onchange="updateDiscSelectedCount()"></td>
          <td style="padding:4px 6px;">${i + 1}</td>
          <td style="padding:4px 6px;font-weight:bold;font-size:15px;direction:rtl;color:#000;">${d.word}${catBadge}</td>
          <td style="padding:4px 6px;direction:rtl;color:#000;font-weight:600;">${d.root}</td>
          <td style="padding:4px 6px;color:#000;">${d.minDistance}</td>
          <td style="padding:4px 6px;color:#000;">${d.bestOcc.skip}</td>
          <td style="padding:4px 6px;color:${zColor};font-weight:bold;">${d.zScore.toFixed(1)}</td>
          <td style="padding:4px 6px;font-size:11px;color:#000;">${d.dictSource || (d.inDict ? '✓' : '')}</td>
          <td style="padding:4px 6px;font-size:12px;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:#000;">${defText}</td>
        </tr>`;
      }

      html += '</tbody></table>';
      resultsDiv.innerHTML = html;
    }

    // --- Filter checkbox handler (radio-style: only one active) ---
    window.applyDiscoverFilter = function() {
      const fAll = document.getElementById('discFilterAll');
      const fNames = document.getElementById('discFilterNames');
      const fDates = document.getElementById('discFilterDates');
      // Radio-style: uncheck others when one is checked
      const clicked = event && event.target;
      if (clicked === fAll && fAll.checked) { fNames.checked = false; fDates.checked = false; }
      else if (clicked === fNames && fNames.checked) { fAll.checked = false; fDates.checked = false; }
      else if (clicked === fDates && fDates.checked) { fAll.checked = false; fNames.checked = false; }
      // If nothing checked, default to All
      if (!fAll.checked && !fNames.checked && !fDates.checked) fAll.checked = true;
      if (discoveredResults.length > 0) renderDiscoveredResults();
    };

    // --- Check/uncheck all discovered term checkboxes ---
    window.discSelectAll = function(checked) {
      document.querySelectorAll('.disc-term-cb').forEach(cb => cb.checked = checked);
      const hdr = document.getElementById('discCheckAllHeader');
      if (hdr) hdr.checked = checked;
      updateDiscSelectedCount();
    };

    // --- Update selected count display ---
    window.updateDiscSelectedCount = function() {
      const all = document.querySelectorAll('.disc-term-cb');
      const checked = document.querySelectorAll('.disc-term-cb:checked');
      const span = document.getElementById('discSelectedCount');
      if (span) span.textContent = `${checked.length} selected`;
      const hdr = document.getElementById('discCheckAllHeader');
      if (hdr) hdr.checked = all.length > 0 && checked.length === all.length;
    };

    // --- Add all checked terms to textarea ---
    window.addSelectedTerms = function() {
      const checked = document.querySelectorAll('.disc-term-cb:checked');
      if (checked.length === 0) { alert('No terms selected. Check the boxes first.'); return; }
      const textarea = document.getElementById('batchTextarea');
      if (!textarea) return;
      const current = textarea.value.trim();
      const lines = current ? current.split('\n') : [];
      const existingWords = new Set();
      for (const line of lines) {
        for (const w of line.split(/\s+/)) existingWords.add(w);
      }
      let added = 0, skipped = 0;
      for (const cb of checked) {
        const word = cb.dataset.word;
        if (existingWords.has(word)) { skipped++; continue; }
        lines.push(word);
        existingWords.add(word);
        added++;
      }
      textarea.value = lines.join('\n');
      const msg = `Added ${added} term${added !== 1 ? 's' : ''}` + (skipped > 0 ? ` (${skipped} already present)` : '');
      const span = document.getElementById('discSelectedCount');
      if (span) { span.textContent = msg; span.style.color = '#2e7d32'; setTimeout(() => { span.style.color = '#555'; updateDiscSelectedCount(); }, 2000); }
    };

    // Add a discovered term to the search textarea and re-scan
    window.addDiscoveredTerm = function(word, pos, skip) {
      const textarea = document.getElementById('batchTextarea');
      if (!textarea) return;
      // Add term on new line if not already present
      const current = textarea.value.trim();
      const lines = current ? current.split('\n') : [];
      // Check if already present (as primary or alternate)
      const alreadyPresent = lines.some(line => line.split(/\s+/).some(w => w === word));
      if (alreadyPresent) {
        alert(`"${word}" is already in the search terms.`);
        return;
      }
      textarea.value = current + (current ? '\n' : '') + word;
      // Flash feedback
      const btn = event.target;
      btn.textContent = '✓';
      btn.style.background = '#2e7d32';
      setTimeout(() => { btn.textContent = '+'; btn.style.background = ''; }, 1000);
    };

    // --- Render N-term matrix ---
    function renderScanMatrix(hits) {
      // Determine grid width from max |skip|
      const width = Math.max(...hits.map(h => Math.abs(h.skip)), 30);

      // Center on cluster midpoint
      const allPositions = [];
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) allPositions.push(h.pos + i * h.skip);
      }
      const minPos = Math.min(...allPositions);
      const maxPos = Math.max(...allPositions);

      // Compute row range from actual term positions (with context padding)
      const padding = 3;
      const startRow = Math.max(0, Math.floor(minPos / width) - padding);
      const endRow = Math.floor(maxPos / width) + padding;

      // Build posMap: position -> Set of termIdx
      const posMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          if (!posMap.has(p)) posMap.set(p, new Set());
          posMap.get(p).add(h.termIdx);
        }
      }

      let html = '';
      for (let row = startRow; row <= endRow; row++) {
        const rowStart = row * width;
        if (rowStart < 0) continue;
        for (let col = 0; col < width; col++) {
          const pos = rowStart + col;
          if (pos >= torahText.length) break;
          const ch = torahText[pos];
          const termSet = posMap.get(pos);
          let cls = 'matrix-cell';
          let tooltip = '';

          if (termSet) {
            if (termSet.size > 1) {
              cls += ' multi-term';
            } else {
              const idx = termSet.values().next().value;
              cls += ` term-color-${idx % 8}`;
            }
            // Tooltip with verse reference
            const verse = getVerseForPosition(pos);
            const termNames = [...termSet].map(t => scanTerms[t]).join(', ');
            tooltip = verse ? `${termNames} — ${verse}` : termNames;
          }

          html += `<div class="${cls}" data-pos="${pos}"${tooltip ? ` title="${tooltip}"` : ''}>${ch}</div>`;
        }
      }

      const grid = document.getElementById('scanMatrixGrid');
      grid.style.gridTemplateColumns = `repeat(${width}, 26px)`;
      grid.innerHTML = html;
    }

    // ============= BATCH TERM LOADER =============
    // batchTerms: each entry is one "term slot" (one line from textarea).
    // If a line has space-separated words, they're alternate spellings.
    // alternates: array of cleaned forms (all searched, best used in matrix).
    let batchTerms = [];       // [{original, cleaned, alternates, hits, bestSkip, bestPos, status}]
    let batchAllResults = {};  // cleaned term -> [{pos, skip}]
    let batchAbort = false;

    // toggleBatchPanel removed — terms panel is always visible

    window.loadBatchFile = function(input) {
      const file = input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        document.getElementById('batchTextarea').value = e.target.result;
        document.getElementById('batchParseStatus').textContent = `Loaded: ${file.name}`;
      };
      reader.readAsText(file);
    };

    window.clearBatchInput = function() {
      document.getElementById('batchTextarea').value = '';
      document.getElementById('batchParseStatus').textContent = '';
      document.getElementById('batchPreview').style.display = 'none';
      document.getElementById('batchResults').style.display = 'none';
      batchTerms = [];
      batchAllResults = {};
    };

    // Strip name to consonantal Hebrew only
    // Normalize sofit (final-form) letters to regular form for search matching
    const SOFIT_MAP = { 'ך':'כ', 'ם':'מ', 'ן':'נ', 'ף':'פ', 'ץ':'צ' };
    function normalizeSofiot(s) {
      return s.replace(/[ךםןףץ]/g, ch => SOFIT_MAP[ch]);
    }

    function cleanHebrewName(name) {
      // Remove parenthetical content: (אדריאן), (אלכסנדר), (ג'ימי), (נטלי)
      let s = name.replace(/\([^)]*\)/g, '');
      // Remove military ranks and honorifics
      s = s.replace(/\b(אל"ם|סמ"ר|סא"ל|רס"ן|סגן|סרן|רב"ט|טור'|רס"ר|רנ"ג|רב סמל|סמל|טוראי)\s*/g, '');
      // Remove הי"ד (memorial suffix)
      s = s.replace(/הי"ד/g, '');
      // Remove quotation marks and double-quotes within abbreviations
      s = s.replace(/["״׳']/g, '');
      // Keep only Hebrew letters (strip spaces, punctuation, Latin chars, digits)
      s = s.replace(/[^\u05D0-\u05EA]/g, '');
      // Normalize final-form letters to regular form for search
      s = normalizeSofiot(s);
      return s;
    }

    window.parseBatchInput = function() {
      const text = document.getElementById('batchTextarea').value.trim();
      if (!text) { batchTerms = []; return; }

      const lines = text.split('\n').map(l => l.trim()).filter(l => l);
      batchTerms = [];
      const seen = new Set();

      for (const line of lines) {
        // Space-separated words on same line = alternate spellings
        const parts = line.split(/\s+/);
        const alternates = [];
        for (const part of parts) {
          const c = cleanHebrewName(part);
          if (c.length >= 2 && !seen.has(c)) {
            alternates.push(c);
            seen.add(c);
          }
        }
        if (alternates.length === 0) continue;
        // Primary form = first alternate; others are alt spellings
        batchTerms.push({
          original: line,
          cleaned: alternates[0],
          alternates,    // all cleaned forms for this term slot
          hits: 0,
          bestSkip: null,
          bestPos: null,
          status: 'pending'
        });
      }

      if (batchTerms.length === 0) return;

      // Show preview
      const preview = document.getElementById('batchPreview');
      preview.style.display = '';
      const totalForms = batchTerms.reduce((s, t) => s + t.alternates.length, 0);
      document.getElementById('batchPreviewCount').textContent =
        `${batchTerms.length} terms parsed` + (totalForms > batchTerms.length ? ` (${totalForms} forms incl. alternates)` : '');

      // Time estimate (count all forms)
      const skipRange = (parseInt(document.getElementById('maxSkip').value) || 500) -
                         (parseInt(document.getElementById('minSkip').value) || -500) + 1;
      const estSec = Math.round(totalForms * (skipRange / 200) * 4);
      const estMin = Math.floor(estSec / 60);
      const estRemSec = estSec % 60;
      document.getElementById('batchTimeEstimate').textContent =
        `Est. ~${estMin}m ${estRemSec}s (${skipRange} skip values)`;

      // Preview list
      let previewHtml = batchTerms.map((t, i) => {
        if (t.alternates.length > 1) {
          const altStr = t.alternates.map((a, j) => j === 0 ? `<strong>${a}</strong>` : a).join(' / ');
          return `<div style="display:inline-block;padding:3px 8px;margin:2px;background:#e3ecf7;border-radius:3px;font-size:12px;">
            ${altStr} <span style="color:#999;font-size:10px;">(alt)</span>
          </div>`;
        }
        return `<div style="display:inline-block;padding:3px 8px;margin:2px;background:#e3ecf7;border-radius:3px;font-size:12px;">
          <strong>${t.cleaned}</strong> <span style="color:#999;">\u2190 ${t.original}</span>
        </div>`;
      }).join('');
      document.getElementById('batchPreviewList').innerHTML = previewHtml;
      document.getElementById('batchParseStatus').textContent = `${batchTerms.length} terms ready`;

      // Reset results
      document.getElementById('batchResults').style.display = 'none';
      document.getElementById('batchExportBtn').style.display = 'none';
      batchAllResults = {};
    };

    function renderBatchTable() {
      const tbody = document.getElementById('batchTableBody');
      let html = '';
      batchTerms.forEach((t, i) => {
        const statusCls = t.status === 'done' ? 'batch-status-done' :
                          t.status === 'scanning' ? 'batch-status-active' : 'batch-status-pending';
        const statusText = t.status === 'done' ? 'Done' :
                           t.status === 'scanning' ? 'Scanning...' : 'Pending';
        html += `<tr data-batch-idx="${i}">
          <td>${i + 1}</td>
          <td>${t.original}</td>
          <td style="direction:rtl;font-weight:bold;">${t.cleaned}</td>
          <td>${t.cleaned.length}</td>
          <td>${t.status === 'done' ? t.hits.toLocaleString() : '—'}</td>
          <td>${t.bestSkip !== null ? t.bestSkip : '—'}</td>
          <td class="batch-status-cell ${statusCls}">${statusText}</td>
        </tr>`;
      });
      tbody.innerHTML = html;
    }

    function updateBatchRow(idx) {
      const row = document.querySelector(`tr[data-batch-idx="${idx}"]`);
      if (!row) { renderBatchTable(); return; }
      const t = batchTerms[idx];
      const statusCls = t.status === 'done' ? 'batch-status-done' :
                        t.status === 'scanning' ? 'batch-status-active' : 'batch-status-pending';
      const statusText = t.status === 'done' ? 'Done' :
                         t.status === 'scanning' ? 'Scanning...' : 'Pending';
      row.cells[4].textContent = t.status === 'done' ? t.hits.toLocaleString() : '—';
      row.cells[5].textContent = t.bestSkip !== null ? t.bestSkip : '—';
      row.cells[6].className = 'batch-status-cell ' + statusCls;
      row.cells[6].textContent = statusText;
    }

    window.exportBatchResults = function() {
      if (batchTerms.length === 0) return;
      // CSV export
      let csv = 'Index,Original Name,Search Term,Letters,Hits,Best Skip,Best Position\n';
      batchTerms.forEach((t, i) => {
        csv += `${i+1},"${t.original}","${t.cleaned}",${t.cleaned.length},${t.hits},${t.bestSkip || ''},${t.bestPos || ''}\n`;
      });
      const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = `batch-els-results-${new Date().toISOString().slice(0,10)}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    };

    let batchSortCol = -1, batchSortAsc = true;
    window.sortBatchTable = function(col) {
      if (batchSortCol === col) { batchSortAsc = !batchSortAsc; }
      else { batchSortCol = col; batchSortAsc = true; }

      const getVal = (t, c) => {
        switch(c) {
          case 0: return batchTerms.indexOf(t);
          case 1: return t.original;
          case 2: return t.cleaned;
          case 3: return t.cleaned.length;
          case 4: return t.hits;
          case 5: return t.bestSkip || 0;
          case 6: return t.status === 'done' ? 2 : t.status === 'scanning' ? 1 : 0;
          default: return 0;
        }
      };

      batchTerms.sort((a, b) => {
        let va = getVal(a, col), vb = getVal(b, col);
        if (typeof va === 'string') return batchSortAsc ? va.localeCompare(vb) : vb.localeCompare(va);
        return batchSortAsc ? va - vb : vb - va;
      });
      renderBatchTable();
    };

    // ============= SCAN MODE: SAVE/LOAD SESSIONS =============
    window.saveScanSession = function() {
      if (scanTerms.length === 0) { alert('No scan results to save'); return; }
      const name = document.getElementById('scanSessionName').value.trim() || `Scan ${new Date().toLocaleTimeString()}`;
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      sessions.unshift({
        name,
        terms: scanTerms,
        allResults: scanAllResults,
        clusters: scanClusters,
        savedAt: new Date().toISOString()
      });
      if (sessions.length > 20) sessions.length = 20;
      try {
        localStorage.setItem('elsScanSessions', JSON.stringify(sessions));
      } catch (e) {
        alert('Session too large to save. Try reducing the skip range or number of terms.');
        return;
      }
      loadSavedScanSessions();
      document.getElementById('scanSessionName').value = '';
    };

    window.loadScanSession = function(idx) {
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      if (!sessions[idx]) return;
      const s = sessions[idx];
      scanTerms = s.terms;
      scanAllResults = s.allResults;
      scanClusters = s.clusters || [];

      // Restore terms into textarea
      document.getElementById('batchTextarea').value = s.terms.join('\n');
      // Auto-parse so batch state is consistent
      parseBatchInput();

      // Load char DB for verse attribution then display
      loadCharDB().then(() => {
        displayScanResults(scanTerms, scanAllResults, scanClusters);
      });
    };

    window.deleteScanSession = function(idx) {
      if (!confirm('Delete session?')) return;
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      sessions.splice(idx, 1);
      localStorage.setItem('elsScanSessions', JSON.stringify(sessions));
      loadSavedScanSessions();
    };

    function loadSavedScanSessions() {
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      const container = document.getElementById('savedScanSessions');
      if (!container) return;
      if (sessions.length === 0) {
        container.innerHTML = '<p style="font-size: 12px; color: #666; margin-top: 10px;">No saved scan sessions</p>';
        return;
      }
      let html = '';
      const esc = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
      sessions.forEach((s, i) => {
        html += `<div class="saved-item">
          <div><span class="name">${esc(s.name)}</span><br><span class="meta">${esc(s.terms.join(', '))}</span></div>
          <div><button class="btn btn-small btn-secondary" onclick="loadScanSession(${i})">Load</button>
          <button class="btn btn-small btn-danger" onclick="deleteScanSession(${i})">×</button></div>
        </div>`;
      });
      container.innerHTML = html;
    }

    window.exportScanResults = function() {
      if (scanTerms.length === 0) { alert('No results to export'); return; }
      const data = { terms: scanTerms, allResults: scanAllResults, clusters: scanClusters, timestamp: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = `els-scan-${scanTerms.join('-')}-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    };

    window.clearScanSession = function() {
      if (!confirm('Clear all terms and results?')) return;
      document.getElementById('batchTextarea').value = '';
      batchTerms = [];
      batchAllResults = {};
      document.getElementById('batchPreview').style.display = 'none';
      document.getElementById('batchResults').style.display = 'none';
      document.getElementById('batchParseStatus').textContent = '';
      document.getElementById('scanResults').innerHTML = '';
      document.getElementById('scanMatrixView').style.display = 'none';
      scanTerms = [];
      scanAllResults = {};
      scanClusters = [];
      current3DHits = null;
      is3DActive = false;
      destroy3DScene();
      // Reset 3D toggle button state
      const btn3d = document.getElementById('btn3DToggle');
      if (btn3d) { btn3d.textContent = '3D View'; btn3d.classList.remove('active'); }
      document.getElementById('scanMatrix2D').style.display = '';
      document.getElementById('scanMatrix3D').style.display = 'none';
      document.getElementById('btn3DPause').style.display = 'none';
      document.getElementById('btn3DReset').style.display = 'none';
    };

    // Load saved scan sessions on init
    loadSavedScanSessions();

    // ============= SCAN MODE: PDF EXPORT =============
    window.downloadMatrixPNG = function() {
      const matrixView = document.getElementById('scanMatrixView');
      if (!matrixView || matrixView.style.display === 'none') { alert('No matrix displayed'); return; }

      // Use canvas rendering approach
      const grid = document.getElementById('scanMatrixGrid');
      const cells = grid.querySelectorAll('.matrix-cell');
      if (cells.length === 0) return;

      const title = document.getElementById('scanMatrixTitle').textContent;
      const cols = parseInt(grid.style.gridTemplateColumns.match(/repeat\((\d+)/)?.[1] || '30');
      const rows = Math.ceil(cells.length / cols);
      const cellSize = 22;
      const padding = 40;
      const headerHeight = 80;

      const canvas = document.createElement('canvas');
      canvas.width = cols * cellSize + padding * 2;
      canvas.height = rows * cellSize + padding * 2 + headerHeight;
      const ctx = canvas.getContext('2d');

      // Background
      ctx.fillStyle = '#1a1a28';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Title
      ctx.fillStyle = '#8bb8e8';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(title, canvas.width / 2, 30);

      // Stats/legend text
      const legend = document.getElementById('scanMatrixLegend');
      ctx.font = '12px sans-serif';
      ctx.fillStyle = '#ccc';
      ctx.fillText(legend?.textContent?.trim() || '', canvas.width / 2, 55);

      // Color map
      const colorMap = {
        'term-color-0': '#ffc107', 'term-color-1': '#00bcd4', 'term-color-2': '#ff5722',
        'term-color-3': '#4caf50', 'term-color-4': '#e91e63', 'term-color-5': '#3f51b5',
        'term-color-6': '#795548', 'term-color-7': '#607d8b', 'multi-term': '#9c27b0'
      };

      // Draw cells
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      cells.forEach((cell, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = padding + col * cellSize;
        const y = headerHeight + padding + row * cellSize;

        // Determine cell color
        let bg = '#2d2d44';
        let fg = '#e0e0e0';
        for (const [cls, color] of Object.entries(colorMap)) {
          if (cell.classList.contains(cls)) {
            bg = color;
            fg = cls === 'term-color-0' || cls === 'term-color-1' ? '#000' : '#fff';
            break;
          }
        }

        ctx.fillStyle = bg;
        ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
        ctx.fillStyle = fg;
        ctx.fillText(cell.textContent, x + cellSize / 2, y + cellSize / 2);
      });

      // Download as PNG (simpler, universally supported, better quality than canvas-to-PDF)
      const link = document.createElement('a');
      link.download = `els-matrix-${title.replace(/[^a-zA-Z0-9א-ת]/g, '-')}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    };

    // ============= DICTIONARY MODE =============
    let dictData = null;
    let dictLoaded = false;

    async function loadDict() {
      if (dictLoaded) return;
      try {
        const resp = await fetch('data/dictionaries/unified/hebrew-unified.json.gz');
        const blob = await resp.blob();
        const ds = new DecompressionStream('gzip');
        const text = await new Response(blob.stream().pipeThrough(ds)).text();
        dictData = JSON.parse(text);
        dictLoaded = true;
        document.getElementById('dictLoading')?.remove();
        document.getElementById('dictContent')?.style && (document.getElementById('dictContent').style.display = 'block');
      } catch (err) {
        console.warn('Dictionary load deferred:', err.message);
      }
    }

    // Load dict when switching to dict tab
    document.querySelectorAll('.mode-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        if (tab.dataset.mode === 'dict' && !dictLoaded) {
          loadDict();
        }
      });
    });

    window.searchDict = function() {
      if (!dictData) return;
      const query = document.getElementById('dictSearch').value.trim();
      const source = document.getElementById('dictSource').value;
      if (!query) { browseDict('random'); return; }

      const results = [];
      for (const [word, entry] of Object.entries(dictData)) {
        if (source !== 'all' && entry.source !== source) continue;
        if (word.includes(query)) {
          results.push({ word, ...entry });
          if (results.length >= 100) break;
        }
      }

      displayDictResults(results, `Search: "${query}"`);
    };

    window.browseDict = function(mode) {
      if (!dictData) return;
      const source = document.getElementById('dictSource').value;
      const words = Object.entries(dictData)
        .filter(([w, e]) => source === 'all' || e.source === source);

      let results;
      if (mode === 'random') {
        const shuffled = words.sort(() => Math.random() - 0.5);
        results = shuffled.slice(0, 50).map(([word, entry]) => ({ word, ...entry }));
      } else {
        // Sort by some metric - for now just alphabetical
        results = words.slice(0, 50).map(([word, entry]) => ({ word, ...entry }));
      }

      displayDictResults(results, mode === 'random' ? 'Random Words' : 'Browse');
    };

    function displayDictResults(results, title) {
      if (results.length === 0) {
        document.getElementById('dictResults').innerHTML = '<div class="results"><p>No results found</p></div>';
        return;
      }

      let html = `<div class="results"><h3>${title} (${results.length})</h3>`;
      html += '<p style="font-size:12px;color:var(--gray);margin-bottom:10px;">Click word to search in ELS index, or + to add as search term</p>';
      html += '<div class="results-scrollable">';
      results.forEach(r => {
        const def = r.definition || r.gloss || r.meaning || '';
        const srcBadge = r.source ? `<span style="background:#ddd;padding:2px 6px;border-radius:3px;font-size:11px;">${r.source}</span>` : '';
        const inIndex = elsService?.hasWord(r.word);
        const indexBadge = inIndex ? '<span style="background:#d4edda;color:#2e7d32;padding:2px 6px;border-radius:3px;font-size:11px;">in index</span>' : '';
        html += `<div style="padding:12px;border-bottom:1px solid var(--border);cursor:pointer;transition:background 0.15s;"
                     onmouseover="this.style.background='var(--blue-light)'"
                     onmouseout="this.style.background='transparent'">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <span style="font-size:20px;font-weight:bold;color:var(--blue);" onclick="searchWordInELS('${r.word}')">${r.word}</span>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="btn btn-small" onclick="event.stopPropagation();addWordToSearch('${r.word}')" title="Add to search terms">+</button>
              ${indexBadge}
              ${srcBadge}
            </div>
          </div>
          ${def ? `<div style="color:var(--gray);margin-top:4px;">${def.substring(0, 200)}${def.length > 200 ? '...' : ''}</div>` : ''}
          ${r.root ? `<div style="font-size:12px;color:#888;margin-top:4px;">Root: ${r.root}</div>` : ''}
        </div>`;
      });
      html += '</div></div>';
      document.getElementById('dictResults').innerHTML = html;
    }

    window.searchWordInELS = function(word) {
      // Switch to index mode
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('.mode-tab[data-mode="index"]').classList.add('active');
      document.getElementById('index-mode').classList.add('active');

      // Set the word as first term and search
      const container = document.getElementById('termEntries');
      container.innerHTML = `<div class="term-entry">
        <input type="text" class="term-input" value="${word}" dir="rtl">
        <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
      </div>`;

      // Run search
      if (elsService) {
        const occs = elsService.findWord(word);
        currentResults = {
          terms: [word],
          termData: { [word]: { occurrences: occs, count: occs.length } },
          proximityPairs: [],
          timestamp: new Date().toISOString()
        };
        displayIndexResults(currentResults);
      }
    };

    window.addWordToSearch = function(word) {
      // Switch to index mode if not already
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('.mode-tab[data-mode="index"]').classList.add('active');
      document.getElementById('index-mode').classList.add('active');

      // Add word as new term
      const container = document.getElementById('termEntries');
      const n = container.querySelectorAll('.term-entry').length + 1;
      const div = document.createElement('div');
      div.className = 'term-entry';
      div.innerHTML = `<input type="text" class="term-input" value="${word}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
      container.appendChild(div);
    };

    // ============= WRR 1994 EXPERIMENT — ACADEMIC REPLICATION =============
    // Reference: Witztum, Rips & Rosenberg, "Equidistant Letter Sequences in
    // the Book of Genesis", Statistical Science, Vol. 9, No. 3, 1994, 429-438.
    //
    // Algorithm:
    // 1. Dynamic skip range D(w) per term based on expected ELS occurrence count
    // 2. Find ALL ELS occurrences of each name/date form with |skip| in [2, D(w)]
    // 3. 2D Euclidean distance on cylindrical array (width = |skip|)
    // 4. Both array orientations tested (width = |d_name| and |d_date|)
    // 5. Only |skip| >= 2 (open text excluded per WRR definition)
    // 6. Sofiot normalized to standard forms for matching

    const WRR_GENESIS_LEN = 78064;

    // WRR List 2: 32 rabbis from Encyclopedia of Great Men in Israel.
    // Appellations converted from WRR's original MC transliteration (WRR2.txt, McKay ANU archive).
    // Each appellation is a single consonantal Hebrew word (no spaces) — searched as ELS.
    // Rabbis 4 and 8 have no recorded death dates — excluded from analysis.
    const WRR_RABBIS = [
      { id:1, en:"Abraham ben David (RABaD)", names:["רביאברהמ","הראבי","הרבאבד","הראבד","האשכול","בעלהאשכול","ראבי","הרבאבביתדינ","ראבד"], dates:["כ חשונ","כ בחשונ","בכ חשונ"] },
      { id:2, en:"Abraham Yitzhaki", names:["רביאברהמ","יצחקי","זרעאברהמ","בעלזרעאברהמ","אברהמיצחקי"], dates:["יג סיונ","יג בסיונ","ביג סיונ"] },
      { id:3, en:"Abraham HaMalakh", names:["רביאברהמ","המלאכ","חסדלאברהמ","בעלחסדלאברהמ"], dates:["יב תשרי","יב בתשרי","ביב תשרי"] },
      { id:4, en:"Abraham Saba", names:["רביאברהמ","אברהמסבע","צרורהמר","בעלצרורהמר"], dates:[] },
      { id:5, en:"Aaron HaGadol of Karlin", names:["רביאהרנ","אהרנהגדולמקרלינ"], dates:["יט ניסנ","יט בניסנ","ביט ניסנ"] },
      { id:6, en:"Eliezer Ashkenazi", names:["מעשיהשמ","מעשייהוה","בעלמעשיהשמ","בעלמעשייהוה","אליעזראשכנזי","רביאליעזר"], dates:["כב כסלו","כב בכסלו","בכב כסלו"] },
      { id:7, en:"David Oppenheim", names:["רבידוד","אופנהימ","הרדא","מהרדאופנהימ","דודאופנהימ"], dates:["ז תשרי","ז בתשרי","בז תשרי"] },
      { id:8, en:"David HaNagid", names:["רבידוד","דודהנגיד"], dates:[] },
      { id:9, en:"David Nieto", names:["רבידוד","דודניטו","הכוזריהשני","בעלהכוזריהשני","ניטו"], dates:["כח טבת","כח בטבת","בכח טבת"] },
      { id:10, en:"Hayyim Abulafia", names:["רביחיימ","חיימאבואלעפיה","אבואלעפיה"], dates:["ו ניסנ","ו בניסנ","בו ניסנ"] },
      { id:11, en:"Hayyim Benveniste", names:["רביחיימ","בנבנשת","כנסתהגדולה","בעלכנסתהגדולה","חיימבנבנשת"], dates:["יט אלול","יט באלול","ביט אלול"] },
      { id:12, en:"Hayyim Capusi", names:["רביחיימ","כפוסי","בעלנס","בעלהנס","חיימכפוסי"], dates:["יב שבט","יב בשבט","ביב שבט"] },
      { id:13, en:"Hayyim Shabetai", names:["רביחיימ","חיימשבתי","מהרחש","המהרחש"], dates:["יג ניסנ","יג בניסנ","ביג ניסנ"] },
      { id:14, en:"Yair Hayyim Bacharach", names:["חותיאיר","בעלחותיאיר","יאירחיימבכרכ","בכרכ","רבייאירחיימ"], dates:["א טבת","א בטבת","בא טבת"] },
      { id:15, en:"Yehuda HeHasid", names:["רבייהודה","יהודהחסיד","יהודההחסיד"], dates:["ה חשונ","ה בחשונ","בה חשונ"] },
      { id:16, en:"Yehuda Ayash", names:["רבייהודה","מהריעיאש","יהודהעיאש","עיאש"], dates:["א תשרי","א בתשרי","בא תשרי"] },
      { id:17, en:"Yehosef HaNagid", names:["רבייהוספ"], dates:["ט טבת","ט בטבת","בט טבת"] },
      { id:18, en:"Yehoshua (Maginei Shlomo)", names:["רבייהושע","מגנישלמה"], dates:["כז אב","כז באב","בכז אב"] },
      { id:19, en:"Yosef di Trani (MaHaRiT)", names:["רבייוספ","מטרני","יוספטרני","טראני","מטראני","מהרימט","המהרימט","מהריט","המהריט","יוספמטרני","יוספטראני","יוספמטראני","טרני"], dates:["יד תמוז","יד בתמוז","ביד תמוז"] },
      { id:20, en:"Yosef Te'omim", names:["רבייוספ","תאומימ","פרימגדימ","בעלפרימגדימ","יוספתאומימ"], dates:["ד איר","ד באיר","בד איר"] },
      { id:21, en:"Ya'akov BeRav", names:["רבייעקב","יעקבבירב","מהריבירב","הריבר","בירב"], dates:["ל ניסנ","ל בניסנ","בל ניסנ"] },
      { id:22, en:"Yisrael Ya'akov Hagiz", names:["חאגיז","בעלהלקט","הלקט","ישראליעקב","רביישראליעקב"], dates:["כו שבט","כו בשבט","בכו שבט"] },
      { id:23, en:"Ya'akov Moelin (MaHaRIL)", names:["רבייעקב","מולינ","יעקבסגל","יעקבהלוי","מהריסגל","מהריהלוי","מהריל","המהריל","יעקבמולינ"], dates:["כב אלול","כב באלול","בכב אלול"] },
      { id:24, en:"Ya'akov Emden (Ya'avetz)", names:["היעבצ","הריעבצ","עמדינ","הריעמדנ","הריעמדינ","יעקבישראלעמדנ","יעקבישראלעמדינ","עמדנ","רבייעקבישראל"], dates:["ל ניסנ","ל בניסנ","בל ניסנ"] },
      { id:25, en:"Yitzhak HaLevi Horowitz", names:["רבייצחק","הורוויצ","יצחקהלוי","רביאיצקלהמבורגר","יצחקהלויאישהורוויצ"], dates:["ו איר","ו באיר","בו איר"] },
      { id:26, en:"Menachem Mendel Krochmal", names:["רבימנחמ","קרוכמל","רבימענדל","צמחצדק","בעלצמחצדק","מנחממענדל"], dates:["ב שבט","ב בשבט","בב שבט"] },
      { id:27, en:"Moshe Zacuto", names:["רבימשה","זכותא","זכותו","משהזכות","משהזכותא","משהזכותו","מהרמזכות","מהרמז","המהרמז","המזלנ","קולהרמז","מזלנ","בעלקולהרמז","זכות"], dates:["טז תשרי","טז בתשרי","בטז תשרי","יו תשרי","יו בתשרי","ביו תשרי"] },
      { id:28, en:"Moshe Margalit", names:["רבימשה","מרגלית","פנימשה","בעלפנימשה","משהמרגלית"], dates:["יב טבת","יב בטבת","ביב טבת"] },
      { id:29, en:"Azariah Figo", names:["רביעזריה","עזריהפיגו"], dates:["א אדרא","א באדרא","בא אדרא"] },
      { id:30, en:"Immanuel Hai Ricchi", names:["אחהער","ישרלבב","משנתחסידימ","בעלמשנתחסידימ","בעלישרלבב","עמנואלחירפאלריקי","ריקי","רביעמנואלחירפאל"], dates:["א אדר","א באדר","בא אדר"] },
      { id:31, en:"Shalom Sharabi (RaShaSh)", names:["רבישלומ","מזרחי","שרעבי","שרשלומ","מהרשש","המהרשש","שמש","השמש","שלוממזרחי"], dates:["י שבט","י בשבט","בי שבט"] },
      { id:32, en:"Shlomo HaMa'almi", names:["רבישלמה","מרכבתהמשנה","בעלמרכבתהמשנה","שלמהמחלמא","שלמהמחעלמא"], dates:["כא תמוז","כא בתמוז","בכא תמוז"] }
    ];

    // WRR List 1: 34 rabbis (major figures). Converted from WRR1.txt (McKay ANU archive).
    // Rabbi 23 (Rif) has no recorded death date — excluded from analysis.
    const WRR_RABBIS_LIST1 = [
      { id:1, en:"Abraham ben David (RABaD)", names:["רביאברהמ","הראבד","בעלההשגות","ראבד"], dates:["כו כסלו","כו בכסלו","בכו כסלו"] },
      { id:2, en:"Abraham the Pious (ben HaRambam)", names:["רביאברהמ","אברהמהחסיד","אברהמבנהרמבמ"], dates:["יח כסלו","יח בכסלו","ביח כסלו"] },
      { id:3, en:"Abraham ibn Ezra", names:["רביאברהמ","אבנעזרא","בנעזרא","הראבע","ראבע","אברהמבנעזרא","אברהמאבנעזרא"], dates:["א אדרא","א באדרא","בא אדרא"] },
      { id:4, en:"Eliyahu Bahur", names:["רביאליהו","הבחור","בעלהבחור","אליהוהלוי"], dates:["ו שבט","ו בשבט","בו שבט"] },
      { id:5, en:"Eliyahu (the GR\"A)", names:["רביאליהו","הגאונ","הגרא","הגאונמוילנא"], dates:["טו ניסנ","טו בניסנ","בטו ניסנ","יה ניסנ","יה בניסנ","ביה ניסנ","יט תשרי","יט בתשרי","ביט תשרי"] },
      { id:6, en:"Gershon Ashkenazi", names:["רביגרשונ","הגרשני","בעלעבודתהגרשני","גרשונאשכנזי"], dates:["י אדרב","י באדרב","בי אדרב"] },
      { id:7, en:"David Ganz", names:["רבידוד","דודגנז","דודגאנז","צמחדוד","בעלצמחדוד"], dates:["ה אלול","ה באלול","בה אלול"] },
      { id:8, en:"David HaLevi (the TaZ)", names:["רבידוד","דודהלוי","בעלהטז","הטז"], dates:["כו שבט","כו בשבט","בכו שבט"] },
      { id:9, en:"Hayyim ibn Attar", names:["רביחיימ","בנעטר","אבנעטר","אורהחיימ","בעלאורהחיימ","חיימבנעטר","חיימאבנעטר"], dates:["טו תמוז","טו בתמוז","בטו תמוז","יה תמוז","יה בתמוז","ביה תמוז"] },
      { id:10, en:"Yehuda ben HaRosh", names:["רבייהודה","יהודהבנהראש"], dates:["יז תמוז","יז בתמוז","ביז תמוז"] },
      { id:11, en:"Yehuda HeHasid (of Regensburg)", names:["רבייהודה","בעלספרחסידימ","יהודההחסיד"], dates:["יג אדר","יג באדר","ביג אדר"] },
      { id:12, en:"Yehuda Loew (MaHaRaL of Prague)", names:["רבייהודה","רביליוא","המהרל","מהרלמפרג","מהרלמפראג","מהרל"], dates:["יח אלול","יח באלול","ביח אלול"] },
      { id:13, en:"Yonatan Eybeschutz", names:["רבייונתנ","איבשיצ","בעלהתמימ","יונתנפרגר","יונתנאיבשיצ","יונתנפראגר","יהונתנאיבשיצ","רבייהונתנ"], dates:["כא אלול","כא באלול","בכא אלול"] },
      { id:14, en:"Yehoshua (Penei Yehoshua)", names:["רבייהושע","רביהעשיל"], dates:["כ תשרי","כ בתשרי","בכ תשרי"] },
      { id:15, en:"Yehoshua Falk (the SM\"A)", names:["רבייהושע","בעלהסמע","הסמע","יהושעפלקכצ","יהושעולקכצ"], dates:["יט ניסנ","יט בניסנ","ביט ניסנ"] },
      { id:16, en:"Yoel Sirkis (the Ba\"CH)", names:["רבייואל","סירקש","בעלהבח","הבח","יואלסירקש"], dates:["כ אדר","כ באדר","בכ אדר"] },
      { id:17, en:"Yom Tov Lipmann Heller", names:["העלר","רבייומטוב","בעלתוספותיומטוב","תוספותיומטוב","יומטובליפמנהעלר"], dates:["ו אלול","ו באלול","בו אלול"] },
      { id:18, en:"Yonah Gerondi", names:["רבייונה","רבנויונה","יונהגרונדי"], dates:["ח חשונ","ח בחשונ","בח חשונ"] },
      { id:19, en:"Yosef Karo", names:["רבייוספ","יוספקרו","יוספקארו","מהריקרו","מהריקארו","ביתיוספ","המחבר","קרו","קארו","בעלביתיוספ"], dates:["יג ניסנ","יג בניסנ","ביג ניסנ"] },
      { id:20, en:"Yehezkel Landau (Noda BiYehuda)", names:["בעלהצלח","נודעביהודה","יחזקאללנדא","לנדא","רבייחזקאל","בעלנורעביהודה","הצלח"], dates:["יח חשונ","יח בחשונ","ביח חשונ","יז איר","יז באיר","ביז איר"] },
      { id:21, en:"Ya'akov Yehoshua Falk (Penei Yehoshua)", names:["פנייהושע","בעלפנייהושע","יעקביהושעפלק","פלק","רבייעקביהושע","פאלק","יעקביהושעפאלק"], dates:["כח כסלו","כח בכסלו","בכח כסלו","יד שבט","יד בשבט","ביד שבט"] },
      { id:22, en:"Ya'akov Tam (Rabbeinu Tam)", names:["רבייעקב","רבנותמ"], dates:["ד תמוז","ד בתמוז","בד תמוז"] },
      { id:23, en:"Yitzhak Alfasi (the Rif)", names:["רבייצחק","אלפסי","רבאלפס","בעלההלכות","ריפ","הריפ","יצחקאלפסי"], dates:[] },
      { id:24, en:"Yisrael Ba'al Shem Tov", names:["רביישראל","בעלשמטוב","הבעשט","בעשט"], dates:["יח אלול","יח באלול","ביח אלול"] },
      { id:25, en:"Meir of Rothenburg (MaHaRaM)", names:["רבימאיר","המהרמ","מהרמ","מהרממרוטמבורג","מהרמברברוכ"], dates:["יט איר","יט באיר","ביט איר"] },
      { id:26, en:"Mordechai Yaffe (the Levush)", names:["רבימרדכי","מרדכייפה","הלבוש","בעלהלבוש","בעלהלבושימ","יפה"], dates:["ג אדרב","ג באדרב","בג אדרב"] },
      { id:27, en:"Moshe Isserles (the Rema)", names:["רבימשה","איסרלש","הרמא","משהאיסרלש"], dates:["יח איר","יח באיר","ביח איר"] },
      { id:28, en:"Moshe Hayyim Luzzatto (RaMCHaL)", names:["לוצטו","לוצאטו","הרמחל","רמחל","משהחיימלוצטו","רבימשהחיימ","משהחיימלוצאטו"], dates:["כו איר","כו באיר","בכו איר"] },
      { id:29, en:"Moshe ben Maimon (Rambam)", names:["רבימשה","הרמבמ","רמבמ","משהבנמימונ","משהבנמימונהספרדי"], dates:["כ טבת","כ בטבת","בכ טבת","יד ניסנ","יד בניסנ","ביד ניסנ"] },
      { id:30, en:"Tzvi Ashkenazi (Hakham Tzvi)", names:["רביצבי","חכמצבי","צביאשכנזי"], dates:["א איר","א באיר","בא איר"] },
      { id:31, en:"Shabtai HaKohen (the ShaKH)", names:["רבישבתי","שבתיכהנ","שבתיהכהנ","בעלהשכ","השכ"], dates:["א אדרא","א באדרא","בא אדרא"] },
      { id:32, en:"Shlomo Yitzhaki (Rashi)", names:["רבישלמה","רשי","שלמהיצחקי"], dates:["כט תמוז","כט בתמוז","בכט תמוז"] },
      { id:33, en:"Shlomo Luria (MaHaRShaL)", names:["רבישלמה","לוריא","מהרשל","המהרשל","שלמהלוריאאשכנזי"], dates:["יב כסלו","יב בכסלו","ביב כסלו"] },
      { id:34, en:"Shmuel Eliezer Eidels (MaHaRSHA)", names:["אידלש","מהרשא","המהרשא","שמואלאליעזראידלש","רבישמואלאליעזר"], dates:["ה כסלו","ה בכסלו","בה כסלו"] }
    ];

    // Active rabbi list (switchable via UI)
    let wrrActiveRabbis = WRR_RABBIS;
    let wrrActiveListName = 'list2';
    let wrrActiveTextName = 'genesis';

    let wrrAbort = false;
    let wrrTextNorm = null;      // Active text with sofiot normalized (Genesis or W&P)
    let wrrLetterFreqs = null;   // letter frequency map for active text
    let wrrResults = [];         // stored results for export/view
    let wrrELSCache = new Map(); // termNorm:maxSkip → hits (avoid re-searching shared terms)
    // Cache both texts so switching is instant
    let wrrGenesisNorm = null;
    let wrrWarAndPeaceNorm = null;

    // ---- Load active text and compute letter frequencies ----
    async function wrrLoadText() {
      if (wrrActiveTextName === 'genesis') {
        if (!wrrGenesisNorm) {
          let raw;
          if (torahText && torahText.length >= WRR_GENESIS_LEN) {
            raw = torahText.slice(0, WRR_GENESIS_LEN);
          } else {
            const resp = await fetch('data/torahNoSpaces.txt');
            raw = (await resp.text()).trim().slice(0, WRR_GENESIS_LEN);
          }
          wrrGenesisNorm = normalizeSofiot(raw);
        }
        wrrTextNorm = wrrGenesisNorm;
      } else {
        if (!wrrWarAndPeaceNorm) {
          const resp = await fetch('data/warAndPeace78064.txt');
          const raw = (await resp.text()).trim();
          wrrWarAndPeaceNorm = normalizeSofiot(raw);
        }
        wrrTextNorm = wrrWarAndPeaceNorm;
      }
      // Compute letter frequencies for D(w) calculation
      wrrLetterFreqs = {};
      for (const ch of wrrTextNorm) {
        wrrLetterFreqs[ch] = (wrrLetterFreqs[ch] || 0) + 1;
      }
    }
    // Alias for backward compatibility
    const wrrLoadGenesis = wrrLoadText;

    // ---- Dynamic skip range D(w) ----
    // D(w) = smallest D such that sum_{d=2}^{D} E(w,d) >= 10
    // where E(w,d) = (L - (k-1)*d) * prod(freq[letter_i] / L)
    function wrrMaxSkip(termNorm, cap) {
      const k = termNorm.length;
      const L = WRR_GENESIS_LEN;
      // Compute log-probability of match at any position
      let logP = 0;
      for (const ch of termNorm) {
        const f = wrrLetterFreqs[ch];
        if (!f) return 2; // letter not in Genesis text
        logP += Math.log(f / L);
      }
      const pMatch = Math.exp(logP);
      let cumExpected = 0;
      for (let d = 2; d <= cap; d++) {
        const validStarts = L - (k - 1) * d;
        if (validStarts <= 0) return Math.max(d - 1, 2);
        cumExpected += validStarts * pMatch;
        if (cumExpected >= 10) return d;
      }
      return cap; // rare word: search full range
    }

    // ---- Optimized ELS search with first-character filter ----
    // Finds all ELS of termNorm in text with skip in [2, maxSkip] (forward only)
    function wrrFindELSForward(text, termNorm, maxSkip) {
      const k = termNorm.length;
      const L = text.length;
      const results = [];
      const ch0 = termNorm[0];
      const ch0Pos = [];
      for (let i = 0; i < L; i++) {
        if (text[i] === ch0) ch0Pos.push(i);
      }
      for (let d = 2; d <= maxSkip; d++) {
        const maxStart = L - (k - 1) * d;
        if (maxStart <= 0) break;
        for (const s of ch0Pos) {
          if (s >= maxStart) break;
          let match = true;
          for (let i = 1; i < k; i++) {
            if (text[s + i * d] !== termNorm[i]) { match = false; break; }
          }
          if (match) results.push({ pos: s, skip: d, len: k });
        }
      }
      return results;
    }

    // ---- Search both forward and backward ELS (|skip| >= 2) ----
    // Backward ELS = reversed term with positive skip. Cached by term+maxSkip.
    function wrrFindELS(text, termNorm, maxSkip) {
      const cacheKey = termNorm + ':' + maxSkip;
      const cached = wrrELSCache.get(cacheKey);
      if (cached) return cached;

      const forward = wrrFindELSForward(text, termNorm, maxSkip);
      const rev = [...termNorm].reverse().join('');
      let results;
      if (rev === termNorm) {
        results = forward;
      } else {
        results = forward.concat(wrrFindELSForward(text, rev, maxSkip));
      }
      wrrELSCache.set(cacheKey, results);
      return results;
    }

    // ---- 2D Euclidean distance on cylindrical array ----
    // Position p on array of width w maps to row=floor(p/w), col=p%w
    function wrr2DDist(p1, p2, w) {
      const r1 = Math.floor(p1 / w), c1 = p1 % w;
      const r2 = Math.floor(p2 / w), c2 = p2 % w;
      return Math.sqrt((r1 - r2) * (r1 - r2) + (c1 - c2) * (c1 - c2));
    }

    // Min 2D distance between two ELS words, testing both array widths
    function wrrPairDist(h1, h2) {
      let minDist = Infinity;
      // Get letter positions for each ELS occurrence
      const pos1 = [];
      for (let i = 0; i < h1.len; i++) pos1.push(h1.pos + i * h1.skip);
      const pos2 = [];
      for (let i = 0; i < h2.len; i++) pos2.push(h2.pos + i * h2.skip);
      // Test both array widths: |skip1| and |skip2|
      const widths = new Set();
      if (h1.skip >= 2) widths.add(h1.skip);
      if (h2.skip >= 2) widths.add(h2.skip);
      for (const w of widths) {
        for (const a of pos1) {
          for (const b of pos2) {
            const d = wrr2DDist(a, b, w);
            if (d < minDist) minDist = d;
          }
        }
      }
      return minDist;
    }

    // Find best proximity across all name×date ELS hit combinations
    function wrrBestProximity(nameHits, dateHits) {
      let best = { dist: Infinity, nameHit: null, dateHit: null };
      for (const nh of nameHits) {
        for (const dh of dateHits) {
          const d = wrrPairDist(nh, dh);
          if (d < best.dist) best = { dist: d, nameHit: nh, dateHit: dh };
        }
      }
      return best.dist < Infinity ? best : null;
    }

    // ---- Populate rabbi table ----
    function populateWRRTable() {
      const tbody = document.getElementById('wrrTableBody');
      if (!tbody) return;
      let html = '';
      wrrActiveRabbis.forEach(r => {
        const hasDates = r.dates.length > 0;
        const pairCount = hasDates ? r.names.length * r.dates.length : 0;
        const dateStr = hasDates ? r.dates[0] : '—';
        const rowStyle = hasDates ? '' : 'opacity:0.5;';
        html += `<tr id="wrrRow${r.id}" style="border-bottom:1px solid #eee;${rowStyle}">
          <td style="padding:6px 4px;text-align:center;color:var(--gray);">${r.id}</td>
          <td style="padding:6px 4px;font-size:12px;">${r.en}</td>
          <td style="padding:6px 4px;direction:rtl;font-family:'SBL Hebrew',serif;font-size:14px;">${r.names[0]}${r.names.length > 1 ? ` <span style="color:#999;font-size:11px;">(+${r.names.length - 1})</span>` : ''}</td>
          <td style="padding:6px 4px;direction:rtl;font-family:'SBL Hebrew',serif;font-size:14px;">${dateStr}</td>
          <td style="padding:6px 4px;text-align:center;">${pairCount || '—'}</td>
          <td style="padding:6px 4px;text-align:center;font-size:11px;color:var(--gray);" id="wrrDw${r.id}">—</td>
          <td style="padding:6px 4px;text-align:center;" id="wrrResult${r.id}"><span style="color:#ccc;">—</span></td>
        </tr>`;
      });
      tbody.innerHTML = html;
    }

    // ---- Switch rabbi list ----
    window.wrrSwitchList = function(listName) {
      wrrActiveListName = listName;
      if (listName === 'list1') {
        wrrActiveRabbis = WRR_RABBIS_LIST1;
        document.getElementById('wrrStatRabbis').textContent = '34';
        document.getElementById('wrrStatRabbisLabel').textContent = 'Rabbis (List 1)';
        document.getElementById('wrrTableLabel').textContent = 'Rabbi List (WRR List 1)';
      } else {
        wrrActiveRabbis = WRR_RABBIS;
        document.getElementById('wrrStatRabbis').textContent = '32';
        document.getElementById('wrrStatRabbisLabel').textContent = 'Rabbis (List 2)';
        document.getElementById('wrrTableLabel').textContent = 'Rabbi List (WRR List 2)';
      }
      wrrResults = [];
      wrrELSCache.clear();
      populateWRRTable();
      document.getElementById('wrrSummary').style.display = 'none';
    };

    // ---- Switch text (Genesis / War and Peace) ----
    window.wrrSwitchText = function(textName) {
      wrrActiveTextName = textName;
      wrrTextNorm = null;  // Force reload
      wrrLetterFreqs = null;
      wrrELSCache.clear();
      wrrResults = [];
      const label = document.getElementById('wrrStatTextLabel');
      const note = document.getElementById('wrrTextNote');
      if (textName === 'tolstoy') {
        label.textContent = 'Letters in War & Peace';
        note.textContent = 'Control text: WRR published non-significant results for Tolstoy.';
      } else {
        label.textContent = 'Letters in Genesis';
        note.textContent = '';
      }
      populateWRRTable();
      document.getElementById('wrrSummary').style.display = 'none';
    };

    // ---- UI helpers for WRR results ----
    let wrrActiveWorker = null;
    let wrrT0 = 0;

    function wrrUpdateRabbiRow(rabbiId, maxDw, result) {
      const resultCell = document.getElementById(`wrrResult${rabbiId}`);
      const dwCell = document.getElementById(`wrrDw${rabbiId}`);
      if (dwCell) dwCell.textContent = maxDw;
      if (!result) {
        resultCell.innerHTML = '<span style="color:#ccc;" title="No ELS found in skip range">\u2014</span>';
        return;
      }
      const d = result.dist;
      const color = d < 5 ? '#1b5e20' : d < 20 ? '#2e7d32' : d < 50 ? '#558b2f' :
                    d < 100 ? '#f57f17' : d < 500 ? '#e65100' : '#c62828';
      const tip = `Name: ${result.name} (skip ${result.nameSkip})\nDate: ${result.date} (skip ${result.dateSkip})\n\u0394 = ${d.toFixed(2)} (2D Euclidean)`;
      resultCell.innerHTML = `<span style="color:${color};font-weight:bold;cursor:pointer;" title="${tip}" onclick="viewWRRPair(${rabbiId})">${d.toFixed(1)}</span>`;
    }

    function wrrShowSummary(skipCap) {
      const rabbisWithDates = wrrActiveRabbis.filter(r => r.dates.length > 0);
      const summary = document.getElementById('wrrSummary');
      const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);
      document.getElementById('wrrRunBtn').disabled = false;
      document.getElementById('wrrCancelBtn').style.display = 'none';
      document.getElementById('wrrProgressBar').style.display = 'none';
      const noMatch = rabbisWithDates.length - wrrResults.length;
      if (wrrResults.length === 0) {
        summary.style.display = '';
        summary.innerHTML = `<div style="color:#c62828;font-weight:bold;">No ELS pairs found for any rabbi (${elapsed}s). Try increasing skip cap.</div>`;
        return;
      }
      wrrResults.sort((a, b) => a.dist - b.dist);
      const median = wrrResults[Math.floor(wrrResults.length / 2)].dist;
      const avg = wrrResults.reduce((s, r) => s + r.dist, 0) / wrrResults.length;
      const geoMean = Math.exp(wrrResults.reduce((s, r) => s + Math.log(r.dist), 0) / wrrResults.length);
      const minDist = wrrResults[0].dist;
      const maxDist = wrrResults[wrrResults.length - 1].dist;
      const close20 = wrrResults.filter(r => r.dist < 20).length;
      const close100 = wrrResults.filter(r => r.dist < 100).length;
      const mode = wrrActiveWorker ? 'Web Worker' : 'main thread';
      summary.style.display = '';
      summary.innerHTML = `
        <div style="font-weight:bold;color:#2e7d32;font-size:16px;margin-bottom:8px;">Experiment Complete (${elapsed}s, ${mode})</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:8px;font-size:13px;">
          <div><strong>${wrrResults.length}</strong> / ${rabbisWithDates.length} matched${noMatch > 0 ? `, <span style="color:#c62828">${noMatch} unmatched</span>` : ''}</div>
          <div>Geometric mean \u0394: <strong>${geoMean.toFixed(2)}</strong></div>
          <div>Arithmetic mean \u0394: <strong>${avg.toFixed(1)}</strong></div>
          <div>Median \u0394: <strong>${median.toFixed(1)}</strong></div>
          <div>Range: <strong>${minDist.toFixed(1)}</strong> \u2013 <strong>${maxDist.toFixed(1)}</strong></div>
          <div>\u0394 < 20: <strong>${close20}</strong> | \u0394 < 100: <strong>${close100}</strong></div>
          <div>Skip cap: <strong>${skipCap}</strong></div>
        </div>
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
          <button class="btn btn-secondary" onclick="wrrExportCSV()" style="font-size:12px;padding:6px 12px;">Export CSV</button>
          <button class="btn" onclick="wrrRunPermTest()" id="wrrPermBtn" style="font-size:12px;padding:6px 12px;background:linear-gradient(135deg,#7b1fa2,#9c27b0);color:#fff;border:none;border-radius:6px;cursor:pointer;">
            \u{1F3B2} Permutation Test
          </button>
          <label style="font-size:11px;color:#555;">
            N=<input type="number" id="wrrPermN" value="1000" min="100" max="100000" step="100" style="width:70px;font-size:11px;padding:2px 4px;">
          </label>
        </div>
        <div id="wrrPermResults" style="display:none;margin-top:10px;padding:10px;background:#f3e5f5;border-radius:6px;border:1px solid #ce93d8;"></div>
        <div style="margin-top:8px;font-size:12px;color:#555;">
          \u0394 = min 2D Euclidean distance on cylindrical array (width = |skip|), testing both array widths per pair.
          Geometric mean is the WRR aggregate proximity measure. Click any \u0394 value to view the pair in the ELS matrix.
        </div>`;
      wrrActiveWorker = null;
    }

    // ---- Main experiment: Web Worker with main-thread fallback ----
    window.runWRRExperiment = async function() {
      wrrAbort = false;
      wrrResults = [];
      wrrELSCache.clear();

      const runBtn = document.getElementById('wrrRunBtn');
      const cancelBtn = document.getElementById('wrrCancelBtn');
      const progressBar = document.getElementById('wrrProgressBar');
      const progressFill = document.getElementById('wrrProgressFill');
      const progressText = document.getElementById('wrrProgressText');
      const summary = document.getElementById('wrrSummary');

      runBtn.disabled = true;
      cancelBtn.style.display = '';
      progressBar.style.display = '';
      summary.style.display = 'none';

      progressText.textContent = `Loading ${wrrActiveTextName === 'genesis' ? 'Genesis' : 'War and Peace'} (78,064 letters)...`;
      await wrrLoadGenesis();

      const skipCap = parseInt(document.getElementById('wrrSkipCap')?.value) || 1000;
      wrrT0 = performance.now();
      populateWRRTable();

      // Try Web Worker first (Option A: pass text via postMessage)
      try {
        const worker = new Worker('engines/wrr.worker.js');
        wrrActiveWorker = worker;
        progressText.textContent = 'Running via Web Worker (UI stays responsive)...';

        worker.onmessage = function(e) {
          const msg = e.data;
          if (msg.type === 'rabbi-done') {
            // Update progress
            const pct = Math.round((msg.completed / msg.total) * 100);
            progressFill.style.width = pct + '%';
            const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);
            progressText.textContent = `${msg.completed}/${msg.total} rabbis (${elapsed}s)`;
            // Update table row
            wrrUpdateRabbiRow(msg.rabbiId, msg.maxDw, msg.result);
            // Store result
            if (msg.result) {
              wrrResults.push({
                rabbiId: msg.rabbiId, en: msg.en, dist: msg.result.dist,
                name: msg.result.name, date: msg.result.date,
                nameSkip: msg.result.nameSkip, dateSkip: msg.result.dateSkip,
                namePos: msg.result.namePos, datePos: msg.result.datePos, maxDw: msg.maxDw
              });
            }
          } else if (msg.type === 'complete') {
            wrrShowSummary(skipCap);
          } else if (msg.type === 'error') {
            console.warn('WRR Worker error, falling back to main thread:', msg.message);
            worker.terminate();
            wrrActiveWorker = null;
            wrrResults = [];
            populateWRRTable();
            wrrRunMainThread(skipCap);
          }
        };

        worker.onerror = function(err) {
          console.warn('WRR Worker failed, falling back to main thread:', err.message);
          worker.terminate();
          wrrActiveWorker = null;
          wrrResults = [];
          populateWRRTable();
          wrrRunMainThread(skipCap);
        };

        // Send data to Worker
        worker.postMessage({
          action: 'run',
          genesisNorm: wrrTextNorm,
          rabbis: wrrActiveRabbis,
          skipCap: skipCap,
          letterFreqs: wrrLetterFreqs
        });

      } catch (e) {
        // Worker not supported or failed to create
        console.warn('Web Worker unavailable, running on main thread:', e.message);
        wrrActiveWorker = null;
        wrrRunMainThread(skipCap);
      }
    };

    // ---- Fallback: run on main thread (same algorithms, with UI yields) ----
    async function wrrRunMainThread(skipCap) {
      const progressFill = document.getElementById('wrrProgressFill');
      const progressText = document.getElementById('wrrProgressText');
      const rabbisWithDates = wrrActiveRabbis.filter(r => r.dates.length > 0);

      progressText.textContent = 'Running on main thread...';

      for (const rabbi of rabbisWithDates) {
        if (wrrAbort) break;
        const resultCell = document.getElementById(`wrrResult${rabbi.id}`);
        resultCell.innerHTML = '<span style="color:var(--orange);">&#9203;</span>';

        let bestResult = null;
        let bestDist = Infinity;
        let maxDw = 0;

        for (const nameRaw of rabbi.names) {
          if (wrrAbort) break;
          const nameNorm = normalizeSofiot(nameRaw.replace(/\s+/g, ''));
          if (nameNorm.length < 2) continue;
          const dName = wrrMaxSkip(nameNorm, skipCap);
          if (dName > maxDw) maxDw = dName;
          const nameHits = wrrFindELS(wrrTextNorm, nameNorm, dName);
          if (nameHits.length === 0) continue;
          await new Promise(r => setTimeout(r, 0));
          for (const dateRaw of rabbi.dates) {
            if (wrrAbort) break;
            const dateNorm = normalizeSofiot(dateRaw.replace(/\s+/g, ''));
            if (dateNorm.length < 2) continue;
            const dDate = wrrMaxSkip(dateNorm, skipCap);
            if (dDate > maxDw) maxDw = dDate;
            const dateHits = wrrFindELS(wrrTextNorm, dateNorm, dDate);
            if (dateHits.length === 0) continue;
            const pair = wrrBestProximity(nameHits, dateHits);
            if (pair && pair.dist < bestDist) {
              bestDist = pair.dist;
              bestResult = { nameHit: pair.nameHit, dateHit: pair.dateHit, nameStr: nameRaw, dateStr: dateRaw };
            }
          }
        }

        const result = bestResult ? {
          dist: bestDist, name: bestResult.nameStr, date: bestResult.dateStr,
          nameSkip: bestResult.nameHit.skip, dateSkip: bestResult.dateHit.skip,
          namePos: bestResult.nameHit.pos, datePos: bestResult.dateHit.pos
        } : null;
        wrrUpdateRabbiRow(rabbi.id, maxDw, result);
        if (result) {
          wrrResults.push({ rabbiId: rabbi.id, en: rabbi.en, ...result, maxDw });
        }
        const done = wrrResults.length + wrrActiveRabbis.filter(r => r.dates.length === 0).length;
        progressFill.style.width = Math.round((done / rabbisWithDates.length) * 100) + '%';
        const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);
        progressText.textContent = `${done}/${rabbisWithDates.length} rabbis (${elapsed}s, main thread)`;
        await new Promise(r => setTimeout(r, 0));
      }

      wrrShowSummary(skipCap);
    }

    window.cancelWRR = function() {
      wrrAbort = true;
      if (wrrActiveWorker) {
        wrrActiveWorker.terminate();
        wrrActiveWorker = null;
      }
      if (wrrFullWorker) {
        wrrFullWorker.terminate();
        wrrFullWorker = null;
      }
      if (wrrPermWorker) {
        wrrPermWorker.terminate();
        wrrPermWorker = null;
      }
      document.getElementById('wrrCancelBtn').style.display = 'none';
      document.getElementById('wrrRunBtn').disabled = false;
      const fullBtn = document.getElementById('wrrFullBtn');
      if (fullBtn) fullBtn.disabled = false;
      document.getElementById('wrrProgressBar').style.display = 'none';
      document.getElementById('wrrProgress').textContent = 'Cancelled';
    };

    // View a specific rabbi's best name-date pair in the scan matrix
    window.viewWRRPair = function(rabbiId) {
      const res = wrrResults.find(r => r.rabbiId === rabbiId);
      const rabbi = wrrActiveRabbis.find(r => r.id === rabbiId);
      if (!rabbi) return;
      const nameToSearch = res ? res.name.replace(/\s+/g, '') : rabbi.names[0].replace(/\s+/g, '');
      const dateToSearch = res ? res.date.replace(/\s+/g, '') : (rabbi.dates[0] || '').replace(/\s+/g, '');
      if (!dateToSearch) return;
      document.getElementById('batchTextarea').value = nameToSearch + '\n' + dateToSearch;
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('[data-mode="scan"]').classList.add('active');
      document.getElementById('scan-mode').classList.add('active');
      // Auto-trigger the scan after UI updates
      setTimeout(() => { if (typeof startScan === 'function') startScan(); }, 150);
    };

    // Export results as CSV
    window.wrrExportCSV = function() {
      if (!wrrResults.length) return;
      const hdr = 'Rabbi ID,Name (English),Best Name Form,Best Date Form,Name Skip,Date Skip,Name Pos,Date Pos,Delta (2D Euclidean),Max D(w)\n';
      const rows = wrrResults.map(r =>
        `${r.rabbiId},"${r.en}","${r.name}","${r.date}",${r.nameSkip},${r.dateSkip},${r.namePos},${r.datePos},${r.dist.toFixed(4)},${r.maxDw}`
      ).join('\n');
      const blob = new Blob(['\ufeff' + hdr + rows], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'wrr-1994-replication.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    // ---- Permutation test: shuffle rabbi↔date assignments, compute P-value ----
    let wrrPermWorker = null;

    window.wrrRunPermTest = function() {
      if (!wrrResults.length) {
        alert('Run the experiment first to get baseline results.');
        return;
      }
      const numPerm = parseInt(document.getElementById('wrrPermN')?.value) || 1000;
      const permBtn = document.getElementById('wrrPermBtn');
      const permDiv = document.getElementById('wrrPermResults');
      const skipCap = parseInt(document.getElementById('wrrSkipCap')?.value) || 1000;

      // Compute actual geometric mean from current results
      const actualGeoMean = Math.exp(
        wrrResults.reduce((s, r) => s + Math.log(r.dist), 0) / wrrResults.length
      );

      permBtn.disabled = true;
      permBtn.textContent = 'Running...';
      permDiv.style.display = '';
      permDiv.innerHTML = `<div style="font-size:13px;color:#6a1b9a;">
        <strong>Permutation Test</strong> — Pre-computing ELS hits for all terms...
        <div style="margin-top:6px;background:#e1bee7;border-radius:4px;overflow:hidden;height:8px;">
          <div id="wrrPermFill" style="width:0%;height:100%;background:linear-gradient(90deg,#7b1fa2,#ce93d8);transition:width 0.3s;"></div>
        </div>
        <div id="wrrPermStatus" style="margin-top:4px;font-size:12px;">0 / ${numPerm} permutations</div>
      </div>`;

      try {
        const worker = new Worker('engines/wrr.worker.js');
        wrrPermWorker = worker;

        worker.onmessage = function(e) {
          const msg = e.data;
          if (msg.type === 'perm-progress') {
            const fill = document.getElementById('wrrPermFill');
            const status = document.getElementById('wrrPermStatus');
            if (msg.phase === 'precomputing') {
              if (status) status.textContent = 'Pre-computing ELS hits for all terms...';
            } else {
              const pct = Math.round((msg.completed / msg.total) * 100);
              if (fill) fill.style.width = pct + '%';
              if (status) status.textContent = `${msg.completed} / ${msg.total} permutations — P \u2248 ${msg.currentPValue.toFixed(4)} (${msg.betterCount} better)`;
            }
          } else if (msg.type === 'perm-complete') {
            wrrShowPermResults(msg);
            permBtn.disabled = false;
            permBtn.textContent = '\u{1F3B2} Permutation Test';
            wrrPermWorker = null;
          } else if (msg.type === 'error') {
            permDiv.innerHTML = `<div style="color:#c62828;font-weight:bold;">Error: ${msg.message}</div>`;
            permBtn.disabled = false;
            permBtn.textContent = '\u{1F3B2} Permutation Test';
            wrrPermWorker = null;
          }
        };

        worker.onerror = function(err) {
          permDiv.innerHTML = `<div style="color:#c62828;">Worker error: ${err.message}</div>`;
          permBtn.disabled = false;
          permBtn.textContent = '\u{1F3B2} Permutation Test';
          wrrPermWorker = null;
        };

        // Ensure Genesis is loaded, then start
        wrrLoadGenesis().then(() => {
          worker.postMessage({
            action: 'permutation-test',
            genesisNorm: wrrTextNorm,
            rabbis: wrrActiveRabbis,
            skipCap,
            letterFreqs: wrrLetterFreqs,
            numPermutations: numPerm,
            actualGeoMean
          });
        });

      } catch (e) {
        permDiv.innerHTML = `<div style="color:#c62828;">Could not start permutation test: ${e.message}</div>`;
        permBtn.disabled = false;
        permBtn.textContent = '\u{1F3B2} Permutation Test';
      }
    };

    function wrrShowPermResults(msg) {
      const permDiv = document.getElementById('wrrPermResults');
      const pVal = msg.pValue;
      const pColor = pVal < 0.01 ? '#1b5e20' : pVal < 0.05 ? '#2e7d32' : pVal < 0.1 ? '#f57f17' : '#c62828';
      const sigLabel = pVal < 0.001 ? 'Highly significant' :
                       pVal < 0.01  ? 'Very significant' :
                       pVal < 0.05  ? 'Significant' :
                       pVal < 0.1   ? 'Marginally significant' : 'Not significant';
      const ratio = pVal > 0 ? Math.round(1 / pVal) : msg.numPermutations;

      // Build mini histogram from distribution
      let histHTML = '';
      if (msg.distribution && msg.distribution.length > 10) {
        const dist = msg.distribution;
        const minV = dist[0], maxV = dist[dist.length - 1];
        const bins = 30;
        const binW = (maxV - minV) / bins || 1;
        const counts = new Array(bins).fill(0);
        for (const v of dist) {
          const bi = Math.min(bins - 1, Math.floor((v - minV) / binW));
          counts[bi]++;
        }
        const maxCount = Math.max(...counts);
        const actualBin = Math.min(bins - 1, Math.floor((msg.actualGeoMean - minV) / binW));

        histHTML = '<div style="margin-top:8px;"><div style="font-size:11px;color:#555;margin-bottom:4px;">Distribution of permuted geometric means:</div>';
        histHTML += '<div style="display:flex;align-items:flex-end;height:60px;gap:1px;">';
        for (let b = 0; b < bins; b++) {
          const h = maxCount > 0 ? Math.round((counts[b] / maxCount) * 56) : 0;
          const isActual = b === actualBin;
          const bg = isActual ? '#c62828' : '#ce93d8';
          const title = `${(minV + b * binW).toFixed(1)}\u2013${(minV + (b + 1) * binW).toFixed(1)}: ${counts[b]}`;
          histHTML += `<div style="width:${Math.max(4, Math.floor(200 / bins))}px;height:${Math.max(1, h)}px;background:${bg};border-radius:1px 1px 0 0;" title="${title}"></div>`;
        }
        histHTML += '</div>';
        histHTML += `<div style="font-size:10px;color:#999;display:flex;justify-content:space-between;"><span>${minV.toFixed(1)}</span><span>Red = actual (${msg.actualGeoMean.toFixed(2)})</span><span>${maxV.toFixed(1)}</span></div>`;
        histHTML += '</div>';
      }

      permDiv.innerHTML = `
        <div style="font-weight:bold;color:#6a1b9a;font-size:14px;margin-bottom:6px;">Permutation Test Results</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:6px;font-size:13px;">
          <div>P-value: <strong style="color:${pColor};font-size:15px;">${pVal.toFixed(6)}</strong></div>
          <div>Significance: <strong style="color:${pColor};">${sigLabel}</strong></div>
          <div>Rank: <strong>${msg.betterCount}</strong> / ${msg.numPermutations} (1/${ratio})</div>
          <div>Actual geo. mean: <strong>${msg.actualGeoMean.toFixed(2)}</strong></div>
          <div>Permuted median: <strong>${msg.median.toFixed(2)}</strong></div>
          <div>Permuted mean: <strong>${msg.mean.toFixed(2)}</strong></div>
        </div>
        ${histHTML}
        <div style="margin-top:6px;font-size:11px;color:#777;">
          ${msg.numPermutations} random permutations of rabbi\u2194date assignments.
          P = fraction of permutations with geometric mean \u0394 \u2264 actual.
        </div>`;
    }

    // ---- Full WRR experiment with c(w,w') perturbation statistic ----
    let wrrFullWorker = null;

    window.wrrRunFullExperiment = async function() {
      const runBtn = document.getElementById('wrrRunBtn');
      const fullBtn = document.getElementById('wrrFullBtn');
      const cancelBtn = document.getElementById('wrrCancelBtn');
      const progressBar = document.getElementById('wrrProgressBar');
      const progressFill = document.getElementById('wrrProgressFill');
      const progressText = document.getElementById('wrrProgressText');
      const summary = document.getElementById('wrrSummary');

      runBtn.disabled = true;
      fullBtn.disabled = true;
      cancelBtn.style.display = '';
      progressBar.style.display = '';
      summary.style.display = 'none';

      progressText.textContent = `Loading ${wrrActiveTextName === 'genesis' ? 'Genesis' : 'War and Peace'} (78,064 letters)...`;
      await wrrLoadGenesis();

      const skipCap = parseInt(document.getElementById('wrrSkipCap')?.value) || 1000;
      wrrT0 = performance.now();
      populateWRRTable();

      try {
        const worker = new Worker('engines/wrr.worker.js');
        wrrFullWorker = worker;

        worker.onmessage = function(e) {
          const msg = e.data;

          if (msg.type === 'wrr-phase') {
            progressText.textContent = msg.message;

          } else if (msg.type === 'wrr-rabbi-done') {
            const pct = Math.round((msg.completed / msg.total) * 100);
            progressFill.style.width = pct + '%';
            const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);
            progressText.textContent = `c(w,w') — ${msg.completed}/${msg.total} rabbis (${elapsed}s)`;
            // Update table row with c value
            wrrUpdateRabbiRowFull(msg.result);

          } else if (msg.type === 'wrr-complete') {
            wrrShowFullSummary(msg, skipCap);

          } else if (msg.type === 'wrr-perm-precompute-progress') {
            const pct = Math.round((msg.completed / msg.total) * 100);
            progressFill.style.width = pct + '%';
            progressText.textContent = msg.message;

          } else if (msg.type === 'wrr-perm-progress') {
            const pct = Math.round((msg.completed / msg.total) * 100);
            progressFill.style.width = pct + '%';
            progressText.textContent = `Permutation ${msg.completed}/${msg.total} — P \u2248 ${msg.currentPValue.toFixed(6)}`;

          } else if (msg.type === 'wrr-perm-complete') {
            wrrShowFullPermResults(msg);
            progressBar.style.display = 'none';

          } else if (msg.type === 'error') {
            progressText.textContent = 'Error: ' + msg.message;
            console.error('WRR Full error:', msg.message);
          }
        };

        worker.onerror = function(err) {
          progressText.textContent = 'Worker error: ' + err.message;
          console.error('WRR Full worker error:', err);
          runBtn.disabled = false;
          fullBtn.disabled = false;
          cancelBtn.style.display = 'none';
        };

        const numPerm = parseInt(document.getElementById('wrrPermN2')?.value) || 0;

        worker.postMessage({
          action: 'run-wrr-full',
          genesisNorm: wrrTextNorm,
          rabbis: wrrActiveRabbis,
          skipCap,
          letterFreqs: wrrLetterFreqs,
          runPermTest: numPerm > 0,
          numPermutations: numPerm
        });

      } catch (e) {
        progressText.textContent = 'Could not start worker: ' + e.message;
        runBtn.disabled = false;
        fullBtn.disabled = false;
        cancelBtn.style.display = 'none';
      }
    };

    // Update table row with c(w,w') result
    function wrrUpdateRabbiRowFull(result) {
      if (!result) return;
      const row = document.getElementById(`wrrRow${result.rabbiId}`);
      if (!row) return;
      const cells = row.querySelectorAll('td');
      // The delta column is the last one (index 6)
      const deltaCell = cells[6];
      if (deltaCell) {
        const c = result.c;
        const color = c < 0.05 ? '#1b5e20' : c < 0.2 ? '#2e7d32' : c < 0.5 ? '#f57f17' : '#888';
        deltaCell.innerHTML = result.name
          ? `<span style="color:${color};font-weight:bold;cursor:pointer;" title="c(w,w') = ${c.toFixed(4)} | Name: ${result.name} (${result.nameHitCount} hits) | Date: ${result.date} (${result.dateHitCount} hits)">${c.toFixed(3)}</span>`
          : '<span style="color:#ccc;">\u2014</span>';
      }
    }

    // Show full WRR summary with P₁, P₂
    function wrrShowFullSummary(msg, skipCap) {
      const summary = document.getElementById('wrrSummary');
      const runBtn = document.getElementById('wrrRunBtn');
      const fullBtn = document.getElementById('wrrFullBtn');
      const cancelBtn = document.getElementById('wrrCancelBtn');
      const progressBar = document.getElementById('wrrProgressBar');

      const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);

      // Color-code overall P
      const p = msg.overallP;
      const pColor = p < 0.001 ? '#1b5e20' : p < 0.01 ? '#2e7d32' : p < 0.05 ? '#f57f17' : '#c62828';
      const sigLabel = p < 0.001 ? 'Highly significant' :
                       p < 0.01  ? 'Very significant' :
                       p < 0.05  ? 'Significant' :
                       p < 0.1   ? 'Marginally significant' : 'Not significant';

      const kLow = msg.cValues.filter(c => c < 0.2).length;
      const k10 = msg.cValues.filter(c => c < 0.1).length;
      const textLabel = wrrActiveTextName === 'genesis' ? 'Genesis' : 'War & Peace';
      const listLabel = wrrActiveListName === 'list1' ? 'List 1' : 'List 2';

      // Published Table 3 values (List 2, Genesis, 1M permutations)
      const isGenL2 = wrrActiveTextName === 'genesis' && wrrActiveListName === 'list2';
      const pubRef = isGenL2
        ? '<div style="margin-top:10px;padding:8px 12px;background:#fff3e0;border-radius:6px;border:1px solid #ffe0b2;font-size:12px;">' +
          '<strong style="color:#e65100;">WRR Published (Table 3, List 2, Genesis):</strong> ' +
          'P\u2081 rank = 453, P\u2082 rank = 5, P\u2083 rank = 570, P\u2084 rank = 4 out of 1,000,000. ' +
          '\u03C1 = 4\u00b74/(10\u2076\u22121) \u2248 16/10\u2076' +
          '</div>'
        : '';

      summary.style.display = '';
      summary.style.background = 'linear-gradient(135deg,#e8f5e9,#c8e6c9)';
      summary.style.border = '1px solid #a5d6a7';

      summary.innerHTML = `
        <div style="font-weight:bold;color:#1b5e20;font-size:16px;margin-bottom:8px;">Full WRR — c(w,w') Statistic (${textLabel}, ${listLabel}, ${elapsed}s)</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:8px;font-size:13px;">
          <div><strong>${msg.matchedCount}</strong> / ${msg.totalRabbis} rabbis matched (c &lt; 1.0)</div>
          <div>c &lt; 0.2: <strong>${kLow}</strong> / ${msg.cValues.length} &nbsp; c &lt; 0.1: <strong>${k10}</strong></div>
          <div>P\u2081 (Bin 0.2): <strong>${msg.p1.toExponential(4)}</strong></div>
          <div>P\u2082 (Gamma): <strong>${msg.p2.toExponential(4)}</strong></div>
          <div>P\u2083 (Bin 0.1): <strong>${(msg.p3 || 1).toExponential(4)}</strong></div>
          <div>P\u2084 (\u0393 trunc): <strong>${(msg.p4 || 1).toExponential(4)}</strong></div>
          <div style="font-size:15px;">P = 4\u00b7min(P\u2081..P\u2084): <strong style="color:${pColor};font-size:17px;">${p.toExponential(4)}</strong></div>
          <div>Significance: <strong style="color:${pColor};">${sigLabel}</strong></div>
          <div>Skip cap: <strong>${skipCap}</strong></div>
        </div>
        ${pubRef}
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
          <button class="btn btn-secondary" onclick="wrrExportCSVFull()" style="font-size:12px;padding:6px 12px;">Export CSV</button>
          <label style="font-size:11px;color:#555;">
            Permutation test N=<input type="number" id="wrrPermN2" value="1000" min="100" max="100000" step="100" style="width:70px;font-size:11px;padding:2px 4px;">
            <button class="btn" onclick="wrrRunFullWithPerm()" style="font-size:11px;padding:4px 10px;background:linear-gradient(135deg,#1b5e20,#388e3c);color:#fff;border:none;border-radius:4px;cursor:pointer;">
              Run Permutation Test
            </button>
          </label>
        </div>
        <div id="wrrFullPermResults" style="display:none;margin-top:10px;padding:10px;background:#e8f5e9;border-radius:6px;border:1px solid #a5d6a7;"></div>
        <div style="margin-top:8px;font-size:12px;color:#555;">
          c(w,w') = rank of actual \u03b5 proximity among 125 spatial perturbations.
          Small c \u2192 unusually close name-date ELS proximity. 10 row lengths h<sub>i</sub>=round(|d|/i) tested per pair.
        </div>`;

      runBtn.disabled = false;
      fullBtn.disabled = false;
      cancelBtn.style.display = 'none';
      if (!msg.runPermTest) progressBar.style.display = 'none';

      // Store results for re-use
      window._wrrFullResults = msg;
    }

    // Run permutation test from Full WRR summary button
    window.wrrRunFullWithPerm = function() {
      const numPerm = parseInt(document.getElementById('wrrPermN2')?.value) || 1000;
      if (numPerm < 10) { alert('Need at least 10 permutations.'); return; }

      const fullBtn = document.getElementById('wrrFullBtn');
      const progressBar = document.getElementById('wrrProgressBar');
      const progressFill = document.getElementById('wrrProgressFill');
      const progressText = document.getElementById('wrrProgressText');

      fullBtn.disabled = true;
      progressBar.style.display = '';
      progressFill.style.width = '0%';

      const skipCap = parseInt(document.getElementById('wrrSkipCap')?.value) || 1000;
      wrrT0 = performance.now();

      wrrLoadGenesis().then(() => {
        try {
          const worker = new Worker('engines/wrr.worker.js');
          wrrFullWorker = worker;

          worker.onmessage = function(e) {
            const msg = e.data;
            if (msg.type === 'wrr-phase') {
              progressText.textContent = msg.message;
            } else if (msg.type === 'wrr-rabbi-done') {
              const pct = Math.round((msg.completed / msg.total) * 100);
              progressFill.style.width = (pct * 0.3) + '%';  // 0-30% for c computation
              progressText.textContent = `c(w,w') — ${msg.completed}/${msg.total} rabbis`;
            } else if (msg.type === 'wrr-complete') {
              // c computation done, permutation test starting
              window._wrrFullResults = msg;
            } else if (msg.type === 'wrr-perm-precompute-progress') {
              const pct = Math.round((msg.completed / msg.total) * 100);
              progressFill.style.width = (30 + pct * 0.3) + '%'; // 30-60%
              progressText.textContent = msg.message;
            } else if (msg.type === 'wrr-perm-progress') {
              const pct = Math.round((msg.completed / msg.total) * 100);
              progressFill.style.width = (60 + pct * 0.4) + '%'; // 60-100%
              progressText.textContent = `Permutation ${msg.completed}/${msg.total} — P \u2248 ${msg.currentPValue.toFixed(6)}`;
            } else if (msg.type === 'wrr-perm-complete') {
              wrrShowFullPermResults(msg);
              progressBar.style.display = 'none';
              fullBtn.disabled = false;
            } else if (msg.type === 'error') {
              progressText.textContent = 'Error: ' + msg.message;
              fullBtn.disabled = false;
            }
          };

          worker.onerror = function(err) {
            progressText.textContent = 'Worker error: ' + err.message;
            fullBtn.disabled = false;
          };

          worker.postMessage({
            action: 'run-wrr-full',
            genesisNorm: wrrTextNorm,
            rabbis: wrrActiveRabbis,
            skipCap,
            letterFreqs: wrrLetterFreqs,
            runPermTest: true,
            numPermutations: numPerm
          });
        } catch (e) {
          progressText.textContent = 'Worker error: ' + e.message;
          fullBtn.disabled = false;
        }
      });
    };

    // Show permutation test results for Full WRR
    function wrrShowFullPermResults(msg) {
      const permDiv = document.getElementById('wrrFullPermResults');
      if (!permDiv) return;
      const pVal = msg.pValue;
      const pColor = pVal < 0.001 ? '#1b5e20' : pVal < 0.01 ? '#2e7d32' : pVal < 0.05 ? '#f57f17' : '#c62828';
      const sigLabel = pVal < 0.001 ? 'Highly significant' :
                       pVal < 0.01  ? 'Very significant' :
                       pVal < 0.05  ? 'Significant' :
                       pVal < 0.1   ? 'Marginally significant' : 'Not significant';
      const ratio = pVal > 0 ? Math.round(1 / pVal) : msg.numPermutations;

      permDiv.style.display = '';
      permDiv.innerHTML = `
        <div style="font-weight:bold;color:#1b5e20;font-size:14px;margin-bottom:6px;">Permutation Test (c statistic)</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:6px;font-size:13px;">
          <div>P-value: <strong style="color:${pColor};font-size:15px;">${pVal.toFixed(6)}</strong></div>
          <div>Significance: <strong style="color:${pColor};">${sigLabel}</strong></div>
          <div>Rank: <strong>${msg.betterCount}</strong> / ${msg.numPermutations} (1/${ratio})</div>
          <div>Actual P(c): <strong>${msg.actualOverallP.toExponential(4)}</strong></div>
        </div>
        <div style="margin-top:6px;font-size:11px;color:#777;">
          ${msg.numPermutations} random permutations of rabbi\u2194date assignments.
          Each permutation: compute c(w,w') for all pairings, then P\u2081\u2013P\u2084.
          P-value = fraction with overall P \u2264 actual.
        </div>`;
    }

    // CSV export for Full WRR results
    window.wrrExportCSVFull = function() {
      const results = window._wrrFullResults;
      if (!results) { alert('No full WRR results to export.'); return; }
      const rows = [['Rabbi', 'Name', 'Date', 'c(w,w\')', 'Name Hits', 'Date Hits']];
      for (const r of results.rabbiResults) {
        rows.push([r.en || r.rabbiId, r.name || '', r.date || '', r.c.toFixed(6), r.nameHitCount, r.dateHitCount]);
      }
      rows.push([]);
      rows.push(['P1 (binomial 0.2)', results.p1.toExponential(6)]);
      rows.push(['P2 (Gamma)', results.p2.toExponential(6)]);
      rows.push(['P3 (binomial 0.1)', (results.p3 || 1).toExponential(6)]);
      rows.push(['P4 (Gamma truncated)', (results.p4 || 1).toExponential(6)]);
      rows.push(['Overall P = 4*min(P1..P4)', results.overallP.toExponential(6)]);
      rows.push(['Text', wrrActiveTextName]);
      rows.push(['List', wrrActiveListName]);
      const csv = rows.map(r => r.join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'wrr-full-c-statistic.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    // Initialize WRR table
    populateWRRTable();

    // ============= 3D MATRIX VIEW =============
    let THREE = null, OrbitControls = null;
    let scene3D = null, camera3D = null, renderer3D = null, controls3D = null;
    let animFrame3D = null;
    let is3DActive = false;
    let current3DHits = null;
    let meshUserData = []; // for raycasting
    let textureCache = new Map();
    let raycaster3D = null, mouse3D = null;

    // Video capture state
    let vidRecorder = null;
    let vidStream = null;
    let vidChunks = [];
    let vidBlob = null;
    let vidStartTime = 0;
    let vidTimerInterval = null;
    let vidFrameCount = 0;
    let vidIsRecording = false;
    let vidFrameBlobs = [];  // for frame-by-frame mode
    let vidGifFrames = [];   // for GIF capture mode
    let vidGifInterval = null;

    // Lazy-load Three.js from CDN
    async function load3DDeps() {
      if (THREE) return;
      const threeModule = await import('./lib/three.module.js');
      THREE = threeModule;
      const controlsModule = await import('./lib/OrbitControls.js');
      OrbitControls = controlsModule.OrbitControls;
    }

    // Auto-compute optimal W,H from hit skip values
    function findOptimalDimensions(hits) {
      const skips = [...new Set(hits.map(h => Math.abs(h.skip)))].filter(s => s >= 2);
      if (skips.length === 0) return { W: 30, H: 15 };

      // Generate candidate W values
      const candidateWs = new Set();
      for (const s of skips) {
        if (s >= 10 && s <= 200) candidateWs.add(s);
        if (s - 1 >= 10) candidateWs.add(s - 1);
        if (s + 1 <= 200) candidateWs.add(s + 1);
        // factors of s
        for (let f = 2; f * f <= s; f++) {
          if (s % f === 0) {
            if (f >= 10 && f <= 200) candidateWs.add(f);
            if (s / f >= 10 && s / f <= 200) candidateWs.add(s / f);
          }
        }
      }
      if (candidateWs.size === 0) candidateWs.add(Math.max(Math.max(...skips), 30));

      let bestScore = -1, bestW = 30, bestH = 15;

      for (const W of candidateWs) {
        // Generate candidate H values
        const candidateHs = new Set([10, 15, 20]);
        for (const s of skips) {
          if (s % W === 0) {
            const h = s / W;
            if (h >= 3 && h <= 50) candidateHs.add(h);
          }
        }
        for (const H of candidateHs) {
          let score = 0;
          for (const s of skips) {
            if (s === W) score += 10;           // Y-axis aligned
            else if (s === W * H) score += 10;  // Z-axis aligned
            else if (W > 0 && s % W === 0) score += 7; // divisible by W
            else if (s === W + 1 || s === W - 1) score += 6; // XY diagonal
            else if (Math.abs(s - W) <= 3) score += 3;       // near axis
          }
          if (score > bestScore) { bestScore = score; bestW = W; bestH = H; }
        }
      }

      return { W: bestW, H: bestH };
    }

    // Create Hebrew letter texture on canvas
    function makeLetterTexture(letter, colorHex) {
      const key = letter + '|' + colorHex;
      if (textureCache.has(key)) return textureCache.get(key);

      const size = 64;
      const cv = document.createElement('canvas');
      cv.width = size; cv.height = size;
      const ctx = cv.getContext('2d');

      // Background with slight transparency
      ctx.fillStyle = colorHex;
      ctx.globalAlpha = 0.85;
      ctx.fillRect(0, 0, size, size);
      ctx.globalAlpha = 1;

      // Letter
      ctx.fillStyle = (colorHex === '#ffc107' || colorHex === '#00bcd4') ? '#000' : '#fff';
      ctx.font = 'bold 40px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(letter, size / 2, size / 2);

      const tex = new THREE.CanvasTexture(cv);
      tex.minFilter = THREE.LinearFilter;
      textureCache.set(key, tex);
      return tex;
    }

    // Init Three.js scene
    function init3DScene(container) {
      const w = container.clientWidth, h = container.clientHeight;

      scene3D = new THREE.Scene();
      scene3D.background = new THREE.Color('#1a1a2e');

      camera3D = new THREE.PerspectiveCamera(50, w / h, 0.1, 2000);
      camera3D.position.set(0, 0, 50);

      renderer3D = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer3D.setSize(w, h);
      renderer3D.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer3D.domElement);

      // Lights
      scene3D.add(new THREE.AmbientLight(0xffffff, 0.7));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.set(10, 20, 15);
      scene3D.add(dirLight);

      // Controls
      controls3D = new OrbitControls(camera3D, renderer3D.domElement);
      controls3D.enableDamping = true;
      controls3D.dampingFactor = 0.08;
      controls3D.autoRotate = true;
      controls3D.autoRotateSpeed = 1.0;

      // Raycaster
      raycaster3D = new THREE.Raycaster();
      mouse3D = new THREE.Vector2();

      // Mousemove for tooltips
      renderer3D.domElement.addEventListener('mousemove', onMouseMove3D);

      // Animation loop
      function animate() {
        animFrame3D = requestAnimationFrame(animate);
        controls3D.update();
        renderer3D.render(scene3D, camera3D);
      }
      animate();
    }

    // Render 3D matrix
    function render3DMatrix(hits, W, H) {
      if (!scene3D || !THREE) return;

      // Clear existing meshes (geometry shared — dispose once separately)
      const toRemove = [];
      const geoSet = new Set();
      scene3D.traverse(obj => { if (obj.isMesh) toRemove.push(obj); });
      toRemove.forEach(obj => { geoSet.add(obj.geometry); obj.material.dispose(); scene3D.remove(obj); });
      geoSet.forEach(g => g.dispose());
      meshUserData = [];

      // Build posMap: position -> { termIdxs, letter }
      const posMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          if (p < 0 || p >= torahText.length) continue;
          if (!posMap.has(p)) posMap.set(p, { termIdxs: new Set(), letter: torahText[p] });
          posMap.get(p).termIdxs.add(h.termIdx);
        }
      }

      const cellSize = 1.2;
      const layerGap = 1.5;
      const group = new THREE.Group();
      const planeGeo = new THREE.PlaneGeometry(cellSize * 0.9, cellSize * 0.9);

      // Collect positions for context neighbors
      const contextPositions = new Set();
      for (const pos of posMap.keys()) {
        for (const dp of [-1, 1, -W, W]) {
          const np = pos + dp;
          if (np >= 0 && np < torahText.length && !posMap.has(np)) contextPositions.add(np);
        }
      }

      // Render highlighted term chars
      for (const [pos, data] of posMap) {
        const col = pos % W;
        const row = Math.floor(pos / W) % H;
        const layer = Math.floor(pos / (W * H));

        const color = data.termIdxs.size > 1 ? '#9c27b0' :
          TERM_COLORS[[...data.termIdxs][0] % 8];
        const tex = makeLetterTexture(data.letter, color);
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(planeGeo, mat);

        // Position: X = col (RTL so negate), Y = -row, Z = layer * gap
        mesh.position.set(-col * cellSize, -row * cellSize, layer * cellSize * layerGap);
        group.add(mesh);

        // Store data for raycasting
        const termNames = [...data.termIdxs].map(t => scanTerms[t] || `Term ${t}`).join(', ');
        const verse = getVerseForPosition(pos);
        mesh.userData = { pos, letter: data.letter, termNames, verse, col, row, layer };
        meshUserData.push(mesh);
      }

      // Render dim context neighbors
      for (const pos of contextPositions) {
        const col = pos % W;
        const row = Math.floor(pos / W) % H;
        const layer = Math.floor(pos / (W * H));
        const letter = torahText[pos];

        const tex = makeLetterTexture(letter, '#2d2d44');
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(planeGeo, mat);
        mesh.position.set(-col * cellSize, -row * cellSize, layer * cellSize * layerGap);
        group.add(mesh);
      }

      // Layer guide planes (semi-transparent)
      const allLayers = new Set();
      for (const pos of posMap.keys()) allLayers.add(Math.floor(pos / (W * H)));
      for (const layer of allLayers) {
        const guideGeo = new THREE.PlaneGeometry(W * cellSize, H * cellSize);
        const guideMat = new THREE.MeshBasicMaterial({
          color: 0x3a3a5d, transparent: true, opacity: 0.05, side: THREE.DoubleSide
        });
        const guide = new THREE.Mesh(guideGeo, guideMat);
        guide.position.set(-W * cellSize / 2, -H * cellSize / 2, layer * cellSize * layerGap);
        group.add(guide);
      }

      scene3D.add(group);

      // Center group
      const box = new THREE.Box3().setFromObject(group);
      const center = box.getCenter(new THREE.Vector3());
      group.position.sub(center);

      fitCameraToGroup(box);

      // Update info bar
      const layers = allLayers.size;
      const infoEl = document.getElementById('matrix3DInfo');
      infoEl.style.display = 'flex';
      infoEl.innerHTML = `
        <span>W: <span class="info-val">${W}</span></span>
        <span>H: <span class="info-val">${H}</span></span>
        <span>Layers: <span class="info-val">${layers}</span></span>
        <span>Cells: <span class="info-val">${posMap.size + contextPositions.size}</span></span>
        <span style="margin-right:auto;"></span>
        <span>Drag to orbit · Scroll to zoom · Right-drag to pan</span>
      `;
    }

    function fitCameraToGroup(box) {
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera3D.fov * (Math.PI / 180);
      let dist = maxDim / (2 * Math.tan(fov / 2));
      dist *= 1.4; // padding
      camera3D.position.set(dist * 0.5, dist * 0.3, dist);
      camera3D.lookAt(0, 0, 0);
      controls3D.target.set(0, 0, 0);
      controls3D.update();
    }

    // Tooltip raycasting
    function onMouseMove3D(event) {
      if (!raycaster3D || !camera3D || meshUserData.length === 0) return;
      const rect = renderer3D.domElement.getBoundingClientRect();
      mouse3D.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse3D.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster3D.setFromCamera(mouse3D, camera3D);
      const intersects = raycaster3D.intersectObjects(meshUserData);

      const tooltip = document.getElementById('matrix3DTooltip');
      if (intersects.length > 0) {
        const d = intersects[0].object.userData;
        if (d && d.termNames) {
          tooltip.innerHTML = `<strong>${d.letter}</strong> — ${d.termNames}` +
            (d.verse ? `<br>${d.verse}` : '') +
            `<br>pos: ${d.pos.toLocaleString()} | col: ${d.col} row: ${d.row} layer: ${d.layer}`;
          tooltip.style.display = 'block';
          tooltip.style.left = (event.clientX - rect.left + 12) + 'px';
          tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
        }
      } else {
        tooltip.style.display = 'none';
      }
    }

    // Toggle between 2D and 3D views
    window.toggle3DView = async function() {
      const btn = document.getElementById('btn3DToggle');
      const d2 = document.getElementById('scanMatrix2D');
      const d3 = document.getElementById('scanMatrix3D');
      const pauseBtn = document.getElementById('btn3DPause');
      const resetBtn = document.getElementById('btn3DReset');
      const videoBtn = document.getElementById('btn3DVideo');

      if (is3DActive) {
        // Stop any active recording
        if (vidRecorder && vidRecorder.state === 'recording') vidStopRecord();
        // Switch back to 2D
        is3DActive = false;
        btn.textContent = '3D View';
        btn.classList.remove('active');
        d2.style.display = '';
        d3.style.display = 'none';
        pauseBtn.style.display = 'none';
        resetBtn.style.display = 'none';
        videoBtn.style.display = 'none';
        document.getElementById('videoControlPanel').style.display = 'none';
        destroy3DScene();
        return;
      }

      // Switch to 3D
      btn.textContent = 'Loading 3D...';
      btn.disabled = true;
      try {
        await load3DDeps();
      } catch (e) {
        alert('Failed to load Three.js: ' + e.message);
        btn.textContent = '3D View';
        btn.disabled = false;
        return;
      }

      is3DActive = true;
      btn.textContent = '2D View';
      btn.classList.add('active');
      btn.disabled = false;
      d2.style.display = 'none';
      d3.style.display = '';
      pauseBtn.style.display = '';
      resetBtn.style.display = '';
      videoBtn.style.display = '';

      const container = document.getElementById('matrix3DCanvas');
      // Remove old canvas if any
      const oldCanvas = container.querySelector('canvas');
      if (oldCanvas) oldCanvas.remove();

      init3DScene(container);

      if (current3DHits && current3DHits.length > 0) {
        const { W, H } = findOptimalDimensions(current3DHits);
        render3DMatrix(current3DHits, W, H);
      }
    };

    window.toggle3DAutoRotate = function() {
      if (!controls3D) return;
      controls3D.autoRotate = !controls3D.autoRotate;
      document.getElementById('btn3DPause').textContent =
        controls3D.autoRotate ? 'Pause Rotation' : 'Resume Rotation';
    };

    window.reset3DCamera = function() {
      if (!scene3D || !camera3D) return;
      const box = new THREE.Box3().setFromObject(scene3D);
      fitCameraToGroup(box);
    };

    function destroy3DScene() {
      if (animFrame3D) { cancelAnimationFrame(animFrame3D); animFrame3D = null; }
      if (renderer3D) {
        renderer3D.domElement.removeEventListener('mousemove', onMouseMove3D);
        renderer3D.dispose();
        const container = document.getElementById('matrix3DCanvas');
        const canvas = container?.querySelector('canvas');
        if (canvas) canvas.remove();
        renderer3D = null;
      }
      if (controls3D) { controls3D.dispose(); controls3D = null; }
      // Dispose all textures in scene
      if (scene3D) {
        scene3D.traverse(obj => {
          if (obj.isMesh) {
            obj.geometry.dispose();
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        });
        scene3D = null;
      }
      camera3D = null;
      meshUserData = [];
      textureCache.forEach(t => t.dispose());
      textureCache.clear();
      document.getElementById('matrix3DInfo').style.display = 'none';
      document.getElementById('matrix3DTooltip').style.display = 'none';
      vidCleanup();
    }

    // Resize handler
    function onResize3D() {
      if (!renderer3D || !camera3D) return;
      const container = document.getElementById('matrix3DCanvas');
      const w = container.clientWidth, h = container.clientHeight;
      camera3D.aspect = w / h;
      camera3D.updateProjectionMatrix();
      renderer3D.setSize(w, h);
    }
    window.addEventListener('resize', onResize3D);

    // ============= 3D VIDEO CAPTURE =============

    window.vidShowPanel = function() {
      const panel = document.getElementById('videoControlPanel');
      // Use getComputedStyle to detect CSS-hidden panels (not just inline style)
      const isHidden = getComputedStyle(panel).display === 'none';
      panel.style.display = isHidden ? 'block' : 'none';
    };

    function vidUpdateStatus(text) {
      document.getElementById('vidStatus').innerHTML = text;
    }

    function vidUpdateTime() {
      if (!vidIsRecording) return;
      const elapsed = (performance.now() - vidStartTime) / 1000;
      const mm = Math.floor(elapsed / 60);
      const ss = Math.floor(elapsed % 60).toString().padStart(2, '0');
      document.getElementById('vidTimeDisplay').textContent = `${mm}:${ss}`;
    }

    // Warn user if they change format during recording
    document.getElementById('vidFormatSelect')?.addEventListener('change', function() {
      if (vidIsRecording) {
        alert('Format change will apply to the NEXT recording.\nCurrent recording continues in the original format.\n\nTo record in the new format: Stop → then Record again.');
      }
      document.getElementById('vidFormatNote').textContent = 'Select before recording';
    });

    window.vidToggleRecord = function() {
      if (vidIsRecording) {
        vidStopRecord();
      } else {
        vidStartRecord();
      }
    };

    function vidStartRecord() {
      if (!renderer3D) { alert('3D view not active'); return; }

      const canvas = renderer3D.domElement;
      const fps = parseInt(document.getElementById('vidFPSSelect')?.value) || 30;
      const format = document.getElementById('vidFormatSelect')?.value || 'webm';

      // Verify canvas is valid and has dimensions
      if (!canvas || canvas.width === 0 || canvas.height === 0) {
        alert('Canvas not ready. Try rotating the 3D view first.');
        return;
      }

      // GIF mode: frame-by-frame canvas capture (no MediaRecorder needed)
      if (format === 'gif') {
        vidStartGifRecord(canvas, fps);
        return;
      }

      // Video mode (WebM): use MediaRecorder
      if (typeof canvas.captureStream !== 'function') {
        alert('captureStream() not supported. Use Chrome or Firefox.');
        return;
      }
      if (typeof MediaRecorder === 'undefined') {
        alert('MediaRecorder not supported. Use Chrome or Firefox.');
        return;
      }

      // Capture stream from the WebGL canvas
      try {
        vidStream = canvas.captureStream(fps);
      } catch (e) {
        alert('Failed to capture canvas stream: ' + e.message);
        return;
      }
      if (!vidStream || vidStream.getVideoTracks().length === 0) {
        alert('No video tracks in canvas stream. Try Chrome or Firefox.');
        return;
      }

      vidChunks = [];
      vidBlob = null;
      vidFrameCount = 0;

      // Choose best WebM codec
      let mimeType = '';
      const webmTypes = [
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm'
      ];
      for (const mt of webmTypes) {
        if (MediaRecorder.isTypeSupported(mt)) { mimeType = mt; break; }
      }

      if (!mimeType) {
        alert('No supported video codec. Try Chrome or Firefox.');
        return;
      }

      try {
        vidRecorder = new MediaRecorder(vidStream, {
          mimeType,
          videoBitsPerSecond: 5000000 // 5 Mbps for quality
        });
      } catch (e) {
        alert('Failed to create recorder: ' + e.message);
        return;
      }

      vidRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) {
          vidChunks.push(e.data);
          vidFrameCount++;
        }
      };

      vidRecorder.onstop = () => {
        vidBlob = new Blob(vidChunks, { type: mimeType });
        vidIsRecording = false;
        clearInterval(vidTimerInterval);

        const elapsed = (performance.now() - vidStartTime) / 1000;
        const mm = Math.floor(elapsed / 60);
        const ss = Math.floor(elapsed % 60).toString().padStart(2, '0');
        vidUpdateStatus(`WebM recorded: ${mm}:${ss} (${(vidBlob.size / 1024 / 1024).toFixed(1)} MB)`);

        const recBtn = document.getElementById('vidRecBtn');
        recBtn.textContent = 'Record';
        recBtn.classList.remove('recording');
        const dlBtn = document.getElementById('vidDownloadBtn');
        dlBtn.textContent = 'Download WebM';
        dlBtn.style.display = '';
        document.getElementById('vidTimeline').disabled = false;
        document.getElementById('vidTimeline').max = 100;
        document.getElementById('vidTimeline').value = 100;

        // Create preview URL for timeline scrubbing
        const url = URL.createObjectURL(vidBlob);
        vidSetupPreview(url, elapsed);
      };

      // Request data every 100ms for smooth timeline updates
      vidRecorder.start(100);
      vidIsRecording = true;
      vidStartTime = performance.now();

      const recBtn = document.getElementById('vidRecBtn');
      recBtn.textContent = 'Stop';
      recBtn.classList.add('recording');
      document.getElementById('vidDownloadBtn').style.display = 'none';
      document.getElementById('vidTimeline').disabled = true;
      vidUpdateStatus('<span class="rec-dot">&#9679;</span> Recording WebM...');

      vidTimerInterval = setInterval(vidUpdateTime, 250);
    }

    // ---- GIF Recording (universal playback) ----

    function vidStartGifRecord(canvas, fps) {
      vidGifFrames = [];
      vidBlob = null;
      vidIsRecording = true;
      vidStartTime = performance.now();
      vidFrameCount = 0;

      const delay = Math.round(1000 / fps);
      const w = canvas.width;
      const h = canvas.height;

      // Capture frames at specified FPS from WebGL canvas
      vidGifInterval = setInterval(() => {
        if (!vidIsRecording) return;
        // Force render to ensure canvas has content
        if (controls3D) controls3D.update();
        if (renderer3D && scene3D && camera3D) renderer3D.render(scene3D, camera3D);

        // Read pixels from WebGL
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        if (!gl) return;
        const pixels = new Uint8Array(w * h * 4);
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        // WebGL pixels are bottom-up, flip vertically
        const flipped = new Uint8Array(w * h * 4);
        for (let row = 0; row < h; row++) {
          const srcOff = row * w * 4;
          const dstOff = (h - 1 - row) * w * 4;
          flipped.set(pixels.subarray(srcOff, srcOff + w * 4), dstOff);
        }

        vidGifFrames.push({ data: flipped, delay });
        vidFrameCount++;
      }, delay);

      const recBtn = document.getElementById('vidRecBtn');
      recBtn.textContent = 'Stop';
      recBtn.classList.add('recording');
      document.getElementById('vidDownloadBtn').style.display = 'none';
      document.getElementById('vidTimeline').disabled = true;
      vidUpdateStatus('<span class="rec-dot">&#9679;</span> Recording GIF...');
      vidTimerInterval = setInterval(vidUpdateTime, 250);
    }

    function vidStopGifRecord() {
      clearInterval(vidGifInterval);
      vidGifInterval = null;
      vidIsRecording = false;
      clearInterval(vidTimerInterval);

      if (vidGifFrames.length === 0) {
        vidUpdateStatus('No frames captured');
        return;
      }

      const canvas = renderer3D.domElement;
      const w = canvas.width;
      const h = canvas.height;

      vidUpdateStatus(`Encoding GIF (${vidGifFrames.length} frames)...`);

      // Encode GIF asynchronously to avoid blocking UI
      setTimeout(() => {
        try {
          const gifData = encodeGIF(vidGifFrames, w, h);
          vidBlob = new Blob([gifData], { type: 'image/gif' });

          const elapsed = (performance.now() - vidStartTime) / 1000;
          const mm = Math.floor(elapsed / 60);
          const ss = Math.floor(elapsed % 60).toString().padStart(2, '0');
          vidUpdateStatus(`GIF: ${vidGifFrames.length} frames, ${mm}:${ss} (${(vidBlob.size / 1024 / 1024).toFixed(1)} MB)`);

          const recBtn = document.getElementById('vidRecBtn');
          recBtn.textContent = 'Record';
          recBtn.classList.remove('recording');
          const dlBtn = document.getElementById('vidDownloadBtn');
          dlBtn.textContent = 'Download GIF';
          dlBtn.style.display = '';
        } catch (e) {
          vidUpdateStatus('GIF encoding failed: ' + e.message);
          const recBtn = document.getElementById('vidRecBtn');
          recBtn.textContent = 'Record';
          recBtn.classList.remove('recording');
        }
        vidGifFrames = [];
      }, 50);
    }

    // Minimal GIF89a encoder (LZW compression, 256-color quantization)
    function encodeGIF(frames, width, height) {
      const buf = [];
      function writeByte(b) { buf.push(b & 0xFF); }
      function writeShort(s) { buf.push(s & 0xFF); buf.push((s >> 8) & 0xFF); }
      function writeStr(s) { for (let i = 0; i < s.length; i++) buf.push(s.charCodeAt(i)); }
      function writeBytes(arr) { for (let i = 0; i < arr.length; i++) buf.push(arr[i]); }

      // Quantize RGBA pixels to 256-color palette using median-cut simplification
      function quantize(rgba, w, h) {
        // Build a 6-bit (64-color) uniform palette for speed
        const palette = [];
        for (let r = 0; r < 4; r++)
          for (let g = 0; g < 4; g++)
            for (let b = 0; b < 4; b++)
              palette.push([(r * 85), (g * 85), (b * 85)]);
        // Pad to 256
        while (palette.length < 256) palette.push([0, 0, 0]);

        const indexed = new Uint8Array(w * h);
        for (let i = 0; i < w * h; i++) {
          const ri = rgba[i * 4], gi = rgba[i * 4 + 1], bi = rgba[i * 4 + 2];
          // Map to 6-bit uniform: r/85 * 16 + g/85 * 4 + b/85
          const idx = Math.round(ri / 85) * 16 + Math.round(gi / 85) * 4 + Math.round(bi / 85);
          indexed[i] = Math.min(idx, 63);
        }
        return { palette, indexed };
      }

      // LZW encoder for GIF
      function lzwEncode(indexed, minCodeSize) {
        const clearCode = 1 << minCodeSize;
        const eoiCode = clearCode + 1;
        let codeSize = minCodeSize + 1;
        let nextCode = eoiCode + 1;
        const maxCode = 4096;

        const output = [];
        let bitBuf = 0, bitPos = 0;

        function emit(code) {
          bitBuf |= (code << bitPos);
          bitPos += codeSize;
          while (bitPos >= 8) {
            output.push(bitBuf & 0xFF);
            bitBuf >>= 8;
            bitPos -= 8;
          }
        }

        // Initialize code table
        let table = new Map();
        function resetTable() {
          table = new Map();
          for (let i = 0; i < clearCode; i++) table.set(String(i), i);
          nextCode = eoiCode + 1;
          codeSize = minCodeSize + 1;
        }

        resetTable();
        emit(clearCode);

        let cur = String(indexed[0]);
        for (let i = 1; i < indexed.length; i++) {
          const next = String(indexed[i]);
          const combined = cur + ',' + next;
          if (table.has(combined)) {
            cur = combined;
          } else {
            emit(table.get(cur));
            if (nextCode < maxCode) {
              table.set(combined, nextCode++);
              if (nextCode > (1 << codeSize) && codeSize < 12) codeSize++;
            } else {
              emit(clearCode);
              resetTable();
            }
            cur = next;
          }
        }
        emit(table.get(cur));
        emit(eoiCode);

        // Flush remaining bits
        if (bitPos > 0) output.push(bitBuf & 0xFF);

        return output;
      }

      // --- Build GIF ---

      // Header
      writeStr('GIF89a');
      writeShort(width);
      writeShort(height);

      // Use first frame for global color table
      const q0 = quantize(frames[0].data, width, height);
      const palette = q0.palette;

      // GCT flag: yes, color resolution: 8, sorted: no, size: 256 (7 → 2^(7+1)=256)
      writeByte(0xF7); // 1_111_0_111
      writeByte(0);    // bg color index
      writeByte(0);    // pixel aspect ratio

      // Write Global Color Table (256 × 3 bytes)
      for (let i = 0; i < 256; i++) {
        writeByte(palette[i][0]);
        writeByte(palette[i][1]);
        writeByte(palette[i][2]);
      }

      // Netscape extension for looping
      writeByte(0x21); // extension
      writeByte(0xFF); // app extension
      writeByte(11);   // block size
      writeStr('NETSCAPE2.0');
      writeByte(3);    // sub-block size
      writeByte(1);    // loop sub-block id
      writeShort(0);   // loop count (0 = infinite)
      writeByte(0);    // terminator

      // Write each frame
      for (let f = 0; f < frames.length; f++) {
        const frame = frames[f];
        const q = f === 0 ? q0 : quantize(frame.data, width, height);
        const delay = Math.round(frame.delay / 10); // GIF delay is in centiseconds

        // Graphic Control Extension
        writeByte(0x21); // extension
        writeByte(0xF9); // GCE
        writeByte(4);    // block size
        writeByte(0);    // disposal: none, no transparency
        writeShort(delay);
        writeByte(0);    // transparent color index
        writeByte(0);    // terminator

        // Image Descriptor
        writeByte(0x2C);
        writeShort(0);      // left
        writeShort(0);      // top
        writeShort(width);
        writeShort(height);
        writeByte(0);       // no local color table

        // LZW minimum code size
        const minCodeSize = 8;
        writeByte(minCodeSize);

        // LZW compressed data
        const lzwData = lzwEncode(q.indexed, minCodeSize);

        // Write as sub-blocks (max 255 bytes each)
        let pos = 0;
        while (pos < lzwData.length) {
          const chunkSize = Math.min(255, lzwData.length - pos);
          writeByte(chunkSize);
          writeBytes(lzwData.slice(pos, pos + chunkSize));
          pos += chunkSize;
        }
        writeByte(0); // block terminator
      }

      // Trailer
      writeByte(0x3B);

      return new Uint8Array(buf);
    }

    function vidStopRecord() {
      // GIF mode
      if (vidGifInterval !== null || (vidGifFrames && vidGifFrames.length > 0)) {
        vidStopGifRecord();
        return;
      }
      // Video mode (WebM)
      if (vidRecorder && vidRecorder.state === 'recording') {
        vidRecorder.stop();
      }
      if (vidStream) {
        vidStream.getTracks().forEach(t => t.stop());
        vidStream = null;
      }
    }

    // Frame-by-frame: pause rotation, capture one render frame
    window.vidCaptureFrame = function() {
      if (!renderer3D || !scene3D) return;
      // Pause rotation during frame capture
      if (controls3D) controls3D.autoRotate = false;
      document.getElementById('btn3DPause').textContent = 'Resume Rotation';

      // Force one render
      controls3D.update();
      renderer3D.render(scene3D, camera3D);

      // Capture frame as PNG
      const dataUrl = renderer3D.domElement.toDataURL('image/png');
      vidFrameBlobs.push(dataUrl);
      vidUpdateStatus(`${vidFrameBlobs.length} frame(s) captured`);
    };

    // Step rotation by degrees (for precise framing)
    window.vidStepRotation = function(dir) {
      if (!controls3D || !camera3D) return;
      controls3D.autoRotate = false;
      document.getElementById('btn3DPause').textContent = 'Resume Rotation';

      const angle = dir * 5 * (Math.PI / 180); // 5 degree steps
      const pos = camera3D.position.clone();
      const target = controls3D.target.clone();
      const offset = pos.sub(target);

      // Rotate around Y axis
      const cos = Math.cos(angle), sin = Math.sin(angle);
      const x = offset.x * cos - offset.z * sin;
      const z = offset.x * sin + offset.z * cos;
      camera3D.position.set(target.x + x, camera3D.position.y, target.z + z);
      camera3D.lookAt(target);
      controls3D.update();
      renderer3D.render(scene3D, camera3D);
    };

    // Rotation speed control
    window.vidSetSpeed = function(val) {
      const speed = parseFloat(val);
      document.getElementById('vidSpeedLabel').textContent = speed.toFixed(1) + 'x';
      if (controls3D) controls3D.autoRotateSpeed = speed;
    };

    // Timeline scrubbing for recorded video
    let vidPreviewEl = null;
    let vidDuration = 0;

    function vidSetupPreview(url, duration) {
      vidDuration = duration;
      // Create hidden video element for seeking
      if (vidPreviewEl) { vidPreviewEl.pause(); vidPreviewEl.remove(); }
      vidPreviewEl = document.createElement('video');
      vidPreviewEl.src = url;
      vidPreviewEl.muted = true;
      vidPreviewEl.style.display = 'none';
      document.body.appendChild(vidPreviewEl);

      vidPreviewEl.onloadedmetadata = () => {
        vidDuration = vidPreviewEl.duration || duration;
        const mm = Math.floor(vidDuration / 60);
        const ss = Math.floor(vidDuration % 60).toString().padStart(2, '0');
        document.getElementById('vidTimeDisplay').textContent = `${mm}:${ss} / ${mm}:${ss}`;
      };
    }

    window.vidSeekTimeline = function(val) {
      if (!vidPreviewEl || !vidDuration) return;
      const pct = parseInt(val) / 100;
      const time = pct * vidDuration;
      vidPreviewEl.currentTime = time;
      const mm = Math.floor(time / 60);
      const ss = Math.floor(time % 60).toString().padStart(2, '0');
      const tMM = Math.floor(vidDuration / 60);
      const tSS = Math.floor(vidDuration % 60).toString().padStart(2, '0');
      document.getElementById('vidTimeDisplay').textContent = `${mm}:${ss} / ${tMM}:${tSS}`;
    };

    window.vidDownload = function() {
      if (!vidBlob) { alert('No recording to download'); return; }
      const ext = vidBlob.type.includes('gif') ? 'gif' : 'webm';
      const a = document.createElement('a');
      a.href = URL.createObjectURL(vidBlob);
      a.download = `els-matrix-3d-${new Date().toISOString().slice(0,19).replace(/[T:]/g,'-')}.${ext}`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 5000);
    };

    // Cleanup video state on 3D scene destroy
    function vidCleanup() {
      if (vidRecorder && vidRecorder.state === 'recording') {
        vidRecorder.stop();
      }
      if (vidStream) {
        vidStream.getTracks().forEach(t => t.stop());
        vidStream = null;
      }
      if (vidPreviewEl) {
        vidPreviewEl.pause();
        vidPreviewEl.remove();
        vidPreviewEl = null;
      }
      vidRecorder = null;
      vidChunks = [];
      vidBlob = null;
      vidIsRecording = false;
      vidFrameBlobs = [];
      vidFrameCount = 0;
      vidGifFrames = [];
      if (vidGifInterval) { clearInterval(vidGifInterval); vidGifInterval = null; }
      if (vidTimerInterval) { clearInterval(vidTimerInterval); vidTimerInterval = null; }
    }

    // ============= INIT ON LOAD =============
    init();
  </script>
</body>
</html>
