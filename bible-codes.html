<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=5">
  <meta name="theme-color" content="#1e5aa8">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ELS Search">
  <meta name="description" content="Search for Equidistant Letter Sequences (ELS) in the Hebrew Bible">
  <link rel="icon" type="image/png" href="img/favicon.png">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">
  <link rel="manifest" href="manifest.json">
  <title>ELS Search - Torah Codes</title>
  <style>
    :root {
      --blue: #1e5aa8;
      --blue-light: #e8f0f8;
      --blue-dark: #174a8a;
      --gray: #555;
      --gray-light: #f5f5f5;
      --border: #ccc;
      --green: #2e7d32;
      --red: #c62828;
      --orange: #e65100;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--gray-light);
      color: #333;
      line-height: 1.5;
    }
    .header {
      background: var(--blue);
      color: white;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .header a { color: white; text-decoration: none; }
    .header img { width: 32px; height: 32px; }
    .header h1 { font-size: 18px; font-weight: 600; }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px; }

    /* Mode Tabs */
    .mode-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 16px;
      background: white;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .mode-tab {
      flex: 1;
      padding: 14px 20px;
      border: none;
      background: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 600;
      color: var(--gray);
      transition: all 0.2s;
      text-align: center;
    }
    .mode-tab:not(:last-child) { border-left: 1px solid var(--border); }
    .mode-tab:hover { background: var(--blue-light); }
    .mode-tab.active {
      background: var(--blue);
      color: white;
    }
    .mode-tab .mode-desc {
      font-size: 11px;
      font-weight: normal;
      opacity: 0.8;
      display: block;
      margin-top: 2px;
    }

    /* Sections */
    .section {
      background: white;
      border-radius: 6px;
      padding: 20px;
      margin-bottom: 16px;
      border: 1px solid var(--border);
    }
    .section h2 {
      color: var(--blue);
      font-size: 16px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .section p { margin-bottom: 12px; color: var(--gray); font-size: 14px; }

    /* Mode content */
    .mode-content { display: none; }
    .mode-content.active { display: block; }

    /* Form elements */
    .input-row {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    input[type="text"], input[type="number"] {
      padding: 10px 12px;
      font-size: 16px;
      border: 1px solid var(--border);
      border-radius: 4px;
      min-width: 120px;
    }
    input:focus { border-color: var(--blue); outline: none; }
    .btn {
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      background: var(--blue);
      color: white;
      border: none;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .btn:hover { background: var(--blue-dark); }
    .btn:active { transform: scale(0.98); }
    .btn-secondary { background: var(--gray); }
    .btn-success { background: var(--green); }
    .btn-danger { background: var(--red); }
    .btn-small { padding: 8px 12px; font-size: 13px; }

    /* Term entries */
    .term-entries { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .term-entry { display: flex; gap: 10px; align-items: center; }
    .term-entry input { flex: 1; }
    .term-entry .remove-btn {
      background: var(--red);
      color: white;
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      cursor: pointer;
      font-size: 16px;
    }

    /* Results */
    .results {
      background: #fafafa;
      border-radius: 4px;
      padding: 15px;
      margin-top: 15px;
      border: 1px solid var(--border);
    }
    .results h3 { color: var(--blue); margin-bottom: 10px; font-size: 15px; }
    .results-scrollable { max-height: 500px; overflow-y: auto; }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .results-table th, .results-table td {
      border: 1px solid var(--border);
      padding: 8px;
      text-align: right;
    }
    .results-table th {
      background: var(--blue);
      color: white;
      position: sticky;
      top: 0;
    }
    .results-table tr:nth-child(even) { background: #f5f5f5; }
    .results-table tr:hover { background: var(--blue-light); }

    /* Stats grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .stat-box {
      background: var(--blue);
      color: white;
      padding: 14px;
      border-radius: 4px;
      text-align: center;
    }
    .stat-box .value { font-size: 20px; font-weight: bold; }
    .stat-box .label { font-size: 11px; opacity: 0.9; }

    /* Proximity matrix */
    .proximity-matrix { overflow-x: auto; margin-top: 15px; }
    .proximity-matrix table { border-collapse: collapse; font-size: 13px; width: 100%; }
    .proximity-matrix th, .proximity-matrix td {
      border: 1px solid var(--border);
      padding: 8px 12px;
      text-align: center;
    }
    .proximity-matrix th { background: var(--blue); color: white; }
    .cell-close { background: #d4edda; }
    .cell-medium { background: #fff3cd; }
    .cell-far { background: #f8d7da; }

    /* Clickable rows */
    .clickable-row { cursor: pointer; transition: background 0.15s; }
    .clickable-row:hover { background: #d0e4f7 !important; }
    .clickable-row.selected { background: var(--blue) !important; color: white; }
    .clickable-row.selected td { color: white; }

    /* Matrix view */
    .matrix-view {
      margin-top: 20px;
      padding: 20px;
      background: #2a2a3d;
      border-radius: 6px;
      color: white;
    }
    .matrix-view h3 { color: #8bb8e8; margin-bottom: 10px; }
    .matrix-view .hint { color: #999; font-size: 13px; }
    .els-matrix {
      font-family: 'Courier New', monospace;
      font-size: 16px;
      line-height: 1.8;
      direction: rtl;
      background: #1a1a28;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      white-space: pre;
      margin: 15px 0;
    }
    .els-matrix .hl1 { background: var(--red); color: white; padding: 2px; border-radius: 2px; }
    .els-matrix .hl2 { background: var(--green); color: white; padding: 2px; border-radius: 2px; }
    .els-matrix .hl-both { background: var(--orange); color: white; padding: 2px; border-radius: 2px; }
    .matrix-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }
    .matrix-stat {
      background: #3a3a4d;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    .matrix-stat .value { font-size: 16px; font-weight: bold; color: #8bb8e8; }
    .matrix-stat .label { font-size: 10px; color: #999; }

    /* Save/Load panel */
    .save-panel {
      background: var(--blue-light);
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 15px;
      border: 1px solid #c8dae8;
    }
    .saved-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: white;
      border-radius: 4px;
      margin-top: 8px;
      border: 1px solid var(--border);
    }
    .saved-item .name { font-weight: bold; color: var(--blue); }
    .saved-item .meta { font-size: 11px; color: #666; }

    /* Loading */
    .loading { text-align: center; padding: 40px; color: #666; }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #eee;
      border-top-color: var(--blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Action buttons */
    .action-row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px; }

    /* Scan mode specific */
    .range-row {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 15px;
      font-size: 14px;
    }
    .range-row label { display: flex; align-items: center; gap: 6px; }
    .range-row input[type="number"] { width: 80px; }
    .result-item {
      padding: 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }
    .result-item:hover { background: var(--blue-light); }
    .result-item .term { font-weight: bold; color: var(--blue); font-size: 18px; }
    .result-item .info { font-size: 13px; color: var(--gray); margin-top: 4px; }

    .matrix-container {
      background: #1a1a2e;
      border-radius: 8px;
      padding: 20px;
      overflow: auto;
      max-width: 100vw;
      max-height: calc(100vh - 150px);
    }
    .matrix-grid {
      display: grid;
      gap: 2px;
      direction: rtl;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      min-width: max-content;
    }
    .matrix-cell {
      width: 26px;
      height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #2d2d44;
      color: #e0e0e0;
      border-radius: 3px;
    }
    .matrix-cell.term1 { background: #ffc107; color: #000; font-weight: bold; }
    .matrix-cell.term2 { background: #00bcd4; color: #000; font-weight: bold; }
    .matrix-cell.term1.term2 { background: #9c27b0; color: #fff; }
    /* N-term color palette for scan mode */
    .matrix-cell.term-color-0 { background: #ffc107; color: #000; font-weight: bold; }
    .matrix-cell.term-color-1 { background: #00bcd4; color: #000; font-weight: bold; }
    .matrix-cell.term-color-2 { background: #ff5722; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-3 { background: #4caf50; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-4 { background: #e91e63; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-5 { background: #3f51b5; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-6 { background: #795548; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-7 { background: #607d8b; color: #fff; font-weight: bold; }
    .matrix-cell.multi-term { background: #9c27b0; color: #fff; font-weight: bold; }
    .scan-term-entries { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .scan-term-entry { display: flex; gap: 10px; align-items: center; }
    .scan-term-entry input { flex: 1; }
    .scan-term-entry .remove-btn {
      background: var(--red);
      color: white;
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      cursor: pointer;
      font-size: 16px;
    }
    .scan-term-entry .term-color-swatch {
      width: 14px; height: 14px; border-radius: 3px; flex-shrink: 0;
    }
    .cluster-row { padding: 14px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; }
    .cluster-row:hover { background: var(--blue-light); }
    .cluster-span { font-weight: bold; color: var(--green); font-size: 16px; }
    .cluster-terms { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .cluster-term-tag { padding: 4px 10px; border-radius: 4px; font-size: 13px; border: 1px solid; }
    .cluster-verses { font-size: 12px; color: #666; margin-top: 6px; }
    .matrix-legend {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      color: white;
      font-size: 13px;
      flex-wrap: wrap;
    }
    .legend-item { display: flex; align-items: center; gap: 6px; }
    .legend-color { width: 18px; height: 18px; border-radius: 3px; }
    .legend-color.t1 { background: #ffc107; }
    .legend-color.t2 { background: #00bcd4; }
    .legend-color.both { background: #9c27b0; }

    /* Info text */
    .info-text {
      background: #e8f5e9;
      border-radius: 4px;
      padding: 10px 14px;
      border-right: 3px solid var(--green);
      font-size: 13px;
      color: var(--green);
      margin-bottom: 15px;
    }

    @media (max-width: 600px) {
      .mode-tab .mode-desc { display: none; }
      .matrix-cell { width: 22px; height: 22px; font-size: 14px; }
    }
  </style>
</head>
<body>
  <header class="header">
    <a href="index.html"><img src="img/favicon.png" alt=""></a>
    <h1>ELS Search</h1>
  </header>

  <main class="container">
    <!-- Mode Tabs -->
    <div class="mode-tabs">
      <button class="mode-tab active" data-mode="index">
        Index Lookup
        <span class="mode-desc">Instant search (110K words)</span>
      </button>
      <button class="mode-tab" data-mode="scan">
        Full Scan
        <span class="mode-desc">Search any term</span>
      </button>
      <button class="mode-tab" data-mode="dict">
        Dictionary
        <span class="mode-desc">Browse 260K words</span>
      </button>
    </div>

    <!-- INDEX MODE -->
    <div id="index-mode" class="mode-content active">
      <div id="indexLoading" class="loading">
        <div class="spinner"></div>
        <div>Loading ELS Index...</div>
        <div id="loadProgress" style="margin-top: 10px; font-size: 12px;"></div>
      </div>

      <div id="indexContent" style="display: none;">
        <!-- Stats -->
        <section class="section">
          <h2>Index Statistics</h2>
          <div class="stats-grid" id="statsGrid"></div>
        </section>

        <!-- Multi-term search -->
        <section class="section">
          <h2>Search Terms</h2>

          <div class="save-panel">
            <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
              <input type="text" id="sessionName" placeholder="Session name..." style="flex: 1; min-width: 150px;">
              <button class="btn btn-success btn-small" onclick="saveSession()">Save</button>
              <button class="btn btn-secondary btn-small" onclick="exportResults()">Export</button>
              <button class="btn btn-secondary btn-small" onclick="clearSession()">Clear</button>
            </div>
            <div id="savedSessions"></div>
          </div>

          <div class="term-entries" id="termEntries">
            <div class="term-entry">
              <input type="text" class="term-input" placeholder="Term 1" value="משה" dir="rtl">
              <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
            </div>
            <div class="term-entry">
              <input type="text" class="term-input" placeholder="Term 2" value="אהרן" dir="rtl">
              <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
            </div>
          </div>

          <div class="action-row">
            <button class="btn btn-secondary" onclick="addTerm()">+ Add Term</button>
            <button class="btn" onclick="searchIndex()">Search</button>
          </div>

          <div id="indexResults"></div>
        </section>
      </div>
    </div>

    <!-- SCAN MODE -->
    <div id="scan-mode" class="mode-content">
      <section class="section">
        <h2>Real-time ELS Scan</h2>
        <p>Scans the entire Torah text for any term. Use this for words not in the index.</p>

        <div class="info-text">
          Text: Koren Edition (Rips et al., 1994) - 304,805 letters
        </div>

        <div class="scan-term-entries" id="scanTermEntries">
          <div class="scan-term-entry">
            <div class="term-color-swatch" style="background:#ffc107;"></div>
            <input type="text" class="scan-term-input" placeholder="Term 1" dir="rtl">
            <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>
          </div>
          <div class="scan-term-entry">
            <div class="term-color-swatch" style="background:#00bcd4;"></div>
            <input type="text" class="scan-term-input" placeholder="Term 2" dir="rtl">
            <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>
          </div>
        </div>

        <div class="action-row" style="margin-bottom: 15px;">
          <button class="btn btn-secondary" onclick="addScanTerm()">+ Add Term</button>
        </div>

        <div class="save-panel">
          <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
            <input type="text" id="scanSessionName" placeholder="Session name..." style="flex: 1; min-width: 150px;">
            <button class="btn btn-success btn-small" onclick="saveScanSession()">Save</button>
            <button class="btn btn-secondary btn-small" onclick="exportScanResults()">Export JSON</button>
            <button class="btn btn-secondary btn-small" onclick="clearScanSession()">Clear</button>
          </div>
          <div id="savedScanSessions"></div>
        </div>

        <div class="range-row">
          <label>Skip range: <input type="number" id="minSkip" value="-100"> to <input type="number" id="maxSkip" value="100"></label>
          <span style="font-size: 12px; color: #666;">Skip 0 excluded, ±1 = open text</span>
        </div>

        <div class="action-row">
          <button class="btn" id="scanBtn" onclick="startScan()">Search</button>
          <button class="btn btn-danger" id="scanCancelBtn" onclick="cancelScan()" style="display:none;">Cancel</button>
          <span id="scanStatus" style="font-size: 13px; color: #666;"></span>
        </div>

        <div id="scanResults"></div>

        <!-- Inline Matrix View -->
        <div id="scanMatrixView" class="matrix-view" style="display:none;">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <h3 id="scanMatrixTitle">Matrix View</h3>
            <button class="btn btn-small" onclick="downloadMatrixPNG()" style="background:#666;">Download PNG</button>
          </div>
          <div id="scanMatrixStats" class="matrix-stats"></div>
          <div class="matrix-container" style="max-height:400px;">
            <div class="matrix-grid" id="scanMatrixGrid"></div>
          </div>
          <div class="matrix-legend" id="scanMatrixLegend"></div>
        </div>
      </section>
    </div>

    <!-- DICTIONARY MODE -->
    <div id="dict-mode" class="mode-content">
      <div id="dictLoading" class="loading">
        <div class="spinner"></div>
        <div>Loading Dictionary...</div>
      </div>

      <div id="dictContent" style="display: none;">
        <section class="section">
          <h2>Dictionary Browser</h2>
          <div class="stats-grid" id="dictStats"></div>

          <div class="input-row">
            <input type="text" id="dictSearch" placeholder="Search word..." dir="rtl" style="flex: 1;">
            <select id="dictSource" style="padding: 10px; border-radius: 4px; border: 1px solid var(--border);">
              <option value="all">All Sources</option>
              <option value="bdb">BDB (Biblical)</option>
              <option value="strongs">Strong's</option>
              <option value="wiktionary">Wiktionary</option>
              <option value="tanakh">Tanakh</option>
              <option value="wikipedia">Wikipedia</option>
            </select>
            <button class="btn" onclick="searchDict()">Search</button>
          </div>

          <div class="action-row">
            <button class="btn btn-secondary" onclick="browseDict('random')">Random Words</button>
            <button class="btn btn-secondary" onclick="browseDict('frequent')">Common Words</button>
          </div>

          <div id="dictResults"></div>
        </section>
      </div>
    </div>
  </main>


  <script type="module">
    import { getElsIndexService, initElsIndex } from './engines/els-index.js';

    let elsService = null;
    let torahText = null;
    let currentResults = null;

    // ============= MODE SWITCHING =============
    document.querySelectorAll('.mode-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.mode + '-mode').classList.add('active');
      });
    });

    // ============= INIT =============
    async function init() {
      try {
        document.getElementById('loadProgress').textContent = 'Loading Torah text...';
        const resp = await fetch('data/torahNoSpaces.txt');
        torahText = await resp.text();

        document.getElementById('loadProgress').textContent = 'Loading ELS index (32MB)...';
        const metadata = await initElsIndex('data/els-index/els-index-50-min4.json.gz');
        elsService = getElsIndexService();

        document.getElementById('indexLoading').style.display = 'none';
        document.getElementById('indexContent').style.display = 'block';

        displayStats(metadata);
        loadSavedSessions();

      } catch (error) {
        console.error('Init failed:', error);
        document.getElementById('indexLoading').innerHTML =
          `<div style="color: red;">Error loading index: ${error.message}</div>`;
      }
    }

    function displayStats(meta) {
      document.getElementById('statsGrid').innerHTML = `
        <div class="stat-box"><div class="value">${meta.total_words?.toLocaleString() || '?'}</div><div class="label">Words</div></div>
        <div class="stat-box"><div class="value">${meta.total_occurrences?.toLocaleString() || '?'}</div><div class="label">Occurrences</div></div>
        <div class="stat-box"><div class="value">±${meta.skip_range?.[1] || '?'}</div><div class="label">Skip Range</div></div>
        <div class="stat-box"><div class="value">${meta.torah_length?.toLocaleString() || '?'}</div><div class="label">Letters</div></div>
      `;
    }

    // ============= INDEX MODE: TERM MANAGEMENT =============
    window.addTerm = function() {
      const container = document.getElementById('termEntries');
      const n = container.querySelectorAll('.term-entry').length + 1;
      const div = document.createElement('div');
      div.className = 'term-entry';
      div.innerHTML = `<input type="text" class="term-input" placeholder="Term ${n}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
      container.appendChild(div);
    };

    window.removeTerm = function(btn) {
      const container = document.getElementById('termEntries');
      if (container.querySelectorAll('.term-entry').length > 1) {
        btn.parentElement.remove();
      }
    };

    // ============= INDEX MODE: SEARCH =============
    window.searchIndex = function() {
      const inputs = document.querySelectorAll('.term-input');
      const terms = Array.from(inputs).map(i => i.value.trim()).filter(t => t);

      if (terms.length < 1) { alert('Enter at least one term'); return; }

      const termData = {};
      for (const term of terms) {
        const occs = elsService.findWord(term);
        termData[term] = { occurrences: occs, count: occs.length };
      }

      // Compute proximity pairs if multiple terms
      const proximityPairs = [];
      if (terms.length > 1) {
        for (let i = 0; i < terms.length; i++) {
          for (let j = i + 1; j < terms.length; j++) {
            const prox = elsService.pairProximity(terms[i], terms[j]);
            if (prox) {
              proximityPairs.push({
                term1: terms[i], term2: terms[j],
                distance: prox.distance,
                pos1: prox.word1.pos, skip1: prox.word1.skip,
                pos2: prox.word2.pos, skip2: prox.word2.skip
              });
            }
          }
        }
        proximityPairs.sort((a, b) => a.distance - b.distance);
      }

      currentResults = { terms, termData, proximityPairs, timestamp: new Date().toISOString() };
      displayIndexResults(currentResults);
    };

    function displayIndexResults(results) {
      const { terms, termData, proximityPairs } = results;

      let html = '<div class="results"><h3>Term Occurrences</h3>';
      html += '<table class="results-table"><tr><th>Term</th><th>Count</th><th>First Pos</th></tr>';
      for (const term of terms) {
        const d = termData[term];
        const firstPos = d.occurrences[0]?.pos ?? 'N/A';
        html += `<tr><td><strong>${term}</strong></td><td>${d.count.toLocaleString()}</td><td>${typeof firstPos === 'number' ? firstPos.toLocaleString() : firstPos}</td></tr>`;
      }
      html += '</table>';

      if (terms.length > 1) {
        // Proximity matrix
        const { matrix } = elsService.computeProximityMatrix(terms);
        html += '<h3 style="margin-top:20px;">Proximity Matrix</h3><div class="proximity-matrix"><table><tr><th></th>';
        terms.forEach(t => html += `<th>${t}</th>`);
        html += '</tr>';
        for (let i = 0; i < terms.length; i++) {
          html += `<tr><th>${terms[i]}</th>`;
          for (let j = 0; j < terms.length; j++) {
            const d = matrix[i][j];
            const cls = d === 0 ? '' : d < 500 ? 'cell-close' : d < 2000 ? 'cell-medium' : 'cell-far';
            html += `<td class="${cls}">${d === Infinity ? '∞' : d.toLocaleString()}</td>`;
          }
          html += '</tr>';
        }
        html += '</table></div>';

        // Pair details
        html += `<h3 style="margin-top:20px;">Proximity Pairs (${proximityPairs.length})</h3>`;
        html += '<div class="results-scrollable"><table class="results-table">';
        html += '<tr><th>#</th><th>Term 1</th><th>Term 2</th><th>Distance</th><th>Pos 1</th><th>Skip 1</th><th>Pos 2</th><th>Skip 2</th></tr>';
        proximityPairs.forEach((p, idx) => {
          const cls = p.distance < 500 ? 'cell-close' : p.distance < 2000 ? 'cell-medium' : 'cell-far';
          html += `<tr class="clickable-row" onclick="showIndexMatrix(${idx})" data-idx="${idx}">
            <td>${idx + 1}</td><td>${p.term1}</td><td>${p.term2}</td>
            <td class="${cls}">${p.distance.toLocaleString()}</td>
            <td>${p.pos1.toLocaleString()}</td><td>${p.skip1}</td>
            <td>${p.pos2.toLocaleString()}</td><td>${p.skip2}</td>
          </tr>`;
        });
        html += '</table></div>';

        // Matrix view area
        html += `<div id="indexMatrixView" class="matrix-view">
          <h3>Matrix View</h3>
          <p class="hint">Click a row above to view the matrix.</p>
          <div id="indexMatrixDisplay"></div>
        </div>`;
      }

      html += '</div>';
      document.getElementById('indexResults').innerHTML = html;
    }

    window.showIndexMatrix = function(idx) {
      if (!currentResults || !torahText) return;
      const pair = currentResults.proximityPairs[idx];
      if (!pair) return;

      document.querySelectorAll('.clickable-row').forEach(r => r.classList.remove('selected'));
      document.querySelector(`.clickable-row[data-idx="${idx}"]`)?.classList.add('selected');

      // Use skip value as width for proper alignment, or default to 30
      const width = Math.max(Math.abs(pair.skip1), Math.abs(pair.skip2), 30);
      const centerPos = Math.min(pair.pos1, pair.pos2);
      const rowsBefore = 5;
      const rowsAfter = 10;
      const startRow = Math.floor(centerPos / width) - rowsBefore;
      const endRow = startRow + rowsBefore + rowsAfter;

      const t1Pos = new Set();
      const t2Pos = new Set();
      for (let i = 0; i < pair.term1.length; i++) t1Pos.add(pair.pos1 + i * pair.skip1);
      for (let i = 0; i < pair.term2.length; i++) t2Pos.add(pair.pos2 + i * pair.skip2);

      // Build grid-based matrix like the popup
      let gridHtml = '';
      for (let row = startRow; row <= endRow; row++) {
        const rowStart = row * width;
        if (rowStart < 0) continue;
        for (let col = 0; col < width; col++) {
          const pos = rowStart + col;
          if (pos >= torahText.length) break;
          const ch = torahText[pos];
          const in1 = t1Pos.has(pos), in2 = t2Pos.has(pos);
          let cls = 'matrix-cell';
          if (in1 && in2) cls += ' term1 term2';
          else if (in1) cls += ' term1';
          else if (in2) cls += ' term2';
          gridHtml += `<div class="${cls}">${ch}</div>`;
        }
      }

      const statsHtml = `
        <div class="matrix-stats" style="margin-bottom:15px;">
          <div class="matrix-stat"><div class="value" style="color:#ffc107;">${pair.term1}</div><div class="label">Term 1</div></div>
          <div class="matrix-stat"><div class="value" style="color:#00bcd4;">${pair.term2}</div><div class="label">Term 2</div></div>
          <div class="matrix-stat"><div class="value">${pair.distance.toLocaleString()}</div><div class="label">Distance</div></div>
          <div class="matrix-stat"><div class="value">${pair.skip1}</div><div class="label">Skip 1</div></div>
          <div class="matrix-stat"><div class="value">${pair.skip2}</div><div class="label">Skip 2</div></div>
          <div class="matrix-stat"><div class="value">${pair.pos1.toLocaleString()}</div><div class="label">Pos 1</div></div>
          <div class="matrix-stat"><div class="value">${pair.pos2.toLocaleString()}</div><div class="label">Pos 2</div></div>
        </div>
        <div class="matrix-container" style="max-height:400px;">
          <div class="matrix-grid" style="grid-template-columns:repeat(${width}, 26px);">${gridHtml}</div>
        </div>
        <div class="matrix-legend" style="margin-top:15px;">
          <div class="legend-item"><div class="legend-color t1"></div><span>${pair.term1}</span></div>
          <div class="legend-item"><div class="legend-color t2"></div><span>${pair.term2}</span></div>
          <div class="legend-item"><div class="legend-color both"></div><span>Overlap</span></div>
        </div>
      `;

      document.getElementById('indexMatrixDisplay').innerHTML = statsHtml;
    };

    // ============= INDEX MODE: SESSIONS =============
    window.saveSession = function() {
      if (!currentResults) { alert('No results to save'); return; }
      const name = document.getElementById('sessionName').value.trim() || `Search ${new Date().toLocaleTimeString()}`;
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      sessions.unshift({ name, results: currentResults, savedAt: new Date().toISOString() });
      if (sessions.length > 20) sessions.length = 20;
      localStorage.setItem('elsSearchSessions', JSON.stringify(sessions));
      loadSavedSessions();
      document.getElementById('sessionName').value = '';
    };

    window.loadSession = function(idx) {
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      if (!sessions[idx]) return;
      const session = sessions[idx];
      currentResults = session.results;
      const container = document.getElementById('termEntries');
      container.innerHTML = '';
      session.results.terms.forEach(term => {
        const div = document.createElement('div');
        div.className = 'term-entry';
        div.innerHTML = `<input type="text" class="term-input" value="${term}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
        container.appendChild(div);
      });
      displayIndexResults(currentResults);
    };

    window.deleteSession = function(idx) {
      if (!confirm('Delete session?')) return;
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      sessions.splice(idx, 1);
      localStorage.setItem('elsSearchSessions', JSON.stringify(sessions));
      loadSavedSessions();
    };

    function loadSavedSessions() {
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      const container = document.getElementById('savedSessions');
      if (sessions.length === 0) {
        container.innerHTML = '<p style="font-size: 12px; color: #666; margin-top: 10px;">No saved sessions</p>';
        return;
      }
      let html = '';
      sessions.forEach((s, i) => {
        html += `<div class="saved-item">
          <div><span class="name">${s.name}</span><br><span class="meta">${s.results.terms.join(', ')}</span></div>
          <div><button class="btn btn-small btn-secondary" onclick="loadSession(${i})">Load</button>
          <button class="btn btn-small btn-danger" onclick="deleteSession(${i})">×</button></div>
        </div>`;
      });
      container.innerHTML = html;
    }

    window.exportResults = function() {
      if (!currentResults) { alert('No results'); return; }
      const blob = new Blob([JSON.stringify(currentResults, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `els-search-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
    };

    window.clearSession = function() {
      if (!confirm('Clear all?')) return;
      document.getElementById('termEntries').innerHTML = `
        <div class="term-entry"><input type="text" class="term-input" placeholder="Term 1" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button></div>
        <div class="term-entry"><input type="text" class="term-input" placeholder="Term 2" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button></div>`;
      document.getElementById('indexResults').innerHTML = '';
      currentResults = null;
    };

    // ============= SCAN MODE =============
    const TERM_COLORS = ['#ffc107','#00bcd4','#ff5722','#4caf50','#e91e63','#3f51b5','#795548','#607d8b'];
    const BOOK_NAMES = {
      1:'Genesis',2:'Exodus',3:'Leviticus',4:'Numbers',5:'Deuteronomy',
      6:'Joshua',7:'Judges',8:'1 Samuel',9:'2 Samuel',10:'1 Kings',
      11:'2 Kings',12:'Isaiah',13:'Jeremiah',14:'Ezekiel',15:'Hosea',
      16:'Joel',17:'Amos',18:'Obadiah',19:'Jonah',20:'Micah',
      21:'Nahum',22:'Habakkuk',23:'Zephaniah',24:'Haggai',25:'Zechariah',
      26:'Malachi',27:'Psalms',28:'Proverbs',29:'Job',30:'Song of Songs',
      31:'Ruth',32:'Lamentations',33:'Ecclesiastes',34:'Esther',35:'Daniel',
      36:'Ezra',37:'Nehemiah',38:'1 Chronicles',39:'2 Chronicles'
    };
    const TORAH_BOOKS = ['genesis','exodus','leviticus','numbers','deuteronomy'];

    // --- Scan term management ---
    window.addScanTerm = function() {
      const container = document.getElementById('scanTermEntries');
      const n = container.querySelectorAll('.scan-term-entry').length;
      if (n >= 8) { alert('Maximum 8 terms'); return; }
      const div = document.createElement('div');
      div.className = 'scan-term-entry';
      div.innerHTML = `<div class="term-color-swatch" style="background:${TERM_COLORS[n % 8]};"></div>
        <input type="text" class="scan-term-input" placeholder="Term ${n + 1}" dir="rtl">
        <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>`;
      container.appendChild(div);
      updateScanTermColors();
    };

    window.removeScanTerm = function(btn) {
      const container = document.getElementById('scanTermEntries');
      if (container.querySelectorAll('.scan-term-entry').length > 1) {
        btn.parentElement.remove();
        updateScanTermColors();
      }
    };

    function updateScanTermColors() {
      const entries = document.querySelectorAll('.scan-term-entry');
      entries.forEach((entry, i) => {
        const swatch = entry.querySelector('.term-color-swatch');
        if (swatch) swatch.style.background = TERM_COLORS[i % 8];
        const input = entry.querySelector('input');
        if (input) input.placeholder = `Term ${i + 1}`;
      });
    }

    // --- Character database for verse attribution ---
    let charDatabase = null;

    async function loadCharDB() {
      if (charDatabase) return;
      try {
        const allChars = [];
        for (const book of TORAH_BOOKS) {
          const resp = await fetch(`data/${book}-chars.json.gz`);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const ds = new DecompressionStream('gzip');
          const text = await new Response(blob.stream().pipeThrough(ds)).text();
          allChars.push(...JSON.parse(text));
        }
        if (allChars.length > 0) charDatabase = allChars;
      } catch (e) {
        console.log('Character database not available:', e.message);
      }
    }

    function getVerseForPosition(pos) {
      if (!charDatabase || pos < 0 || pos >= charDatabase.length) return null;
      const ch = charDatabase[pos];
      if (!ch) return null;
      const bookName = BOOK_NAMES[ch.book] || `Book ${ch.book}`;
      return `${bookName} ${ch.chapter}:${ch.verse}`;
    }

    function getVersesForHit(pos, skip, termLen) {
      if (!charDatabase) return [];
      const seen = new Set();
      const verses = [];
      for (let i = 0; i < termLen; i++) {
        const p = pos + i * skip;
        const v = getVerseForPosition(p);
        if (v && !seen.has(v)) { seen.add(v); verses.push(v); }
      }
      return verses;
    }

    // --- ELS search ---
    function findELS(text, term, skip) {
      const results = [];
      const len = text.length;
      const termLen = term.length;

      if (skip === 1) {
        // Optimized forward open-text search using indexOf
        let idx = 0;
        while ((idx = text.indexOf(term, idx)) !== -1) {
          results.push(idx);
          idx++;
        }
      } else {
        // General ELS search for all other skip values (including negative)
        for (let start = 0; start < len; start++) {
          let match = true;
          for (let i = 0; i < termLen; i++) {
            const pos = start + i * skip;
            if (pos < 0 || pos >= len || text[pos] !== term[i]) { match = false; break; }
          }
          if (match) results.push(start);
        }
      }
      return results;
    }

    // --- N-term scan ---
    let scanAbort = false;
    let scanAllResults = {};  // { term: [{pos, skip}, ...] }
    let scanTerms = [];
    let scanClusters = [];

    window.cancelScan = function() { scanAbort = true; };

    window.startScan = async function() {
      if (!torahText) {
        const resp = await fetch('data/torahNoSpaces.txt');
        torahText = await resp.text();
      }

      const inputs = document.querySelectorAll('.scan-term-input');
      const terms = Array.from(inputs).map(i => i.value.trim()).filter(t => t);
      if (terms.length < 1) { alert('Enter at least one term'); return; }

      const minSkip = parseInt(document.getElementById('minSkip').value) || -100;
      const maxSkip = parseInt(document.getElementById('maxSkip').value) || 100;

      const btn = document.getElementById('scanBtn');
      const cancelBtn = document.getElementById('scanCancelBtn');
      const status = document.getElementById('scanStatus');
      btn.disabled = true;
      btn.textContent = 'Scanning...';
      cancelBtn.style.display = '';
      scanAbort = false;

      // Load character database for verse attribution
      status.textContent = 'Loading verse database...';
      await loadCharDB();

      scanAllResults = {};
      scanTerms = terms;
      for (const term of terms) scanAllResults[term] = [];

      const totalSkips = maxSkip - minSkip + 1;
      let done = 0;

      for (let skip = minSkip; skip <= maxSkip; skip++) {
        if (scanAbort) break;
        if (skip === 0) { done++; continue; }

        done++;
        status.textContent = `Skip ${skip} (${Math.round(done / totalSkips * 100)}%)...`;
        await new Promise(r => setTimeout(r, 0));

        for (const term of terms) {
          const found = findELS(torahText, term, skip);
          for (const pos of found) scanAllResults[term].push({ pos, skip });
        }
      }

      btn.disabled = false;
      btn.textContent = 'Search';
      cancelBtn.style.display = 'none';
      status.textContent = '';

      // Find clusters if 2+ terms
      scanClusters = [];
      if (terms.length >= 2) {
        scanClusters = findClusters(terms, scanAllResults, 10000);
      }

      displayScanResults(terms, scanAllResults, scanClusters);
    };

    // --- Sliding window cluster finder ---
    function findClusters(terms, allResults, maxSpan) {
      // Merge all hits tagged by term index
      const merged = [];
      terms.forEach((term, idx) => {
        for (const hit of allResults[term]) {
          merged.push({ pos: hit.pos, skip: hit.skip, termIdx: idx, term });
        }
      });
      if (merged.length === 0) return [];

      merged.sort((a, b) => a.pos - b.pos);

      const clusters = [];
      const termCount = terms.length;
      // Count of each term in current window
      const counts = new Array(termCount).fill(0);
      let presentTerms = 0;
      let left = 0;

      for (let right = 0; right < merged.length; right++) {
        const rHit = merged[right];
        if (counts[rHit.termIdx] === 0) presentTerms++;
        counts[rHit.termIdx]++;

        // Shrink window from left while all terms still present
        while (presentTerms === termCount) {
          const span = merged[right].pos - merged[left].pos;
          if (span <= maxSpan) {
            // Record cluster: pick one hit per term (closest to center)
            const centerPos = (merged[left].pos + merged[right].pos) / 2;
            const hits = [];
            for (let t = 0; t < termCount; t++) {
              // Find best hit for this term in window
              let best = null, bestDist = Infinity;
              for (let k = left; k <= right; k++) {
                if (merged[k].termIdx === t) {
                  const d = Math.abs(merged[k].pos - centerPos);
                  if (d < bestDist) { bestDist = d; best = merged[k]; }
                }
              }
              if (best) hits.push({ ...best });
            }
            clusters.push({ span, hits, minPos: merged[left].pos, maxPos: merged[right].pos });
          }

          const lHit = merged[left];
          counts[lHit.termIdx]--;
          if (counts[lHit.termIdx] === 0) presentTerms--;
          left++;
        }
      }

      // Sort by span ascending
      clusters.sort((a, b) => a.span - b.span);

      // Deduplicate overlapping clusters (keep smallest span variant)
      const deduped = [];
      const usedKeys = new Set();
      for (const c of clusters) {
        // Key = sorted positions of chosen hits
        const key = c.hits.map(h => `${h.termIdx}:${h.pos}:${h.skip}`).sort().join('|');
        if (!usedKeys.has(key)) {
          usedKeys.add(key);
          deduped.push(c);
          if (deduped.length >= 200) break;
        }
      }

      return deduped;
    }

    // --- Display scan results ---
    function displayScanResults(terms, allResults, clusters) {
      let html = '<div class="results">';

      // Clusters section (2+ terms)
      if (terms.length >= 2 && clusters.length > 0) {
        html += `<div style="background:#fff3e0;padding:16px;border-radius:8px;border-right:4px solid #ff9800;margin-bottom:20px;">`;
        html += `<h3 style="color:#e65100;margin-bottom:12px;">Clusters (${clusters.length}) — sorted by smallest region</h3>`;
        html += `<p style="font-size:13px;color:#666;margin-bottom:12px;">Click to view matrix with all terms</p>`;
        html += '<div class="results-scrollable" style="max-height:500px;">';
        clusters.forEach((c, idx) => {
          html += `<div class="cluster-row" onclick="showClusterMatrix(${idx})">`;
          html += `<div><span class="cluster-span">${c.span.toLocaleString()} chars</span></div>`;
          html += `<div class="cluster-terms">`;
          c.hits.forEach(h => {
            const color = TERM_COLORS[h.termIdx % 8];
            const verses = getVersesForHit(h.pos, h.skip, h.term.length);
            const verseStr = verses.length > 0 ? ` [${verses.join(', ')}]` : '';
            html += `<span class="cluster-term-tag" style="background:${color}20;border-color:${color};color:#333;">
              "${h.term}" pos:${h.pos.toLocaleString()} skip:${h.skip}${verseStr}
            </span>`;
          });
          html += `</div></div>`;
        });
        html += '</div></div>';
      } else if (terms.length >= 2) {
        html += `<div style="background:#fff3e0;padding:16px;border-radius:8px;border-right:4px solid #ff9800;margin-bottom:20px;">`;
        html += `<h3 style="color:#e65100;margin-bottom:12px;">Clusters</h3>`;
        html += `<p>No clusters found — some terms may have no results.</p></div>`;
      }

      // Individual term results
      terms.forEach((term, tIdx) => {
        const results = allResults[term];
        const color = TERM_COLORS[tIdx % 8];
        html += `<h3 style="margin-top:20px;border-right:4px solid ${color};padding-right:10px;">${term}: ${results.length.toLocaleString()} occurrences</h3>`;
        if (results.length > 0) {
          html += '<div class="results-scrollable" style="max-height:300px;">';
          results.forEach((r, i) => {
            const verses = getVersesForHit(r.pos, r.skip, term.length);
            const verseStr = verses.length > 0 ? `<span style="color:#888;font-size:12px;"> — ${verses.join(', ')}</span>` : '';
            html += `<div class="result-item" onclick="showSingleTermMatrix(${tIdx}, ${i})">
              <span class="term" style="color:${color};">${term}</span>
              <span class="info">Position: ${r.pos.toLocaleString()} | Skip: ${r.skip}${verseStr}</span>
            </div>`;
          });
          html += '</div>';
        }
      });

      html += '</div>';
      document.getElementById('scanResults').innerHTML = html;
    }

    // --- Show cluster matrix ---
    window.showClusterMatrix = function(idx) {
      const cluster = scanClusters[idx];
      if (!cluster || !torahText) return;

      const view = document.getElementById('scanMatrixView');
      view.style.display = 'block';
      document.getElementById('scanMatrixTitle').textContent =
        `Cluster — ${cluster.hits.map(h => `"${h.term}"`).join(' + ')}`;

      // Stats
      let statsHtml = `<div class="matrix-stat"><div class="value">${cluster.span.toLocaleString()}</div><div class="label">Span</div></div>`;
      cluster.hits.forEach(h => {
        const color = TERM_COLORS[h.termIdx % 8];
        statsHtml += `<div class="matrix-stat">
          <div class="value" style="color:${color};">${h.term}</div>
          <div class="label">pos ${h.pos.toLocaleString()} skip ${h.skip}</div>
        </div>`;
      });
      document.getElementById('scanMatrixStats').innerHTML = statsHtml;

      // Legend
      let legendHtml = '';
      cluster.hits.forEach(h => {
        const color = TERM_COLORS[h.termIdx % 8];
        const verses = getVersesForHit(h.pos, h.skip, h.term.length);
        const verseStr = verses.length > 0 ? ` (${verses.join(', ')})` : '';
        legendHtml += `<div class="legend-item"><div class="legend-color" style="background:${color};"></div><span>${h.term}${verseStr}</span></div>`;
      });
      if (cluster.hits.length > 1) {
        legendHtml += `<div class="legend-item"><div class="legend-color" style="background:#9c27b0;"></div><span>Overlap</span></div>`;
      }
      document.getElementById('scanMatrixLegend').innerHTML = legendHtml;

      renderScanMatrix(cluster.hits);
      view.scrollIntoView({ behavior: 'smooth' });
    };

    // --- Show single term matrix ---
    window.showSingleTermMatrix = function(termIdx, resultIdx) {
      const term = scanTerms[termIdx];
      const results = scanAllResults[term];
      if (!results || !results[resultIdx] || !torahText) return;

      const r = results[resultIdx];
      const hit = { pos: r.pos, skip: r.skip, term, termIdx };

      const view = document.getElementById('scanMatrixView');
      view.style.display = 'block';
      document.getElementById('scanMatrixTitle').textContent = `"${term}"`;

      const color = TERM_COLORS[termIdx % 8];
      const verses = getVersesForHit(r.pos, r.skip, term.length);
      const verseStr = verses.length > 0 ? ` — ${verses.join(', ')}` : '';

      document.getElementById('scanMatrixStats').innerHTML = `
        <div class="matrix-stat"><div class="value" style="color:${color};">${term}</div><div class="label">Term</div></div>
        <div class="matrix-stat"><div class="value">${r.pos.toLocaleString()}</div><div class="label">Position</div></div>
        <div class="matrix-stat"><div class="value">${r.skip}</div><div class="label">Skip</div></div>
      `;
      document.getElementById('scanMatrixLegend').innerHTML = `
        <div class="legend-item"><div class="legend-color" style="background:${color};"></div><span>${term}${verseStr}</span></div>
      `;

      renderScanMatrix([hit]);
      view.scrollIntoView({ behavior: 'smooth' });
    };

    // --- Render N-term matrix ---
    function renderScanMatrix(hits) {
      // Determine grid width from max |skip|
      const width = Math.max(...hits.map(h => Math.abs(h.skip)), 30);

      // Center on cluster midpoint
      const allPositions = [];
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) allPositions.push(h.pos + i * h.skip);
      }
      const minPos = Math.min(...allPositions);
      const maxPos = Math.max(...allPositions);
      const centerPos = Math.floor((minPos + maxPos) / 2);

      const rowsBefore = 5;
      const rowsAfter = 10;
      const startRow = Math.floor(centerPos / width) - rowsBefore;
      const endRow = startRow + rowsBefore + rowsAfter;

      // Build posMap: position -> Set of termIdx
      const posMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          if (!posMap.has(p)) posMap.set(p, new Set());
          posMap.get(p).add(h.termIdx);
        }
      }

      let html = '';
      for (let row = startRow; row <= endRow; row++) {
        const rowStart = row * width;
        if (rowStart < 0) continue;
        for (let col = 0; col < width; col++) {
          const pos = rowStart + col;
          if (pos >= torahText.length) break;
          const ch = torahText[pos];
          const termSet = posMap.get(pos);
          let cls = 'matrix-cell';
          let tooltip = '';

          if (termSet) {
            if (termSet.size > 1) {
              cls += ' multi-term';
            } else {
              const idx = termSet.values().next().value;
              cls += ` term-color-${idx % 8}`;
            }
            // Tooltip with verse reference
            const verse = getVerseForPosition(pos);
            const termNames = [...termSet].map(t => scanTerms[t]).join(', ');
            tooltip = verse ? `${termNames} — ${verse}` : termNames;
          }

          html += `<div class="${cls}"${tooltip ? ` title="${tooltip}"` : ''}>${ch}</div>`;
        }
      }

      const grid = document.getElementById('scanMatrixGrid');
      grid.style.gridTemplateColumns = `repeat(${width}, 26px)`;
      grid.innerHTML = html;
    }

    // ============= SCAN MODE: SAVE/LOAD SESSIONS =============
    window.saveScanSession = function() {
      if (scanTerms.length === 0) { alert('No scan results to save'); return; }
      const name = document.getElementById('scanSessionName').value.trim() || `Scan ${new Date().toLocaleTimeString()}`;
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      sessions.unshift({
        name,
        terms: scanTerms,
        allResults: scanAllResults,
        clusters: scanClusters,
        savedAt: new Date().toISOString()
      });
      if (sessions.length > 20) sessions.length = 20;
      localStorage.setItem('elsScanSessions', JSON.stringify(sessions));
      loadSavedScanSessions();
      document.getElementById('scanSessionName').value = '';
    };

    window.loadScanSession = function(idx) {
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      if (!sessions[idx]) return;
      const s = sessions[idx];
      scanTerms = s.terms;
      scanAllResults = s.allResults;
      scanClusters = s.clusters || [];

      // Restore term inputs
      const container = document.getElementById('scanTermEntries');
      container.innerHTML = '';
      s.terms.forEach((term, i) => {
        const div = document.createElement('div');
        div.className = 'scan-term-entry';
        div.innerHTML = `<div class="term-color-swatch" style="background:${TERM_COLORS[i % 8]};"></div>
          <input type="text" class="scan-term-input" value="${term}" dir="rtl">
          <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>`;
        container.appendChild(div);
      });

      // Load char DB for verse attribution then display
      loadCharDB().then(() => {
        displayScanResults(scanTerms, scanAllResults, scanClusters);
      });
    };

    window.deleteScanSession = function(idx) {
      if (!confirm('Delete session?')) return;
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      sessions.splice(idx, 1);
      localStorage.setItem('elsScanSessions', JSON.stringify(sessions));
      loadSavedScanSessions();
    };

    function loadSavedScanSessions() {
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      const container = document.getElementById('savedScanSessions');
      if (!container) return;
      if (sessions.length === 0) {
        container.innerHTML = '<p style="font-size: 12px; color: #666; margin-top: 10px;">No saved scan sessions</p>';
        return;
      }
      let html = '';
      sessions.forEach((s, i) => {
        html += `<div class="saved-item">
          <div><span class="name">${s.name}</span><br><span class="meta">${s.terms.join(', ')}</span></div>
          <div><button class="btn btn-small btn-secondary" onclick="loadScanSession(${i})">Load</button>
          <button class="btn btn-small btn-danger" onclick="deleteScanSession(${i})">×</button></div>
        </div>`;
      });
      container.innerHTML = html;
    }

    window.exportScanResults = function() {
      if (scanTerms.length === 0) { alert('No results to export'); return; }
      const data = { terms: scanTerms, allResults: scanAllResults, clusters: scanClusters, timestamp: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `els-scan-${scanTerms.join('-')}-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
    };

    window.clearScanSession = function() {
      if (!confirm('Clear all terms and results?')) return;
      const container = document.getElementById('scanTermEntries');
      container.innerHTML = `
        <div class="scan-term-entry">
          <div class="term-color-swatch" style="background:#ffc107;"></div>
          <input type="text" class="scan-term-input" placeholder="Term 1" dir="rtl">
          <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>
        </div>
        <div class="scan-term-entry">
          <div class="term-color-swatch" style="background:#00bcd4;"></div>
          <input type="text" class="scan-term-input" placeholder="Term 2" dir="rtl">
          <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>
        </div>`;
      document.getElementById('scanResults').innerHTML = '';
      document.getElementById('scanMatrixView').style.display = 'none';
      scanTerms = [];
      scanAllResults = {};
      scanClusters = [];
    };

    // Load saved scan sessions on init
    loadSavedScanSessions();

    // ============= SCAN MODE: PDF EXPORT =============
    window.downloadMatrixPNG = function() {
      const matrixView = document.getElementById('scanMatrixView');
      if (!matrixView || matrixView.style.display === 'none') { alert('No matrix displayed'); return; }

      // Use canvas rendering approach
      const grid = document.getElementById('scanMatrixGrid');
      const cells = grid.querySelectorAll('.matrix-cell');
      if (cells.length === 0) return;

      const title = document.getElementById('scanMatrixTitle').textContent;
      const cols = parseInt(grid.style.gridTemplateColumns.match(/repeat\((\d+)/)?.[1] || '30');
      const rows = Math.ceil(cells.length / cols);
      const cellSize = 22;
      const padding = 40;
      const headerHeight = 80;

      const canvas = document.createElement('canvas');
      canvas.width = cols * cellSize + padding * 2;
      canvas.height = rows * cellSize + padding * 2 + headerHeight;
      const ctx = canvas.getContext('2d');

      // Background
      ctx.fillStyle = '#1a1a28';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Title
      ctx.fillStyle = '#8bb8e8';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(title, canvas.width / 2, 30);

      // Stats/legend text
      const legend = document.getElementById('scanMatrixLegend');
      ctx.font = '12px sans-serif';
      ctx.fillStyle = '#ccc';
      ctx.fillText(legend?.textContent?.trim() || '', canvas.width / 2, 55);

      // Color map
      const colorMap = {
        'term-color-0': '#ffc107', 'term-color-1': '#00bcd4', 'term-color-2': '#ff5722',
        'term-color-3': '#4caf50', 'term-color-4': '#e91e63', 'term-color-5': '#3f51b5',
        'term-color-6': '#795548', 'term-color-7': '#607d8b', 'multi-term': '#9c27b0'
      };

      // Draw cells
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      cells.forEach((cell, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = padding + col * cellSize;
        const y = headerHeight + padding + row * cellSize;

        // Determine cell color
        let bg = '#2d2d44';
        let fg = '#e0e0e0';
        for (const [cls, color] of Object.entries(colorMap)) {
          if (cell.classList.contains(cls)) {
            bg = color;
            fg = cls === 'term-color-0' || cls === 'term-color-1' ? '#000' : '#fff';
            break;
          }
        }

        ctx.fillStyle = bg;
        ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
        ctx.fillStyle = fg;
        ctx.fillText(cell.textContent, x + cellSize / 2, y + cellSize / 2);
      });

      // Download as PNG (simpler, universally supported, better quality than canvas-to-PDF)
      const link = document.createElement('a');
      link.download = `els-matrix-${title.replace(/[^a-zA-Z0-9א-ת]/g, '-')}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    };

    // ============= DICTIONARY MODE =============
    let dictData = null;
    let dictLoaded = false;

    async function loadDict() {
      if (dictLoaded) return;
      try {
        const resp = await fetch('data/dictionaries/unified/hebrew-unified.json.gz');
        const blob = await resp.blob();
        const ds = new DecompressionStream('gzip');
        const text = await new Response(blob.stream().pipeThrough(ds)).text();
        dictData = JSON.parse(text);
        dictLoaded = true;

        document.getElementById('dictLoading').style.display = 'none';
        document.getElementById('dictContent').style.display = 'block';

        // Stats
        const entries = Object.keys(dictData).length;
        const sources = {};
        Object.values(dictData).forEach(entry => {
          const src = entry.source || 'unknown';
          sources[src] = (sources[src] || 0) + 1;
        });
        document.getElementById('dictStats').innerHTML = `
          <div class="stat-box"><div class="value">${entries.toLocaleString()}</div><div class="label">Total Entries</div></div>
          <div class="stat-box"><div class="value">${sources.bdb?.toLocaleString() || 0}</div><div class="label">BDB</div></div>
          <div class="stat-box"><div class="value">${sources.strongs?.toLocaleString() || 0}</div><div class="label">Strong's</div></div>
          <div class="stat-box"><div class="value">${sources.wiktionary?.toLocaleString() || 0}</div><div class="label">Wiktionary</div></div>
          <div class="stat-box"><div class="value">${sources.wikipedia?.toLocaleString() || 0}</div><div class="label">Wikipedia</div></div>
        `;
      } catch (err) {
        document.getElementById('dictLoading').innerHTML = `<div style="color:red;">Error: ${err.message}</div>`;
      }
    }

    // Load dict when switching to dict tab
    document.querySelectorAll('.mode-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        if (tab.dataset.mode === 'dict' && !dictLoaded) {
          loadDict();
        }
      });
    });

    window.searchDict = function() {
      if (!dictData) return;
      const query = document.getElementById('dictSearch').value.trim();
      const source = document.getElementById('dictSource').value;
      if (!query) { browseDict('random'); return; }

      const results = [];
      for (const [word, entry] of Object.entries(dictData)) {
        if (source !== 'all' && entry.source !== source) continue;
        if (word.includes(query)) {
          results.push({ word, ...entry });
          if (results.length >= 100) break;
        }
      }

      displayDictResults(results, `Search: "${query}"`);
    };

    window.browseDict = function(mode) {
      if (!dictData) return;
      const source = document.getElementById('dictSource').value;
      const words = Object.entries(dictData)
        .filter(([w, e]) => source === 'all' || e.source === source);

      let results;
      if (mode === 'random') {
        const shuffled = words.sort(() => Math.random() - 0.5);
        results = shuffled.slice(0, 50).map(([word, entry]) => ({ word, ...entry }));
      } else {
        // Sort by some metric - for now just alphabetical
        results = words.slice(0, 50).map(([word, entry]) => ({ word, ...entry }));
      }

      displayDictResults(results, mode === 'random' ? 'Random Words' : 'Browse');
    };

    function displayDictResults(results, title) {
      if (results.length === 0) {
        document.getElementById('dictResults').innerHTML = '<div class="results"><p>No results found</p></div>';
        return;
      }

      let html = `<div class="results"><h3>${title} (${results.length})</h3>`;
      html += '<p style="font-size:12px;color:var(--gray);margin-bottom:10px;">Click word to search in ELS index, or + to add as search term</p>';
      html += '<div class="results-scrollable">';
      results.forEach(r => {
        const def = r.definition || r.gloss || r.meaning || '';
        const srcBadge = r.source ? `<span style="background:#ddd;padding:2px 6px;border-radius:3px;font-size:11px;">${r.source}</span>` : '';
        const inIndex = elsService?.hasWord(r.word);
        const indexBadge = inIndex ? '<span style="background:#d4edda;color:#2e7d32;padding:2px 6px;border-radius:3px;font-size:11px;">in index</span>' : '';
        html += `<div style="padding:12px;border-bottom:1px solid var(--border);cursor:pointer;transition:background 0.15s;"
                     onmouseover="this.style.background='var(--blue-light)'"
                     onmouseout="this.style.background='transparent'">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <span style="font-size:20px;font-weight:bold;color:var(--blue);" onclick="searchWordInELS('${r.word}')">${r.word}</span>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="btn btn-small" onclick="event.stopPropagation();addWordToSearch('${r.word}')" title="Add to search terms">+</button>
              ${indexBadge}
              ${srcBadge}
            </div>
          </div>
          ${def ? `<div style="color:var(--gray);margin-top:4px;">${def.substring(0, 200)}${def.length > 200 ? '...' : ''}</div>` : ''}
          ${r.root ? `<div style="font-size:12px;color:#888;margin-top:4px;">Root: ${r.root}</div>` : ''}
        </div>`;
      });
      html += '</div></div>';
      document.getElementById('dictResults').innerHTML = html;
    }

    window.searchWordInELS = function(word) {
      // Switch to index mode
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('.mode-tab[data-mode="index"]').classList.add('active');
      document.getElementById('index-mode').classList.add('active');

      // Set the word as first term and search
      const container = document.getElementById('termEntries');
      container.innerHTML = `<div class="term-entry">
        <input type="text" class="term-input" value="${word}" dir="rtl">
        <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
      </div>`;

      // Run search
      if (elsService) {
        const occs = elsService.findWord(word);
        currentResults = {
          terms: [word],
          termData: { [word]: { occurrences: occs, count: occs.length } },
          proximityPairs: [],
          timestamp: new Date().toISOString()
        };
        displayIndexResults(currentResults);
      }
    };

    window.addWordToSearch = function(word) {
      // Switch to index mode if not already
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('.mode-tab[data-mode="index"]').classList.add('active');
      document.getElementById('index-mode').classList.add('active');

      // Add word as new term
      const container = document.getElementById('termEntries');
      const n = container.querySelectorAll('.term-entry').length + 1;
      const div = document.createElement('div');
      div.className = 'term-entry';
      div.innerHTML = `<input type="text" class="term-input" value="${word}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
      container.appendChild(div);
    };

    // ============= INIT ON LOAD =============
    init();
  </script>
</body>
</html>
