<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=5">
  <meta name="theme-color" content="#1e5aa8">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ELS Search">
  <meta name="description" content="Search for Equidistant Letter Sequences (ELS) in the Hebrew Bible">
  <link rel="icon" type="image/png" href="img/favicon.png">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">
  <link rel="manifest" href="manifest.json">
  <title>ELS Search - Torah Codes</title>
  <style>
    :root {
      --blue: #1e5aa8;
      --blue-light: #e8f0f8;
      --blue-dark: #174a8a;
      --gray: #555;
      --gray-light: #f5f5f5;
      --border: #ccc;
      --green: #2e7d32;
      --red: #c62828;
      --orange: #e65100;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--gray-light);
      color: #333;
      line-height: 1.5;
    }
    .header {
      background: var(--blue);
      color: white;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .header a { color: white; text-decoration: none; }
    .header img { width: 32px; height: 32px; }
    .header h1 { font-size: 18px; font-weight: 600; }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px; }

    /* Mode Tabs */
    .mode-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 16px;
      background: white;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .mode-tab {
      flex: 1;
      padding: 14px 20px;
      border: none;
      background: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 600;
      color: var(--gray);
      transition: all 0.2s;
      text-align: center;
    }
    .mode-tab:not(:last-child) { border-left: 1px solid var(--border); }
    .mode-tab:hover { background: var(--blue-light); }
    .mode-tab.active {
      background: var(--blue);
      color: white;
    }
    .mode-tab .mode-desc {
      font-size: 11px;
      font-weight: normal;
      opacity: 0.8;
      display: block;
      margin-top: 2px;
    }

    /* Sections */
    .section {
      background: white;
      border-radius: 6px;
      padding: 20px;
      margin-bottom: 16px;
      border: 1px solid var(--border);
    }
    .section h2 {
      color: var(--blue);
      font-size: 16px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .section p { margin-bottom: 12px; color: var(--gray); font-size: 14px; }

    /* Mode content */
    .mode-content { display: none; }
    .mode-content.active { display: block; }

    /* Form elements */
    .input-row {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    input[type="text"], input[type="number"] {
      padding: 10px 12px;
      font-size: 16px;
      border: 1px solid var(--border);
      border-radius: 4px;
      min-width: 120px;
    }
    input:focus { border-color: var(--blue); outline: none; }
    .btn {
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      background: var(--blue);
      color: white;
      border: none;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .btn:hover { background: var(--blue-dark); }
    .btn:active { transform: scale(0.98); }
    .btn-secondary { background: var(--gray); }
    .btn-success { background: var(--green); }
    .btn-danger { background: var(--red); }
    .btn-small { padding: 8px 12px; font-size: 13px; }

    /* Term entries */
    .term-entries { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .term-entry { display: flex; gap: 10px; align-items: center; }
    .term-entry input { flex: 1; }
    .term-entry .remove-btn {
      background: var(--red);
      color: white;
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      cursor: pointer;
      font-size: 16px;
    }

    /* Results */
    .results {
      background: #fafafa;
      border-radius: 4px;
      padding: 15px;
      margin-top: 15px;
      border: 1px solid var(--border);
    }
    .results h3 { color: var(--blue); margin-bottom: 10px; font-size: 15px; }
    .results-scrollable { max-height: 500px; overflow-y: auto; }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .results-table th, .results-table td {
      border: 1px solid var(--border);
      padding: 8px;
      text-align: right;
    }
    .results-table th {
      background: var(--blue);
      color: white;
      position: sticky;
      top: 0;
    }
    .results-table tr:nth-child(even) { background: #f5f5f5; }
    .results-table tr:hover { background: var(--blue-light); }

    /* Stats grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .stat-box {
      background: var(--blue);
      color: white;
      padding: 14px;
      border-radius: 4px;
      text-align: center;
    }
    .stat-box .value { font-size: 20px; font-weight: bold; }
    .stat-box .label { font-size: 11px; opacity: 0.9; }

    /* Proximity matrix */
    .proximity-matrix { overflow-x: auto; margin-top: 15px; }
    .proximity-matrix table { border-collapse: collapse; font-size: 13px; width: 100%; }
    .proximity-matrix th, .proximity-matrix td {
      border: 1px solid var(--border);
      padding: 8px 12px;
      text-align: center;
    }
    .proximity-matrix th { background: var(--blue); color: white; }
    .cell-close { background: #d4edda; }
    .cell-medium { background: #fff3cd; }
    .cell-far { background: #f8d7da; }

    /* Clickable rows */
    .clickable-row { cursor: pointer; transition: background 0.15s; }
    .clickable-row:hover { background: #d0e4f7 !important; }
    .clickable-row.selected { background: var(--blue) !important; color: white; }
    .clickable-row.selected td { color: white; }

    /* Matrix view */
    .matrix-view {
      margin-top: 20px;
      padding: 20px;
      background: #2a2a3d;
      border-radius: 6px;
      color: white;
    }
    .matrix-view h3 { color: #8bb8e8; margin-bottom: 10px; }
    .matrix-view .hint { color: #999; font-size: 13px; }
    .els-matrix {
      font-family: 'Courier New', monospace;
      font-size: 16px;
      line-height: 1.8;
      direction: rtl;
      background: #1a1a28;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      white-space: pre;
      margin: 15px 0;
    }
    .els-matrix .hl1 { background: var(--red); color: white; padding: 2px; border-radius: 2px; }
    .els-matrix .hl2 { background: var(--green); color: white; padding: 2px; border-radius: 2px; }
    .els-matrix .hl-both { background: var(--orange); color: white; padding: 2px; border-radius: 2px; }
    .matrix-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }
    .matrix-stat {
      background: #3a3a4d;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    .matrix-stat .value { font-size: 16px; font-weight: bold; color: #8bb8e8; }
    .matrix-stat .label { font-size: 10px; color: #999; }

    /* Save/Load panel */
    .save-panel {
      background: var(--blue-light);
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 15px;
      border: 1px solid #c8dae8;
    }
    .saved-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: white;
      border-radius: 4px;
      margin-top: 8px;
      border: 1px solid var(--border);
    }
    .saved-item .name { font-weight: bold; color: var(--blue); }
    .saved-item .meta { font-size: 11px; color: #666; }

    /* Loading */
    .loading { text-align: center; padding: 40px; color: #666; }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #eee;
      border-top-color: var(--blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Action buttons */
    .action-row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px; }

    /* Scan mode specific */
    .range-row {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 15px;
      font-size: 14px;
    }
    .range-row label { display: flex; align-items: center; gap: 6px; }
    .range-row input[type="number"] { width: 80px; }
    .result-item {
      padding: 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }
    .result-item:hover { background: var(--blue-light); }
    .result-item .term { font-weight: bold; color: var(--blue); font-size: 18px; }
    .result-item .info { font-size: 13px; color: var(--gray); margin-top: 4px; }

    .matrix-container {
      background: #1a1a2e;
      border-radius: 8px;
      padding: 20px;
      overflow: auto;
      max-width: 100vw;
      max-height: calc(100vh - 150px);
    }
    .matrix-grid {
      display: grid;
      gap: 2px;
      direction: rtl;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      min-width: max-content;
    }
    .matrix-cell {
      width: 26px;
      height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #2d2d44;
      color: #e0e0e0;
      border-radius: 3px;
    }
    .matrix-cell.term1 { background: #ffc107; color: #000; font-weight: bold; }
    .matrix-cell.term2 { background: #00bcd4; color: #000; font-weight: bold; }
    .matrix-cell.term1.term2 { background: #9c27b0; color: #fff; }
    /* N-term color palette for scan mode */
    .matrix-cell.term-color-0 { background: #ffc107; color: #000; font-weight: bold; }
    .matrix-cell.term-color-1 { background: #00bcd4; color: #000; font-weight: bold; }
    .matrix-cell.term-color-2 { background: #ff5722; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-3 { background: #4caf50; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-4 { background: #e91e63; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-5 { background: #3f51b5; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-6 { background: #795548; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-7 { background: #607d8b; color: #fff; font-weight: bold; }
    .matrix-cell.multi-term { background: #9c27b0; color: #fff; font-weight: bold; }
    .scan-term-entries { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .scan-term-entry { display: flex; gap: 10px; align-items: center; }
    .scan-term-entry input { flex: 1; }
    .scan-term-entry .remove-btn {
      background: var(--red);
      color: white;
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      cursor: pointer;
      font-size: 16px;
    }
    .scan-term-entry .term-color-swatch {
      width: 14px; height: 14px; border-radius: 3px; flex-shrink: 0;
    }
    .cluster-row { padding: 14px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; }
    .cluster-row:hover { background: var(--blue-light); }
    .cluster-span { font-weight: bold; color: var(--green); font-size: 16px; }
    .cluster-terms { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .cluster-term-tag { padding: 4px 10px; border-radius: 4px; font-size: 13px; border: 1px solid; }
    .cluster-verses { font-size: 12px; color: #666; margin-top: 6px; }
    .matrix-legend {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      color: white;
      font-size: 13px;
      flex-wrap: wrap;
    }
    .legend-item { display: flex; align-items: center; gap: 6px; }
    .legend-color { width: 18px; height: 18px; border-radius: 3px; }
    .legend-color.t1 { background: #ffc107; }
    .legend-color.t2 { background: #00bcd4; }
    .legend-color.both { background: #9c27b0; }

    /* Info text */
    .info-text {
      background: #e8f5e9;
      border-radius: 4px;
      padding: 10px 14px;
      border-right: 3px solid var(--green);
      font-size: 13px;
      color: var(--green);
      margin-bottom: 15px;
    }

    /* Batch loader */
    .batch-panel {
      background: #f0f4ff;
      border: 1px solid #b0c4de;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 15px;
    }
    .batch-panel h3 { color: var(--blue-dark); font-size: 14px; margin-bottom: 10px; }
    .batch-textarea {
      width: 100%;
      height: 120px;
      font-size: 14px;
      font-family: inherit;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      direction: rtl;
      resize: vertical;
    }
    .batch-progress {
      width: 100%;
      height: 24px;
      background: #ddd;
      border-radius: 12px;
      overflow: hidden;
      margin: 10px 0;
    }
    .batch-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--blue), var(--green));
      border-radius: 12px;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      color: white;
      min-width: 40px;
    }
    .batch-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      margin-top: 12px;
    }
    .batch-table th, .batch-table td {
      border: 1px solid var(--border);
      padding: 8px 10px;
      text-align: right;
    }
    .batch-table th {
      background: var(--blue);
      color: white;
      position: sticky;
      top: 0;
      cursor: pointer;
    }
    .batch-table th:hover { background: var(--blue-dark); }
    .batch-table tr:nth-child(even) { background: #f5f5f5; }
    .batch-table tr:hover { background: var(--blue-light); }
    .batch-table tr.batch-selected { background: #c8e6c9 !important; }
    .batch-status-cell { font-size: 11px; }
    .batch-status-done { color: var(--green); font-weight: bold; }
    .batch-status-active { color: var(--orange); }
    .batch-status-pending { color: #999; }
    .batch-actions {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .batch-select-info {
      font-size: 12px;
      color: var(--gray);
      padding: 8px 0;
    }

    /* Verse hover highlight */
    .matrix-cell.verse-glow {
      box-shadow: 0 0 0 2px #fff, 0 0 8px 3px rgba(255,255,255,0.7);
      z-index: 2;
      position: relative;
    }
    .verse-ref-hover {
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 3px;
    }
    .verse-ref-hover:hover { text-decoration-style: solid; }
    #verseTooltip {
      position: fixed;
      background: rgba(0,0,0,0.92);
      color: #e0e0e0;
      padding: 10px 14px;
      border-radius: 6px;
      font-size: 15px;
      font-family: 'Courier New', monospace;
      direction: rtl;
      max-width: 500px;
      line-height: 1.8;
      pointer-events: none;
      display: none;
      z-index: 100;
      border: 1px solid #555;
    }
    #verseTooltip .verse-tooltip-ref {
      font-size: 11px;
      color: #8bb8e8;
      font-family: sans-serif;
      margin-bottom: 4px;
    }

    /* 3D Matrix View */
    .matrix-3d-container {
      height: 450px;
      background: #1a1a2e;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    .matrix-3d-container canvas { display: block; width: 100% !important; height: 100% !important; }
    #btn3DToggle.active { background: #9c27b0; }
    .btn-3d-ctrl { padding: 6px 12px; font-size: 12px; font-weight: 600; cursor: pointer; background: #555; color: #fff; border: none; border-radius: 4px; }
    .btn-3d-ctrl:hover { background: #777; }
    #matrix3DInfo {
      background: #2a2a3d;
      color: #aaa;
      font-size: 12px;
      padding: 8px 14px;
      border-radius: 0 0 8px 8px;
      display: flex;
      gap: 18px;
      flex-wrap: wrap;
    }
    #matrix3DInfo .info-val { color: #8bb8e8; font-weight: bold; }
    #matrix3DTooltip {
      position: absolute;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      z-index: 10;
      white-space: nowrap;
      direction: rtl;
    }

    @media (max-width: 600px) {
      .mode-tab .mode-desc { display: none; }
      .matrix-cell { width: 22px; height: 22px; font-size: 14px; }
      .matrix-3d-container { height: 300px; }
    }
  </style>
</head>
<body>
  <header class="header">
    <a href="index.html"><img src="img/favicon.png" alt=""></a>
    <h1>ELS Search</h1>
  </header>

  <main class="container">
    <!-- Mode Tabs -->
    <div class="mode-tabs">
      <button class="mode-tab active" data-mode="index">
        Index Lookup
        <span class="mode-desc">Instant search (110K words)</span>
      </button>
      <button class="mode-tab" data-mode="scan">
        Full Scan
        <span class="mode-desc">Search any term</span>
      </button>
      <button class="mode-tab" data-mode="dict">
        Dictionary
        <span class="mode-desc">Browse 260K words</span>
      </button>
    </div>

    <!-- INDEX MODE -->
    <div id="index-mode" class="mode-content active">
      <div id="indexLoading" class="loading">
        <div class="spinner"></div>
        <div>Loading ELS Index...</div>
        <div id="loadProgress" style="margin-top: 10px; font-size: 12px;"></div>
      </div>

      <div id="indexContent" style="display: none;">
        <!-- Stats -->
        <section class="section">
          <h2>Index Statistics</h2>
          <div class="stats-grid" id="statsGrid"></div>
        </section>

        <!-- Multi-term search -->
        <section class="section">
          <h2>Search Terms</h2>

          <div class="save-panel">
            <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
              <input type="text" id="sessionName" placeholder="Session name..." style="flex: 1; min-width: 150px;">
              <button class="btn btn-success btn-small" onclick="saveSession()">Save</button>
              <button class="btn btn-secondary btn-small" onclick="exportResults()">Export</button>
              <button class="btn btn-secondary btn-small" onclick="clearSession()">Clear</button>
            </div>
            <div id="savedSessions"></div>
          </div>

          <div class="term-entries" id="termEntries">
            <div class="term-entry">
              <input type="text" class="term-input" placeholder="Term 1" dir="rtl">
              <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
            </div>
            <div class="term-entry">
              <input type="text" class="term-input" placeholder="Term 2" dir="rtl">
              <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
            </div>
          </div>

          <div class="action-row">
            <button class="btn btn-secondary" onclick="addTerm()">+ Add Term</button>
            <button class="btn" onclick="searchIndex()">Search</button>
          </div>

          <div id="indexResults"></div>
        </section>
      </div>
    </div>

    <!-- SCAN MODE -->
    <div id="scan-mode" class="mode-content">
      <section class="section">
        <h2>Real-time ELS Scan</h2>
        <p>Scans the entire Torah text for any term. Use this for words not in the index.</p>

        <div class="info-text">
          Text: Koren Edition (Rips et al., 1994) - 304,805 letters
        </div>

        <div class="scan-term-entries" id="scanTermEntries">
          <div class="scan-term-entry">
            <div class="term-color-swatch" style="background:#ffc107;"></div>
            <input type="text" class="scan-term-input" placeholder="Term 1" dir="rtl">
            <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>
          </div>
          <div class="scan-term-entry">
            <div class="term-color-swatch" style="background:#00bcd4;"></div>
            <input type="text" class="scan-term-input" placeholder="Term 2" dir="rtl">
            <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>
          </div>
        </div>

        <div class="action-row" style="margin-bottom: 15px;">
          <button class="btn btn-secondary" onclick="addScanTerm()">+ Add Term</button>
          <button class="btn btn-secondary" onclick="toggleBatchPanel()" id="batchToggleBtn">Load Batch List</button>
        </div>

        <!-- Batch loader panel -->
        <div id="batchPanel" class="batch-panel" style="display:none;">
          <h3>Batch Term Loader</h3>
          <p style="font-size:13px;color:var(--gray);margin-bottom:10px;">
            Paste names (one per line) or load a .txt file. Names are auto-stripped to Hebrew consonants.
          </p>
          <div style="display:flex;gap:10px;margin-bottom:10px;flex-wrap:wrap;">
            <input type="file" id="batchFileInput" accept=".txt" onchange="loadBatchFile(this)" style="font-size:13px;">
            <button class="btn btn-small btn-secondary" onclick="clearBatchInput()">Clear</button>
          </div>
          <textarea id="batchTextarea" class="batch-textarea" placeholder="Enter terms, one per line...&#10;..."></textarea>
          <div style="display:flex;gap:10px;margin-top:10px;align-items:center;">
            <button class="btn" id="batchParseBtn" onclick="parseBatchInput()">Parse Terms</button>
            <span id="batchParseStatus" style="font-size:13px;color:var(--gray);"></span>
          </div>

          <!-- Parsed preview -->
          <div id="batchPreview" style="display:none;margin-top:15px;">
            <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
              <strong id="batchPreviewCount" style="color:var(--blue);"></strong>
              <div style="font-size:12px;color:var(--gray);" id="batchTimeEstimate"></div>
            </div>
            <div id="batchPreviewList" class="results-scrollable" style="max-height:200px;margin:10px 0;font-size:13px;border:1px solid var(--border);border-radius:4px;background:white;padding:8px;direction:rtl;"></div>
            <p style="font-size:13px;color:var(--green);margin-top:8px;">Click <strong>Search</strong> below to scan all parsed terms + any manual terms.</p>
          </div>

          <!-- Batch results table (populated during search) -->
          <div id="batchResults" style="display:none;margin-top:15px;">
            <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;margin-bottom:8px;">
              <strong style="color:var(--blue);">Batch Results</strong>
              <button class="btn btn-secondary btn-small" id="batchExportBtn" onclick="exportBatchResults()">Export CSV</button>
            </div>
            <div class="results-scrollable" style="max-height:500px;">
              <table class="batch-table" id="batchTable">
                <thead>
                  <tr>
                    <th onclick="sortBatchTable(0)">#</th>
                    <th onclick="sortBatchTable(1)">Original</th>
                    <th onclick="sortBatchTable(2)">Search Term</th>
                    <th onclick="sortBatchTable(3)">Letters</th>
                    <th onclick="sortBatchTable(4)">Hits</th>
                    <th onclick="sortBatchTable(5)">Best Skip</th>
                    <th class="batch-status-cell" onclick="sortBatchTable(6)">Status</th>
                  </tr>
                </thead>
                <tbody id="batchTableBody"></tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="save-panel">
          <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
            <input type="text" id="scanSessionName" placeholder="Session name..." style="flex: 1; min-width: 150px;">
            <button class="btn btn-success btn-small" onclick="saveScanSession()">Save</button>
            <button class="btn btn-secondary btn-small" onclick="exportScanResults()">Export JSON</button>
            <button class="btn btn-secondary btn-small" onclick="clearScanSession()">Clear</button>
          </div>
          <div id="savedScanSessions"></div>
        </div>

        <div class="range-row">
          <label>Skip range: <input type="number" id="minSkip" value="-500"> to <input type="number" id="maxSkip" value="500"></label>
          <span style="font-size: 12px; color: #666;">Skip 0 excluded, ±1 = open text</span>
        </div>

        <div class="action-row">
          <button class="btn" id="scanBtn" onclick="startScan()">Search</button>
          <button class="btn btn-danger" id="scanCancelBtn" onclick="cancelScan()" style="display:none;">Cancel</button>
          <span id="scanStatus" style="font-size: 13px; color: #666;"></span>
        </div>

        <div class="batch-progress" id="scanProgress" style="display:none;">
          <div class="batch-progress-bar" id="scanProgressBar" style="width:0%;">0%</div>
        </div>

        <div id="scanResults"></div>

        <!-- Inline Matrix View -->
        <div id="scanMatrixView" class="matrix-view" style="display:none;">
          <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
            <h3 id="scanMatrixTitle">Matrix View</h3>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="btn btn-small" id="btn3DToggle" onclick="toggle3DView()">3D View</button>
              <button class="btn-3d-ctrl" id="btn3DPause" onclick="toggle3DAutoRotate()" style="display:none;">Pause Rotation</button>
              <button class="btn-3d-ctrl" id="btn3DReset" onclick="reset3DCamera()" style="display:none;">Reset Camera</button>
              <button class="btn btn-small" onclick="downloadMatrixPNG()" style="background:#666;">Download PNG</button>
            </div>
          </div>
          <div id="scanMatrixStats" class="matrix-stats"></div>
          <div id="scanMatrix2D">
            <div class="matrix-container" style="max-height:400px;">
              <div class="matrix-grid" id="scanMatrixGrid"></div>
            </div>
          </div>
          <div id="scanMatrix3D" style="display:none;">
            <div class="matrix-3d-container" id="matrix3DCanvas">
              <div id="matrix3DTooltip"></div>
            </div>
            <div id="matrix3DInfo" style="display:none;"></div>
          </div>
          <div class="matrix-legend" id="scanMatrixLegend"></div>
        </div>
      </section>
    </div>

    <!-- DICTIONARY MODE -->
    <div id="dict-mode" class="mode-content">
      <div id="dictLoading" class="loading">
        <div class="spinner"></div>
        <div>Loading Dictionary...</div>
      </div>

      <div id="dictContent" style="display: none;">
        <section class="section">
          <h2>Dictionary Browser</h2>
          <div class="stats-grid" id="dictStats"></div>

          <div class="input-row">
            <input type="text" id="dictSearch" placeholder="Search word..." dir="rtl" style="flex: 1;">
            <select id="dictSource" style="padding: 10px; border-radius: 4px; border: 1px solid var(--border);">
              <option value="all">All Sources</option>
              <option value="bdb">BDB (Biblical)</option>
              <option value="strongs">Strong's</option>
              <option value="wiktionary">Wiktionary</option>
              <option value="tanakh">Tanakh</option>
              <option value="wikipedia">Wikipedia</option>
            </select>
            <button class="btn" onclick="searchDict()">Search</button>
          </div>

          <div class="action-row">
            <button class="btn btn-secondary" onclick="browseDict('random')">Random Words</button>
            <button class="btn btn-secondary" onclick="browseDict('frequent')">Common Words</button>
          </div>

          <div id="dictResults"></div>
        </section>
      </div>
    </div>
  </main>


  <div id="verseTooltip"></div>

  <script type="module">
    import { getElsIndexService, initElsIndex } from './engines/els-index.js';

    let elsService = null;
    let torahText = null;
    let currentResults = null;

    // ============= MODE SWITCHING =============
    document.querySelectorAll('.mode-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.mode + '-mode').classList.add('active');
      });
    });

    // ============= INIT =============
    async function init() {
      try {
        document.getElementById('loadProgress').textContent = 'Loading Torah text...';
        const resp = await fetch('data/torahNoSpaces.txt');
        torahText = await resp.text();

        document.getElementById('loadProgress').textContent = 'Loading ELS index (32MB)...';
        const metadata = await initElsIndex('data/els-index/els-index-50-min4.json.gz');
        elsService = getElsIndexService();

        document.getElementById('indexLoading').style.display = 'none';
        document.getElementById('indexContent').style.display = 'block';

        displayStats(metadata);
        loadSavedSessions();

      } catch (error) {
        console.error('Init failed:', error);
        document.getElementById('indexLoading').innerHTML =
          `<div style="color: red;">Error loading index: ${error.message}</div>`;
      }
    }

    function displayStats(meta) {
      document.getElementById('statsGrid').innerHTML = `
        <div class="stat-box"><div class="value">${meta.total_words?.toLocaleString() || '?'}</div><div class="label">Words</div></div>
        <div class="stat-box"><div class="value">${meta.total_occurrences?.toLocaleString() || '?'}</div><div class="label">Occurrences</div></div>
        <div class="stat-box"><div class="value">±${meta.skip_range?.[1] || '?'}</div><div class="label">Skip Range</div></div>
        <div class="stat-box"><div class="value">${meta.torah_length?.toLocaleString() || '?'}</div><div class="label">Letters</div></div>
      `;
    }

    // ============= INDEX MODE: TERM MANAGEMENT =============
    window.addTerm = function() {
      const container = document.getElementById('termEntries');
      const n = container.querySelectorAll('.term-entry').length + 1;
      const div = document.createElement('div');
      div.className = 'term-entry';
      div.innerHTML = `<input type="text" class="term-input" placeholder="Term ${n}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
      container.appendChild(div);
    };

    window.removeTerm = function(btn) {
      const container = document.getElementById('termEntries');
      if (container.querySelectorAll('.term-entry').length > 1) {
        btn.parentElement.remove();
      }
    };

    // ============= INDEX MODE: SEARCH =============
    window.searchIndex = function() {
      const inputs = document.querySelectorAll('.term-input');
      const terms = Array.from(inputs).map(i => i.value.trim()).filter(t => t);

      if (terms.length < 1) { alert('Enter at least one term'); return; }

      const termData = {};
      for (const term of terms) {
        const occs = elsService.findWord(term);
        termData[term] = { occurrences: occs, count: occs.length };
      }

      // Compute proximity pairs if multiple terms
      const proximityPairs = [];
      if (terms.length > 1) {
        for (let i = 0; i < terms.length; i++) {
          for (let j = i + 1; j < terms.length; j++) {
            const prox = elsService.pairProximity(terms[i], terms[j]);
            if (prox) {
              proximityPairs.push({
                term1: terms[i], term2: terms[j],
                distance: prox.distance,
                pos1: prox.word1.pos, skip1: prox.word1.skip,
                pos2: prox.word2.pos, skip2: prox.word2.skip
              });
            }
          }
        }
        proximityPairs.sort((a, b) => a.distance - b.distance);
      }

      currentResults = { terms, termData, proximityPairs, timestamp: new Date().toISOString() };
      displayIndexResults(currentResults);
    };

    function displayIndexResults(results) {
      const { terms, termData, proximityPairs } = results;

      let html = '<div class="results"><h3>Term Occurrences</h3>';
      html += '<table class="results-table"><tr><th>Term</th><th>Count</th><th>First Pos</th></tr>';
      for (const term of terms) {
        const d = termData[term];
        const firstPos = d.occurrences[0]?.pos ?? 'N/A';
        html += `<tr><td><strong>${term}</strong></td><td>${d.count.toLocaleString()}</td><td>${typeof firstPos === 'number' ? firstPos.toLocaleString() : firstPos}</td></tr>`;
      }
      html += '</table>';

      if (terms.length > 1) {
        // Proximity matrix
        const { matrix } = elsService.computeProximityMatrix(terms);
        html += '<h3 style="margin-top:20px;">Proximity Matrix</h3><div class="proximity-matrix"><table><tr><th></th>';
        terms.forEach(t => html += `<th>${t}</th>`);
        html += '</tr>';
        for (let i = 0; i < terms.length; i++) {
          html += `<tr><th>${terms[i]}</th>`;
          for (let j = 0; j < terms.length; j++) {
            const d = matrix[i][j];
            const cls = d === 0 ? '' : d < 500 ? 'cell-close' : d < 2000 ? 'cell-medium' : 'cell-far';
            html += `<td class="${cls}">${d === Infinity ? '∞' : d.toLocaleString()}</td>`;
          }
          html += '</tr>';
        }
        html += '</table></div>';

        // Pair details
        html += `<h3 style="margin-top:20px;">Proximity Pairs (${proximityPairs.length})</h3>`;
        html += '<div class="results-scrollable"><table class="results-table">';
        html += '<tr><th>#</th><th>Term 1</th><th>Term 2</th><th>Distance</th><th>Pos 1</th><th>Skip 1</th><th>Pos 2</th><th>Skip 2</th></tr>';
        proximityPairs.forEach((p, idx) => {
          const cls = p.distance < 500 ? 'cell-close' : p.distance < 2000 ? 'cell-medium' : 'cell-far';
          html += `<tr class="clickable-row" onclick="showIndexMatrix(${idx})" data-idx="${idx}">
            <td>${idx + 1}</td><td>${p.term1}</td><td>${p.term2}</td>
            <td class="${cls}">${p.distance.toLocaleString()}</td>
            <td>${p.pos1.toLocaleString()}</td><td>${p.skip1}</td>
            <td>${p.pos2.toLocaleString()}</td><td>${p.skip2}</td>
          </tr>`;
        });
        html += '</table></div>';

        // Matrix view area
        html += `<div id="indexMatrixView" class="matrix-view">
          <h3>Matrix View</h3>
          <p class="hint">Click a row above to view the matrix.</p>
          <div id="indexMatrixDisplay"></div>
        </div>`;
      }

      html += '</div>';
      document.getElementById('indexResults').innerHTML = html;
    }

    window.showIndexMatrix = function(idx) {
      if (!currentResults || !torahText) return;
      const pair = currentResults.proximityPairs[idx];
      if (!pair) return;

      document.querySelectorAll('.clickable-row').forEach(r => r.classList.remove('selected'));
      document.querySelector(`.clickable-row[data-idx="${idx}"]`)?.classList.add('selected');

      // Use skip value as width for proper alignment, or default to 30
      const width = Math.max(Math.abs(pair.skip1), Math.abs(pair.skip2), 30);

      const t1Pos = new Set();
      const t2Pos = new Set();
      for (let i = 0; i < pair.term1.length; i++) t1Pos.add(pair.pos1 + i * pair.skip1);
      for (let i = 0; i < pair.term2.length; i++) t2Pos.add(pair.pos2 + i * pair.skip2);

      // Compute row range from actual term positions (with context padding)
      const allTermPositions = [...t1Pos, ...t2Pos];
      const padding = 3;
      const startRow = Math.max(0, Math.floor(Math.min(...allTermPositions) / width) - padding);
      const endRow = Math.floor(Math.max(...allTermPositions) / width) + padding;

      // Build grid-based matrix like the popup
      let gridHtml = '';
      for (let row = startRow; row <= endRow; row++) {
        const rowStart = row * width;
        if (rowStart < 0) continue;
        for (let col = 0; col < width; col++) {
          const pos = rowStart + col;
          if (pos >= torahText.length) break;
          const ch = torahText[pos];
          const in1 = t1Pos.has(pos), in2 = t2Pos.has(pos);
          let cls = 'matrix-cell';
          if (in1 && in2) cls += ' term1 term2';
          else if (in1) cls += ' term1';
          else if (in2) cls += ' term2';
          gridHtml += `<div class="${cls}">${ch}</div>`;
        }
      }

      const statsHtml = `
        <div class="matrix-stats" style="margin-bottom:15px;">
          <div class="matrix-stat"><div class="value" style="color:#ffc107;">${pair.term1}</div><div class="label">Term 1</div></div>
          <div class="matrix-stat"><div class="value" style="color:#00bcd4;">${pair.term2}</div><div class="label">Term 2</div></div>
          <div class="matrix-stat"><div class="value">${pair.distance.toLocaleString()}</div><div class="label">Distance</div></div>
          <div class="matrix-stat"><div class="value">${pair.skip1}</div><div class="label">Skip 1</div></div>
          <div class="matrix-stat"><div class="value">${pair.skip2}</div><div class="label">Skip 2</div></div>
          <div class="matrix-stat"><div class="value">${pair.pos1.toLocaleString()}</div><div class="label">Pos 1</div></div>
          <div class="matrix-stat"><div class="value">${pair.pos2.toLocaleString()}</div><div class="label">Pos 2</div></div>
        </div>
        <div class="matrix-container" style="max-height:400px;">
          <div class="matrix-grid" style="grid-template-columns:repeat(${width}, 26px);">${gridHtml}</div>
        </div>
        <div class="matrix-legend" style="margin-top:15px;">
          <div class="legend-item"><div class="legend-color t1"></div><span>${pair.term1}</span></div>
          <div class="legend-item"><div class="legend-color t2"></div><span>${pair.term2}</span></div>
          <div class="legend-item"><div class="legend-color both"></div><span>Overlap</span></div>
        </div>
      `;

      document.getElementById('indexMatrixDisplay').innerHTML = statsHtml;

      // Set current3DHits for index mode (convert pair to hits format)
      current3DHits = [
        { pos: pair.pos1, skip: pair.skip1, term: pair.term1, termIdx: 0 },
        { pos: pair.pos2, skip: pair.skip2, term: pair.term2, termIdx: 1 }
      ];
    };

    // ============= INDEX MODE: SESSIONS =============
    window.saveSession = function() {
      if (!currentResults) { alert('No results to save'); return; }
      const name = document.getElementById('sessionName').value.trim() || `Search ${new Date().toLocaleTimeString()}`;
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      sessions.unshift({ name, results: currentResults, savedAt: new Date().toISOString() });
      if (sessions.length > 20) sessions.length = 20;
      localStorage.setItem('elsSearchSessions', JSON.stringify(sessions));
      loadSavedSessions();
      document.getElementById('sessionName').value = '';
    };

    window.loadSession = function(idx) {
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      if (!sessions[idx]) return;
      const session = sessions[idx];
      currentResults = session.results;
      const container = document.getElementById('termEntries');
      container.innerHTML = '';
      session.results.terms.forEach(term => {
        const div = document.createElement('div');
        div.className = 'term-entry';
        div.innerHTML = `<input type="text" class="term-input" value="${term}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
        container.appendChild(div);
      });
      displayIndexResults(currentResults);
    };

    window.deleteSession = function(idx) {
      if (!confirm('Delete session?')) return;
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      sessions.splice(idx, 1);
      localStorage.setItem('elsSearchSessions', JSON.stringify(sessions));
      loadSavedSessions();
    };

    function loadSavedSessions() {
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      const container = document.getElementById('savedSessions');
      if (sessions.length === 0) {
        container.innerHTML = '<p style="font-size: 12px; color: #666; margin-top: 10px;">No saved sessions</p>';
        return;
      }
      let html = '';
      sessions.forEach((s, i) => {
        html += `<div class="saved-item">
          <div><span class="name">${s.name}</span><br><span class="meta">${s.results.terms.join(', ')}</span></div>
          <div><button class="btn btn-small btn-secondary" onclick="loadSession(${i})">Load</button>
          <button class="btn btn-small btn-danger" onclick="deleteSession(${i})">×</button></div>
        </div>`;
      });
      container.innerHTML = html;
    }

    window.exportResults = function() {
      if (!currentResults) { alert('No results'); return; }
      const blob = new Blob([JSON.stringify(currentResults, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `els-search-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
    };

    window.clearSession = function() {
      if (!confirm('Clear all?')) return;
      document.getElementById('termEntries').innerHTML = `
        <div class="term-entry"><input type="text" class="term-input" placeholder="Term 1" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button></div>
        <div class="term-entry"><input type="text" class="term-input" placeholder="Term 2" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button></div>`;
      document.getElementById('indexResults').innerHTML = '';
      currentResults = null;
    };

    // ============= SCAN MODE =============
    const TERM_COLORS = ['#ffc107','#00bcd4','#ff5722','#4caf50','#e91e63','#3f51b5','#795548','#607d8b'];
    const BOOK_NAMES = {
      1:'Genesis',2:'Exodus',3:'Leviticus',4:'Numbers',5:'Deuteronomy',
      6:'Joshua',7:'Judges',8:'1 Samuel',9:'2 Samuel',10:'1 Kings',
      11:'2 Kings',12:'Isaiah',13:'Jeremiah',14:'Ezekiel',15:'Hosea',
      16:'Joel',17:'Amos',18:'Obadiah',19:'Jonah',20:'Micah',
      21:'Nahum',22:'Habakkuk',23:'Zephaniah',24:'Haggai',25:'Zechariah',
      26:'Malachi',27:'Psalms',28:'Proverbs',29:'Job',30:'Song of Songs',
      31:'Ruth',32:'Lamentations',33:'Ecclesiastes',34:'Esther',35:'Daniel',
      36:'Ezra',37:'Nehemiah',38:'1 Chronicles',39:'2 Chronicles'
    };
    const TORAH_BOOKS = ['genesis','exodus','leviticus','numbers','deuteronomy'];

    // --- Scan term management ---
    window.addScanTerm = function() {
      const container = document.getElementById('scanTermEntries');
      const n = container.querySelectorAll('.scan-term-entry').length;
      if (n >= 8) { alert('Maximum 8 terms'); return; }
      const div = document.createElement('div');
      div.className = 'scan-term-entry';
      div.innerHTML = `<div class="term-color-swatch" style="background:${TERM_COLORS[n % 8]};"></div>
        <input type="text" class="scan-term-input" placeholder="Term ${n + 1}" dir="rtl">
        <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>`;
      container.appendChild(div);
      updateScanTermColors();
    };

    window.removeScanTerm = function(btn) {
      const container = document.getElementById('scanTermEntries');
      if (container.querySelectorAll('.scan-term-entry').length > 1) {
        btn.parentElement.remove();
        updateScanTermColors();
      }
    };

    function updateScanTermColors() {
      const entries = document.querySelectorAll('.scan-term-entry');
      entries.forEach((entry, i) => {
        const swatch = entry.querySelector('.term-color-swatch');
        if (swatch) swatch.style.background = TERM_COLORS[i % 8];
        const input = entry.querySelector('input');
        if (input) input.placeholder = `Term ${i + 1}`;
      });
    }

    // --- Character database for verse attribution ---
    let charDatabase = null;

    async function loadCharDB() {
      if (charDatabase) return;
      try {
        const allChars = [];
        for (const book of TORAH_BOOKS) {
          const resp = await fetch(`data/${book}-chars.json.gz`);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const ds = new DecompressionStream('gzip');
          const text = await new Response(blob.stream().pipeThrough(ds)).text();
          allChars.push(...JSON.parse(text));
        }
        if (allChars.length > 0) charDatabase = allChars;
      } catch (e) {
        console.log('Character database not available:', e.message);
      }
    }

    function getVerseForPosition(pos) {
      if (!charDatabase || pos < 0 || pos >= charDatabase.length) return null;
      const ch = charDatabase[pos];
      if (!ch) return null;
      const bookName = BOOK_NAMES[ch.book] || `Book ${ch.book}`;
      return `${bookName} ${ch.chapter}:${ch.verse}`;
    }

    function getVersesForHit(pos, skip, termLen) {
      if (!charDatabase) return [];
      const seen = new Set();
      const verses = [];
      for (let i = 0; i < termLen; i++) {
        const p = pos + i * skip;
        const v = getVerseForPosition(p);
        if (v && !seen.has(v)) { seen.add(v); verses.push(v); }
      }
      return verses;
    }

    // --- Verse hover: text reconstruction + matrix highlight ---
    let verseTextCache = new Map();

    function getVerseKey(pos) {
      if (!charDatabase || pos < 0 || pos >= charDatabase.length) return null;
      const ch = charDatabase[pos];
      if (!ch) return null;
      return `${ch.book}:${ch.chapter}:${ch.verse}`;
    }

    function getVerseTextByKey(key) {
      if (verseTextCache.has(key)) return verseTextCache.get(key);
      if (!charDatabase) return null;
      const [bookStr, chapStr, verseStr] = key.split(':');
      const book = +bookStr, chap = +chapStr, verse = +verseStr;
      let text = '';
      let lastWordIdx = -1;
      for (let i = 0; i < charDatabase.length; i++) {
        const ch = charDatabase[i];
        if (ch.book === book && ch.chapter === chap && ch.verse === verse) {
          if (ch.word_index !== undefined && ch.word_index !== lastWordIdx && lastWordIdx !== -1) {
            text += ' ';
          }
          text += ch.base_char || torahText[i];
          if (ch.word_index !== undefined) lastWordIdx = ch.word_index;
        } else if (ch.book > book || (ch.book === book && ch.chapter > chap) ||
                   (ch.book === book && ch.chapter === chap && ch.verse > verse)) {
          break; // past our verse, stop early
        }
      }
      if (text) verseTextCache.set(key, text);
      return text || null;
    }

    // Positions of current hits by verse key: Map<verseKey, Set<pos>>
    let currentHitVerseMap = null;

    function buildHitVerseMap(hits) {
      currentHitVerseMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          const vk = getVerseKey(p);
          if (vk) {
            if (!currentHitVerseMap.has(vk)) currentHitVerseMap.set(vk, new Set());
            currentHitVerseMap.get(vk).add(p);
          }
        }
      }
    }

    window.onVerseHover = function(verseKey, verseLabel, event) {
      // 1. Show tooltip with verse text
      const tooltip = document.getElementById('verseTooltip');
      const text = getVerseTextByKey(verseKey);
      if (text) {
        tooltip.innerHTML = `<div class="verse-tooltip-ref">${verseLabel}</div>${text}`;
        tooltip.style.display = 'block';
        // Position near cursor
        const x = event.clientX, y = event.clientY;
        tooltip.style.left = Math.min(x + 15, window.innerWidth - 520) + 'px';
        tooltip.style.top = (y > window.innerHeight / 2 ? y - tooltip.offsetHeight - 10 : y + 20) + 'px';
      }

      // 2. Highlight matching cells in matrix
      if (currentHitVerseMap && currentHitVerseMap.has(verseKey)) {
        const positions = currentHitVerseMap.get(verseKey);
        const grid = document.getElementById('scanMatrixGrid');
        if (grid) {
          for (const cell of grid.children) {
            const pos = parseInt(cell.dataset.pos);
            if (positions.has(pos)) cell.classList.add('verse-glow');
          }
        }
      }
    };

    window.onVerseLeave = function() {
      document.getElementById('verseTooltip').style.display = 'none';
      const grid = document.getElementById('scanMatrixGrid');
      if (grid) {
        for (const cell of grid.children) cell.classList.remove('verse-glow');
      }
    };

    // Helper to create hoverable verse span HTML
    function makeVerseSpans(versesArray) {
      if (!versesArray || versesArray.length === 0) return '';
      return versesArray.map(v => {
        // Parse "BookName chapter:verse" to get key
        // We need to reverse-map: find a position with this verse label to get the key
        const verseKey = findVerseKeyByLabel(v);
        if (!verseKey) return v;
        const escaped = v.replace(/"/g, '&quot;');
        return `<span class="verse-ref-hover" onmouseenter="onVerseHover('${verseKey}','${escaped}',event)" onmouseleave="onVerseLeave()">${v}</span>`;
      }).join(', ');
    }

    function findVerseKeyByLabel(label) {
      // label is like "Genesis 1:1" — reverse lookup through BOOK_NAMES
      if (!charDatabase) return null;
      for (const [num, name] of Object.entries(BOOK_NAMES)) {
        if (label.startsWith(name + ' ')) {
          const ref = label.substring(name.length + 1);
          const [chap, verse] = ref.split(':').map(Number);
          if (chap && verse) return `${num}:${chap}:${verse}`;
        }
      }
      return null;
    }

    // --- ELS search ---
    function findELS(text, term, skip) {
      const results = [];
      const len = text.length;
      const termLen = term.length;

      if (skip === 1) {
        // Optimized forward open-text search using indexOf
        let idx = 0;
        while ((idx = text.indexOf(term, idx)) !== -1) {
          results.push(idx);
          idx++;
        }
      } else {
        // General ELS search for all other skip values (including negative)
        for (let start = 0; start < len; start++) {
          let match = true;
          for (let i = 0; i < termLen; i++) {
            const pos = start + i * skip;
            if (pos < 0 || pos >= len || text[pos] !== term[i]) { match = false; break; }
          }
          if (match) results.push(start);
        }
      }
      return results;
    }

    // --- N-term scan ---
    let scanAbort = false;
    let scanAllResults = {};  // { term: [{pos, skip}, ...] }
    let scanTerms = [];
    let scanClusters = [];

    window.cancelScan = function() { scanAbort = true; batchAbort = true; };

    window.startScan = async function() {
      if (!torahText) {
        const resp = await fetch('data/torahNoSpaces.txt');
        torahText = await resp.text();
      }

      // Merge manual terms + batch terms
      const inputs = document.querySelectorAll('.scan-term-input');
      const manualTerms = Array.from(inputs).map(i => i.value.trim()).filter(t => t);
      const batchCleaned = batchTerms.filter(t => t.cleaned.length >= 2).map(t => t.cleaned);

      const seen = new Set();
      const terms = [];
      for (const t of [...manualTerms, ...batchCleaned]) {
        if (!seen.has(t) && t.length >= 2) { seen.add(t); terms.push(t); }
      }
      if (terms.length < 1) { alert('Enter at least one term or load a batch list'); return; }

      const minSkip = parseInt(document.getElementById('minSkip').value) || -500;
      const maxSkip = parseInt(document.getElementById('maxSkip').value) || 500;

      const btn = document.getElementById('scanBtn');
      const cancelBtn = document.getElementById('scanCancelBtn');
      const status = document.getElementById('scanStatus');
      const progressDiv = document.getElementById('scanProgress');
      const progressBar = document.getElementById('scanProgressBar');
      btn.disabled = true;
      btn.textContent = 'Scanning...';
      cancelBtn.style.display = '';
      progressDiv.style.display = '';
      progressBar.style.width = '0%';
      progressBar.textContent = '0%';
      scanAbort = false;

      // Load character database for verse attribution
      status.textContent = 'Loading verse database...';
      await loadCharDB();

      scanAllResults = {};
      scanTerms = terms;
      for (const term of terms) scanAllResults[term] = [];

      // Reset batch term statuses if batch is active
      const hasBatch = batchTerms.length > 0;
      if (hasBatch) {
        for (const t of batchTerms) { t.hits = 0; t.bestSkip = null; t.bestPos = null; t.status = 'pending'; }
        batchAllResults = {};
        document.getElementById('batchResults').style.display = '';
        renderBatchTable();
      }

      const totalTerms = terms.length;
      const startTime = performance.now();

      // Scan per-term (better progress for large batches)
      for (let ti = 0; ti < totalTerms; ti++) {
        if (scanAbort) break;

        const term = terms[ti];
        const results = [];

        for (let skip = minSkip; skip <= maxSkip; skip++) {
          if (scanAbort) break;
          if (skip === 0) continue;
          const found = findELS(torahText, term, skip);
          for (const pos of found) results.push({ pos, skip });
        }

        scanAllResults[term] = results;

        // Update batch table row if this term came from batch
        if (hasBatch) {
          const bt = batchTerms.find(b => b.cleaned === term);
          if (bt) {
            batchAllResults[term] = results;
            bt.hits = results.length;
            if (results.length > 0) {
              const sorted = [...results].sort((a, b) => Math.abs(a.skip) - Math.abs(b.skip));
              bt.bestSkip = sorted[0].skip;
              bt.bestPos = sorted[0].pos;
            }
            bt.status = 'done';
            const btIdx = batchTerms.indexOf(bt);
            updateBatchRow(btIdx);
          }
        }

        // Progress
        const pct = Math.round(((ti + 1) / totalTerms) * 100);
        progressBar.style.width = pct + '%';
        progressBar.textContent = pct + '%';

        const elapsed = (performance.now() - startTime) / 1000;
        const perTerm = elapsed / (ti + 1);
        const remaining = Math.round(perTerm * (totalTerms - ti - 1));
        const remMin = Math.floor(remaining / 60);
        const remSec = remaining % 60;
        status.textContent = `Term ${ti + 1}/${totalTerms}: "${term}" — ${results.length} hits` +
          (remaining > 0 ? ` | ~${remMin}m ${remSec}s remaining` : '');

        await new Promise(r => setTimeout(r, 0));
      }

      btn.disabled = false;
      btn.textContent = 'Search';
      cancelBtn.style.display = 'none';
      progressDiv.style.display = 'none';

      const totalTime = Math.round((performance.now() - startTime) / 1000);
      const totalHits = Object.values(scanAllResults).reduce((s, r) => s + r.length, 0);
      status.textContent = scanAbort
        ? 'Cancelled.'
        : `Done! ${totalTerms} terms, ${totalHits.toLocaleString()} hits in ${Math.floor(totalTime/60)}m ${totalTime%60}s`;

      // Auto-cluster all terms with hits (if 2+)
      scanClusters = [];
      const termsWithHits = terms.filter(t => scanAllResults[t].length > 0);
      if (termsWithHits.length >= 2) {
        status.textContent += ' — Finding clusters...';
        await new Promise(r => setTimeout(r, 0));
        scanClusters = findClusters(termsWithHits, scanAllResults, 10000);
        // Update scanTerms to only include terms with hits for display
        scanTerms = termsWithHits;
      }

      displayScanResults(scanTerms, scanAllResults, scanClusters);

      if (hasBatch) {
        batchTerms.forEach((t, i) => t._origIdx = i);
        renderBatchTable();
      }
    };

    // --- Sliding window cluster finder ---
    function findClusters(terms, allResults, maxSpan) {
      // Merge all hits tagged by term index
      const merged = [];
      terms.forEach((term, idx) => {
        for (const hit of allResults[term]) {
          merged.push({ pos: hit.pos, skip: hit.skip, termIdx: idx, term });
        }
      });
      if (merged.length === 0) return [];

      merged.sort((a, b) => a.pos - b.pos);

      const clusters = [];
      const termCount = terms.length;
      // Count of each term in current window
      const counts = new Array(termCount).fill(0);
      let presentTerms = 0;
      let left = 0;

      for (let right = 0; right < merged.length; right++) {
        const rHit = merged[right];
        if (counts[rHit.termIdx] === 0) presentTerms++;
        counts[rHit.termIdx]++;

        // Shrink window from left while all terms still present
        while (presentTerms === termCount) {
          const span = merged[right].pos - merged[left].pos;
          if (span <= maxSpan) {
            // Record cluster: pick one hit per term (closest to center)
            const centerPos = (merged[left].pos + merged[right].pos) / 2;
            const hits = [];
            for (let t = 0; t < termCount; t++) {
              // Find best hit for this term in window
              let best = null, bestDist = Infinity;
              for (let k = left; k <= right; k++) {
                if (merged[k].termIdx === t) {
                  const d = Math.abs(merged[k].pos - centerPos);
                  if (d < bestDist) { bestDist = d; best = merged[k]; }
                }
              }
              if (best) hits.push({ ...best });
            }
            clusters.push({ span, hits, minPos: merged[left].pos, maxPos: merged[right].pos });
          }

          const lHit = merged[left];
          counts[lHit.termIdx]--;
          if (counts[lHit.termIdx] === 0) presentTerms--;
          left++;
        }
      }

      // Sort by span ascending
      clusters.sort((a, b) => a.span - b.span);

      // Deduplicate overlapping clusters (keep smallest span variant)
      const deduped = [];
      const usedKeys = new Set();
      for (const c of clusters) {
        // Key = sorted positions of chosen hits
        const key = c.hits.map(h => `${h.termIdx}:${h.pos}:${h.skip}`).sort().join('|');
        if (!usedKeys.has(key)) {
          usedKeys.add(key);
          deduped.push(c);
          if (deduped.length >= 200) break;
        }
      }

      return deduped;
    }

    // --- Display scan results ---
    function displayScanResults(terms, allResults, clusters) {
      let html = '<div class="results">';

      // Clusters section (2+ terms)
      if (terms.length >= 2 && clusters.length > 0) {
        html += `<div style="background:#fff3e0;padding:16px;border-radius:8px;border-right:4px solid #ff9800;margin-bottom:20px;">`;
        html += `<h3 style="color:#e65100;margin-bottom:12px;">Clusters (${clusters.length}) — sorted by smallest region</h3>`;
        html += `<p style="font-size:13px;color:#666;margin-bottom:12px;">Click to view matrix with all terms</p>`;
        html += '<div class="results-scrollable" style="max-height:500px;">';
        clusters.forEach((c, idx) => {
          html += `<div class="cluster-row" onclick="showClusterMatrix(${idx})">`;
          html += `<div><span class="cluster-span">${c.span.toLocaleString()} chars</span></div>`;
          html += `<div class="cluster-terms">`;
          c.hits.forEach(h => {
            const color = TERM_COLORS[h.termIdx % 8];
            const verses = getVersesForHit(h.pos, h.skip, h.term.length);
            const verseStr = verses.length > 0 ? ` [${verses.join(', ')}]` : '';
            html += `<span class="cluster-term-tag" style="background:${color}20;border-color:${color};color:#333;">
              "${h.term}" pos:${h.pos.toLocaleString()} skip:${h.skip}${verseStr}
            </span>`;
          });
          html += `</div></div>`;
        });
        html += '</div></div>';
      } else if (terms.length >= 2) {
        html += `<div style="background:#fff3e0;padding:16px;border-radius:8px;border-right:4px solid #ff9800;margin-bottom:20px;">`;
        html += `<h3 style="color:#e65100;margin-bottom:12px;">Clusters</h3>`;
        html += `<p>No clusters found — some terms may have no results.</p></div>`;
      }

      // Individual term results
      terms.forEach((term, tIdx) => {
        const results = allResults[term];
        const color = TERM_COLORS[tIdx % 8];
        html += `<h3 style="margin-top:20px;border-right:4px solid ${color};padding-right:10px;">${term}: ${results.length.toLocaleString()} occurrences</h3>`;
        if (results.length > 0) {
          html += '<div class="results-scrollable" style="max-height:300px;">';
          results.forEach((r, i) => {
            const verses = getVersesForHit(r.pos, r.skip, term.length);
            const verseStr = verses.length > 0 ? `<span style="color:#888;font-size:12px;"> — ${verses.join(', ')}</span>` : '';
            html += `<div class="result-item" onclick="showSingleTermMatrix(${tIdx}, ${i})">
              <span class="term" style="color:${color};">${term}</span>
              <span class="info">Position: ${r.pos.toLocaleString()} | Skip: ${r.skip}${verseStr}</span>
            </div>`;
          });
          html += '</div>';
        }
      });

      html += '</div>';
      document.getElementById('scanResults').innerHTML = html;
    }

    // --- Show cluster matrix ---
    window.showClusterMatrix = function(idx) {
      const cluster = scanClusters[idx];
      if (!cluster || !torahText) return;

      const view = document.getElementById('scanMatrixView');
      view.style.display = 'block';
      document.getElementById('scanMatrixTitle').textContent =
        `Cluster — ${cluster.hits.map(h => `"${h.term}"`).join(' + ')}`;

      // Stats
      let statsHtml = `<div class="matrix-stat"><div class="value">${cluster.span.toLocaleString()}</div><div class="label">Span</div></div>`;
      cluster.hits.forEach(h => {
        const color = TERM_COLORS[h.termIdx % 8];
        statsHtml += `<div class="matrix-stat">
          <div class="value" style="color:${color};">${h.term}</div>
          <div class="label">pos ${h.pos.toLocaleString()} skip ${h.skip}</div>
        </div>`;
      });
      document.getElementById('scanMatrixStats').innerHTML = statsHtml;

      // Legend with hoverable verse references
      buildHitVerseMap(cluster.hits);
      let legendHtml = '';
      cluster.hits.forEach(h => {
        const color = TERM_COLORS[h.termIdx % 8];
        const verses = getVersesForHit(h.pos, h.skip, h.term.length);
        const verseSpans = makeVerseSpans(verses);
        const verseStr = verseSpans ? ` (${verseSpans})` : '';
        legendHtml += `<div class="legend-item"><div class="legend-color" style="background:${color};"></div><span>${h.term}${verseStr}</span></div>`;
      });
      if (cluster.hits.length > 1) {
        legendHtml += `<div class="legend-item"><div class="legend-color" style="background:#9c27b0;"></div><span>Overlap</span></div>`;
      }
      document.getElementById('scanMatrixLegend').innerHTML = legendHtml;

      current3DHits = cluster.hits;
      renderScanMatrix(cluster.hits);

      if (is3DActive && THREE) {
        const { W, H } = findOptimalDimensions(current3DHits);
        render3DMatrix(current3DHits, W, H);
      }

      view.scrollIntoView({ behavior: 'smooth' });
    };

    // --- Show single term matrix ---
    window.showSingleTermMatrix = function(termIdx, resultIdx) {
      const term = scanTerms[termIdx];
      const results = scanAllResults[term];
      if (!results || !results[resultIdx] || !torahText) return;

      const r = results[resultIdx];
      const hit = { pos: r.pos, skip: r.skip, term, termIdx };

      const view = document.getElementById('scanMatrixView');
      view.style.display = 'block';
      document.getElementById('scanMatrixTitle').textContent = `"${term}"`;

      const color = TERM_COLORS[termIdx % 8];
      const verses = getVersesForHit(r.pos, r.skip, term.length);

      document.getElementById('scanMatrixStats').innerHTML = `
        <div class="matrix-stat"><div class="value" style="color:${color};">${term}</div><div class="label">Term</div></div>
        <div class="matrix-stat"><div class="value">${r.pos.toLocaleString()}</div><div class="label">Position</div></div>
        <div class="matrix-stat"><div class="value">${r.skip}</div><div class="label">Skip</div></div>
      `;

      // Legend with hoverable verse references
      buildHitVerseMap([hit]);
      const verseSpans = makeVerseSpans(verses);
      const verseStr = verseSpans ? ` — ${verseSpans}` : '';
      document.getElementById('scanMatrixLegend').innerHTML = `
        <div class="legend-item"><div class="legend-color" style="background:${color};"></div><span>${term}${verseStr}</span></div>
      `;

      current3DHits = [hit];
      renderScanMatrix([hit]);

      if (is3DActive && THREE) {
        const { W, H } = findOptimalDimensions(current3DHits);
        render3DMatrix(current3DHits, W, H);
      }

      view.scrollIntoView({ behavior: 'smooth' });
    };

    // --- Render N-term matrix ---
    function renderScanMatrix(hits) {
      // Determine grid width from max |skip|
      const width = Math.max(...hits.map(h => Math.abs(h.skip)), 30);

      // Center on cluster midpoint
      const allPositions = [];
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) allPositions.push(h.pos + i * h.skip);
      }
      const minPos = Math.min(...allPositions);
      const maxPos = Math.max(...allPositions);

      // Compute row range from actual term positions (with context padding)
      const padding = 3;
      const startRow = Math.max(0, Math.floor(minPos / width) - padding);
      const endRow = Math.floor(maxPos / width) + padding;

      // Build posMap: position -> Set of termIdx
      const posMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          if (!posMap.has(p)) posMap.set(p, new Set());
          posMap.get(p).add(h.termIdx);
        }
      }

      let html = '';
      for (let row = startRow; row <= endRow; row++) {
        const rowStart = row * width;
        if (rowStart < 0) continue;
        for (let col = 0; col < width; col++) {
          const pos = rowStart + col;
          if (pos >= torahText.length) break;
          const ch = torahText[pos];
          const termSet = posMap.get(pos);
          let cls = 'matrix-cell';
          let tooltip = '';

          if (termSet) {
            if (termSet.size > 1) {
              cls += ' multi-term';
            } else {
              const idx = termSet.values().next().value;
              cls += ` term-color-${idx % 8}`;
            }
            // Tooltip with verse reference
            const verse = getVerseForPosition(pos);
            const termNames = [...termSet].map(t => scanTerms[t]).join(', ');
            tooltip = verse ? `${termNames} — ${verse}` : termNames;
          }

          html += `<div class="${cls}" data-pos="${pos}"${tooltip ? ` title="${tooltip}"` : ''}>${ch}</div>`;
        }
      }

      const grid = document.getElementById('scanMatrixGrid');
      grid.style.gridTemplateColumns = `repeat(${width}, 26px)`;
      grid.innerHTML = html;
    }

    // ============= BATCH TERM LOADER =============
    let batchTerms = [];       // [{original, cleaned, hits, bestSkip, bestPos, status}]
    let batchAllResults = {};  // cleaned term -> [{pos, skip}]
    let batchAbort = false;

    window.toggleBatchPanel = function() {
      const panel = document.getElementById('batchPanel');
      const btn = document.getElementById('batchToggleBtn');
      if (panel.style.display === 'none') {
        panel.style.display = '';
        btn.textContent = 'Hide Batch';
      } else {
        panel.style.display = 'none';
        btn.textContent = 'Load Batch List';
      }
    };

    window.loadBatchFile = function(input) {
      const file = input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        document.getElementById('batchTextarea').value = e.target.result;
        document.getElementById('batchParseStatus').textContent = `Loaded: ${file.name}`;
      };
      reader.readAsText(file);
    };

    window.clearBatchInput = function() {
      document.getElementById('batchTextarea').value = '';
      document.getElementById('batchParseStatus').textContent = '';
      document.getElementById('batchPreview').style.display = 'none';
      document.getElementById('batchResults').style.display = 'none';
      batchTerms = [];
      batchAllResults = {};
    };

    // Strip name to consonantal Hebrew only
    function cleanHebrewName(name) {
      // Remove parenthetical content: (אדריאן), (אלכסנדר), (ג'ימי), (נטלי)
      let s = name.replace(/\([^)]*\)/g, '');
      // Remove military ranks and honorifics
      s = s.replace(/\b(אל"ם|סמ"ר|סא"ל|רס"ן|סגן|סרן|רב"ט|טור'|רס"ר|רנ"ג|רב סמל|סמל|טוראי)\s*/g, '');
      // Remove הי"ד (memorial suffix)
      s = s.replace(/הי"ד/g, '');
      // Remove quotation marks and double-quotes within abbreviations
      s = s.replace(/["״׳']/g, '');
      // Keep only Hebrew letters (strip spaces, punctuation, Latin chars, digits)
      s = s.replace(/[^\u05D0-\u05EA]/g, '');
      return s;
    }

    window.parseBatchInput = function() {
      const text = document.getElementById('batchTextarea').value.trim();
      if (!text) { alert('Paste or load names first'); return; }

      const lines = text.split('\n').map(l => l.trim()).filter(l => l);
      batchTerms = [];
      const seen = new Set();

      for (const line of lines) {
        const cleaned = cleanHebrewName(line);
        if (cleaned.length < 2) continue;    // skip single-letter or empty
        if (seen.has(cleaned)) continue;      // deduplicate
        seen.add(cleaned);
        batchTerms.push({
          original: line,
          cleaned,
          hits: 0,
          bestSkip: null,
          bestPos: null,
          status: 'pending'
        });
      }

      if (batchTerms.length === 0) { alert('No valid terms found'); return; }

      // Show preview
      const preview = document.getElementById('batchPreview');
      preview.style.display = '';
      document.getElementById('batchPreviewCount').textContent = `${batchTerms.length} terms parsed`;

      // Time estimate
      const skipRange = Math.abs(parseInt(document.getElementById('maxSkip').value) || 100) -
                         (parseInt(document.getElementById('minSkip').value) || -100) + 1;
      const estSec = Math.round(batchTerms.length * (skipRange / 200) * 4);
      const estMin = Math.floor(estSec / 60);
      const estRemSec = estSec % 60;
      document.getElementById('batchTimeEstimate').textContent =
        `Est. ~${estMin}m ${estRemSec}s (${skipRange} skip values)`;

      // Preview list
      let previewHtml = batchTerms.map((t, i) =>
        `<div style="display:inline-block;padding:3px 8px;margin:2px;background:#e3ecf7;border-radius:3px;font-size:12px;">
          <strong>${t.cleaned}</strong> <span style="color:#999;">← ${t.original}</span>
        </div>`
      ).join('');
      document.getElementById('batchPreviewList').innerHTML = previewHtml;
      document.getElementById('batchParseStatus').textContent = `${batchTerms.length} terms ready`;

      // Reset results
      document.getElementById('batchResults').style.display = 'none';
      document.getElementById('batchExportBtn').style.display = 'none';
      batchAllResults = {};
    };

    function renderBatchTable() {
      const tbody = document.getElementById('batchTableBody');
      let html = '';
      batchTerms.forEach((t, i) => {
        const statusCls = t.status === 'done' ? 'batch-status-done' :
                          t.status === 'scanning' ? 'batch-status-active' : 'batch-status-pending';
        const statusText = t.status === 'done' ? 'Done' :
                           t.status === 'scanning' ? 'Scanning...' : 'Pending';
        html += `<tr data-batch-idx="${i}">
          <td>${i + 1}</td>
          <td>${t.original}</td>
          <td style="direction:rtl;font-weight:bold;">${t.cleaned}</td>
          <td>${t.cleaned.length}</td>
          <td>${t.status === 'done' ? t.hits.toLocaleString() : '—'}</td>
          <td>${t.bestSkip !== null ? t.bestSkip : '—'}</td>
          <td class="batch-status-cell ${statusCls}">${statusText}</td>
        </tr>`;
      });
      tbody.innerHTML = html;
    }

    function updateBatchRow(idx) {
      const row = document.querySelector(`tr[data-batch-idx="${idx}"]`);
      if (!row) { renderBatchTable(); return; }
      const t = batchTerms[idx];
      const statusCls = t.status === 'done' ? 'batch-status-done' :
                        t.status === 'scanning' ? 'batch-status-active' : 'batch-status-pending';
      const statusText = t.status === 'done' ? 'Done' :
                         t.status === 'scanning' ? 'Scanning...' : 'Pending';
      row.cells[4].textContent = t.status === 'done' ? t.hits.toLocaleString() : '—';
      row.cells[5].textContent = t.bestSkip !== null ? t.bestSkip : '—';
      row.cells[6].className = 'batch-status-cell ' + statusCls;
      row.cells[6].textContent = statusText;
    }

    window.exportBatchResults = function() {
      if (batchTerms.length === 0) return;
      // CSV export
      let csv = 'Index,Original Name,Search Term,Letters,Hits,Best Skip,Best Position\n';
      batchTerms.forEach((t, i) => {
        csv += `${i+1},"${t.original}","${t.cleaned}",${t.cleaned.length},${t.hits},${t.bestSkip || ''},${t.bestPos || ''}\n`;
      });
      const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `batch-els-results-${new Date().toISOString().slice(0,10)}.csv`;
      a.click();
    };

    let batchSortCol = -1, batchSortAsc = true;
    window.sortBatchTable = function(col) {
      if (batchSortCol === col) { batchSortAsc = !batchSortAsc; }
      else { batchSortCol = col; batchSortAsc = true; }

      const getVal = (t, c) => {
        switch(c) {
          case 0: return batchTerms.indexOf(t);
          case 1: return t.original;
          case 2: return t.cleaned;
          case 3: return t.cleaned.length;
          case 4: return t.hits;
          case 5: return t.bestSkip || 0;
          case 6: return t.status === 'done' ? 2 : t.status === 'scanning' ? 1 : 0;
          default: return 0;
        }
      };

      batchTerms.sort((a, b) => {
        let va = getVal(a, col), vb = getVal(b, col);
        if (typeof va === 'string') return batchSortAsc ? va.localeCompare(vb) : vb.localeCompare(va);
        return batchSortAsc ? va - vb : vb - va;
      });
      renderBatchTable();
    };

    // ============= SCAN MODE: SAVE/LOAD SESSIONS =============
    window.saveScanSession = function() {
      if (scanTerms.length === 0) { alert('No scan results to save'); return; }
      const name = document.getElementById('scanSessionName').value.trim() || `Scan ${new Date().toLocaleTimeString()}`;
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      sessions.unshift({
        name,
        terms: scanTerms,
        allResults: scanAllResults,
        clusters: scanClusters,
        savedAt: new Date().toISOString()
      });
      if (sessions.length > 20) sessions.length = 20;
      localStorage.setItem('elsScanSessions', JSON.stringify(sessions));
      loadSavedScanSessions();
      document.getElementById('scanSessionName').value = '';
    };

    window.loadScanSession = function(idx) {
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      if (!sessions[idx]) return;
      const s = sessions[idx];
      scanTerms = s.terms;
      scanAllResults = s.allResults;
      scanClusters = s.clusters || [];

      // Restore term inputs
      const container = document.getElementById('scanTermEntries');
      container.innerHTML = '';
      s.terms.forEach((term, i) => {
        const div = document.createElement('div');
        div.className = 'scan-term-entry';
        div.innerHTML = `<div class="term-color-swatch" style="background:${TERM_COLORS[i % 8]};"></div>
          <input type="text" class="scan-term-input" value="${term}" dir="rtl">
          <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>`;
        container.appendChild(div);
      });

      // Load char DB for verse attribution then display
      loadCharDB().then(() => {
        displayScanResults(scanTerms, scanAllResults, scanClusters);
      });
    };

    window.deleteScanSession = function(idx) {
      if (!confirm('Delete session?')) return;
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      sessions.splice(idx, 1);
      localStorage.setItem('elsScanSessions', JSON.stringify(sessions));
      loadSavedScanSessions();
    };

    function loadSavedScanSessions() {
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      const container = document.getElementById('savedScanSessions');
      if (!container) return;
      if (sessions.length === 0) {
        container.innerHTML = '<p style="font-size: 12px; color: #666; margin-top: 10px;">No saved scan sessions</p>';
        return;
      }
      let html = '';
      sessions.forEach((s, i) => {
        html += `<div class="saved-item">
          <div><span class="name">${s.name}</span><br><span class="meta">${s.terms.join(', ')}</span></div>
          <div><button class="btn btn-small btn-secondary" onclick="loadScanSession(${i})">Load</button>
          <button class="btn btn-small btn-danger" onclick="deleteScanSession(${i})">×</button></div>
        </div>`;
      });
      container.innerHTML = html;
    }

    window.exportScanResults = function() {
      if (scanTerms.length === 0) { alert('No results to export'); return; }
      const data = { terms: scanTerms, allResults: scanAllResults, clusters: scanClusters, timestamp: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `els-scan-${scanTerms.join('-')}-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
    };

    window.clearScanSession = function() {
      if (!confirm('Clear all terms and results?')) return;
      const container = document.getElementById('scanTermEntries');
      container.innerHTML = `
        <div class="scan-term-entry">
          <div class="term-color-swatch" style="background:#ffc107;"></div>
          <input type="text" class="scan-term-input" placeholder="Term 1" dir="rtl">
          <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>
        </div>
        <div class="scan-term-entry">
          <div class="term-color-swatch" style="background:#00bcd4;"></div>
          <input type="text" class="scan-term-input" placeholder="Term 2" dir="rtl">
          <button class="remove-btn" onclick="removeScanTerm(this)">&times;</button>
        </div>`;
      document.getElementById('scanResults').innerHTML = '';
      document.getElementById('scanMatrixView').style.display = 'none';
      scanTerms = [];
      scanAllResults = {};
      scanClusters = [];
      current3DHits = null;
      is3DActive = false;
      destroy3DScene();
      // Reset 3D toggle button state
      const btn3d = document.getElementById('btn3DToggle');
      if (btn3d) { btn3d.textContent = '3D View'; btn3d.classList.remove('active'); }
      document.getElementById('scanMatrix2D').style.display = '';
      document.getElementById('scanMatrix3D').style.display = 'none';
      document.getElementById('btn3DPause').style.display = 'none';
      document.getElementById('btn3DReset').style.display = 'none';
    };

    // Load saved scan sessions on init
    loadSavedScanSessions();

    // ============= SCAN MODE: PDF EXPORT =============
    window.downloadMatrixPNG = function() {
      const matrixView = document.getElementById('scanMatrixView');
      if (!matrixView || matrixView.style.display === 'none') { alert('No matrix displayed'); return; }

      // Use canvas rendering approach
      const grid = document.getElementById('scanMatrixGrid');
      const cells = grid.querySelectorAll('.matrix-cell');
      if (cells.length === 0) return;

      const title = document.getElementById('scanMatrixTitle').textContent;
      const cols = parseInt(grid.style.gridTemplateColumns.match(/repeat\((\d+)/)?.[1] || '30');
      const rows = Math.ceil(cells.length / cols);
      const cellSize = 22;
      const padding = 40;
      const headerHeight = 80;

      const canvas = document.createElement('canvas');
      canvas.width = cols * cellSize + padding * 2;
      canvas.height = rows * cellSize + padding * 2 + headerHeight;
      const ctx = canvas.getContext('2d');

      // Background
      ctx.fillStyle = '#1a1a28';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Title
      ctx.fillStyle = '#8bb8e8';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(title, canvas.width / 2, 30);

      // Stats/legend text
      const legend = document.getElementById('scanMatrixLegend');
      ctx.font = '12px sans-serif';
      ctx.fillStyle = '#ccc';
      ctx.fillText(legend?.textContent?.trim() || '', canvas.width / 2, 55);

      // Color map
      const colorMap = {
        'term-color-0': '#ffc107', 'term-color-1': '#00bcd4', 'term-color-2': '#ff5722',
        'term-color-3': '#4caf50', 'term-color-4': '#e91e63', 'term-color-5': '#3f51b5',
        'term-color-6': '#795548', 'term-color-7': '#607d8b', 'multi-term': '#9c27b0'
      };

      // Draw cells
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      cells.forEach((cell, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = padding + col * cellSize;
        const y = headerHeight + padding + row * cellSize;

        // Determine cell color
        let bg = '#2d2d44';
        let fg = '#e0e0e0';
        for (const [cls, color] of Object.entries(colorMap)) {
          if (cell.classList.contains(cls)) {
            bg = color;
            fg = cls === 'term-color-0' || cls === 'term-color-1' ? '#000' : '#fff';
            break;
          }
        }

        ctx.fillStyle = bg;
        ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
        ctx.fillStyle = fg;
        ctx.fillText(cell.textContent, x + cellSize / 2, y + cellSize / 2);
      });

      // Download as PNG (simpler, universally supported, better quality than canvas-to-PDF)
      const link = document.createElement('a');
      link.download = `els-matrix-${title.replace(/[^a-zA-Z0-9א-ת]/g, '-')}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    };

    // ============= DICTIONARY MODE =============
    let dictData = null;
    let dictLoaded = false;

    async function loadDict() {
      if (dictLoaded) return;
      try {
        const resp = await fetch('data/dictionaries/unified/hebrew-unified.json.gz');
        const blob = await resp.blob();
        const ds = new DecompressionStream('gzip');
        const text = await new Response(blob.stream().pipeThrough(ds)).text();
        dictData = JSON.parse(text);
        dictLoaded = true;

        document.getElementById('dictLoading').style.display = 'none';
        document.getElementById('dictContent').style.display = 'block';

        // Stats
        const entries = Object.keys(dictData).length;
        const sources = {};
        Object.values(dictData).forEach(entry => {
          const src = entry.source || 'unknown';
          sources[src] = (sources[src] || 0) + 1;
        });
        document.getElementById('dictStats').innerHTML = `
          <div class="stat-box"><div class="value">${entries.toLocaleString()}</div><div class="label">Total Entries</div></div>
          <div class="stat-box"><div class="value">${sources.bdb?.toLocaleString() || 0}</div><div class="label">BDB</div></div>
          <div class="stat-box"><div class="value">${sources.strongs?.toLocaleString() || 0}</div><div class="label">Strong's</div></div>
          <div class="stat-box"><div class="value">${sources.wiktionary?.toLocaleString() || 0}</div><div class="label">Wiktionary</div></div>
          <div class="stat-box"><div class="value">${sources.wikipedia?.toLocaleString() || 0}</div><div class="label">Wikipedia</div></div>
        `;
      } catch (err) {
        document.getElementById('dictLoading').innerHTML = `<div style="color:red;">Error: ${err.message}</div>`;
      }
    }

    // Load dict when switching to dict tab
    document.querySelectorAll('.mode-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        if (tab.dataset.mode === 'dict' && !dictLoaded) {
          loadDict();
        }
      });
    });

    window.searchDict = function() {
      if (!dictData) return;
      const query = document.getElementById('dictSearch').value.trim();
      const source = document.getElementById('dictSource').value;
      if (!query) { browseDict('random'); return; }

      const results = [];
      for (const [word, entry] of Object.entries(dictData)) {
        if (source !== 'all' && entry.source !== source) continue;
        if (word.includes(query)) {
          results.push({ word, ...entry });
          if (results.length >= 100) break;
        }
      }

      displayDictResults(results, `Search: "${query}"`);
    };

    window.browseDict = function(mode) {
      if (!dictData) return;
      const source = document.getElementById('dictSource').value;
      const words = Object.entries(dictData)
        .filter(([w, e]) => source === 'all' || e.source === source);

      let results;
      if (mode === 'random') {
        const shuffled = words.sort(() => Math.random() - 0.5);
        results = shuffled.slice(0, 50).map(([word, entry]) => ({ word, ...entry }));
      } else {
        // Sort by some metric - for now just alphabetical
        results = words.slice(0, 50).map(([word, entry]) => ({ word, ...entry }));
      }

      displayDictResults(results, mode === 'random' ? 'Random Words' : 'Browse');
    };

    function displayDictResults(results, title) {
      if (results.length === 0) {
        document.getElementById('dictResults').innerHTML = '<div class="results"><p>No results found</p></div>';
        return;
      }

      let html = `<div class="results"><h3>${title} (${results.length})</h3>`;
      html += '<p style="font-size:12px;color:var(--gray);margin-bottom:10px;">Click word to search in ELS index, or + to add as search term</p>';
      html += '<div class="results-scrollable">';
      results.forEach(r => {
        const def = r.definition || r.gloss || r.meaning || '';
        const srcBadge = r.source ? `<span style="background:#ddd;padding:2px 6px;border-radius:3px;font-size:11px;">${r.source}</span>` : '';
        const inIndex = elsService?.hasWord(r.word);
        const indexBadge = inIndex ? '<span style="background:#d4edda;color:#2e7d32;padding:2px 6px;border-radius:3px;font-size:11px;">in index</span>' : '';
        html += `<div style="padding:12px;border-bottom:1px solid var(--border);cursor:pointer;transition:background 0.15s;"
                     onmouseover="this.style.background='var(--blue-light)'"
                     onmouseout="this.style.background='transparent'">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <span style="font-size:20px;font-weight:bold;color:var(--blue);" onclick="searchWordInELS('${r.word}')">${r.word}</span>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="btn btn-small" onclick="event.stopPropagation();addWordToSearch('${r.word}')" title="Add to search terms">+</button>
              ${indexBadge}
              ${srcBadge}
            </div>
          </div>
          ${def ? `<div style="color:var(--gray);margin-top:4px;">${def.substring(0, 200)}${def.length > 200 ? '...' : ''}</div>` : ''}
          ${r.root ? `<div style="font-size:12px;color:#888;margin-top:4px;">Root: ${r.root}</div>` : ''}
        </div>`;
      });
      html += '</div></div>';
      document.getElementById('dictResults').innerHTML = html;
    }

    window.searchWordInELS = function(word) {
      // Switch to index mode
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('.mode-tab[data-mode="index"]').classList.add('active');
      document.getElementById('index-mode').classList.add('active');

      // Set the word as first term and search
      const container = document.getElementById('termEntries');
      container.innerHTML = `<div class="term-entry">
        <input type="text" class="term-input" value="${word}" dir="rtl">
        <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
      </div>`;

      // Run search
      if (elsService) {
        const occs = elsService.findWord(word);
        currentResults = {
          terms: [word],
          termData: { [word]: { occurrences: occs, count: occs.length } },
          proximityPairs: [],
          timestamp: new Date().toISOString()
        };
        displayIndexResults(currentResults);
      }
    };

    window.addWordToSearch = function(word) {
      // Switch to index mode if not already
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('.mode-tab[data-mode="index"]').classList.add('active');
      document.getElementById('index-mode').classList.add('active');

      // Add word as new term
      const container = document.getElementById('termEntries');
      const n = container.querySelectorAll('.term-entry').length + 1;
      const div = document.createElement('div');
      div.className = 'term-entry';
      div.innerHTML = `<input type="text" class="term-input" value="${word}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
      container.appendChild(div);
    };

    // ============= 3D MATRIX VIEW =============
    let THREE = null, OrbitControls = null;
    let scene3D = null, camera3D = null, renderer3D = null, controls3D = null;
    let animFrame3D = null;
    let is3DActive = false;
    let current3DHits = null;
    let meshUserData = []; // for raycasting
    let textureCache = new Map();
    let raycaster3D = null, mouse3D = null;

    // Lazy-load Three.js from CDN
    async function load3DDeps() {
      if (THREE) return;
      const threeModule = await import('https://unpkg.com/three@0.160.0/build/three.module.js');
      THREE = threeModule;
      const controlsModule = await import('https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js');
      OrbitControls = controlsModule.OrbitControls;
    }

    // Auto-compute optimal W,H from hit skip values
    function findOptimalDimensions(hits) {
      const skips = [...new Set(hits.map(h => Math.abs(h.skip)))].filter(s => s >= 2);
      if (skips.length === 0) return { W: 30, H: 15 };

      // Generate candidate W values
      const candidateWs = new Set();
      for (const s of skips) {
        if (s >= 10 && s <= 200) candidateWs.add(s);
        if (s - 1 >= 10) candidateWs.add(s - 1);
        if (s + 1 <= 200) candidateWs.add(s + 1);
        // factors of s
        for (let f = 2; f * f <= s; f++) {
          if (s % f === 0) {
            if (f >= 10 && f <= 200) candidateWs.add(f);
            if (s / f >= 10 && s / f <= 200) candidateWs.add(s / f);
          }
        }
      }
      if (candidateWs.size === 0) candidateWs.add(Math.max(Math.max(...skips), 30));

      let bestScore = -1, bestW = 30, bestH = 15;

      for (const W of candidateWs) {
        // Generate candidate H values
        const candidateHs = new Set([10, 15, 20]);
        for (const s of skips) {
          if (s % W === 0) {
            const h = s / W;
            if (h >= 3 && h <= 50) candidateHs.add(h);
          }
        }
        for (const H of candidateHs) {
          let score = 0;
          for (const s of skips) {
            if (s === W) score += 10;           // Y-axis aligned
            else if (s === W * H) score += 10;  // Z-axis aligned
            else if (W > 0 && s % W === 0) score += 7; // divisible by W
            else if (s === W + 1 || s === W - 1) score += 6; // XY diagonal
            else if (Math.abs(s - W) <= 3) score += 3;       // near axis
          }
          if (score > bestScore) { bestScore = score; bestW = W; bestH = H; }
        }
      }

      return { W: bestW, H: bestH };
    }

    // Create Hebrew letter texture on canvas
    function makeLetterTexture(letter, colorHex) {
      const key = letter + '|' + colorHex;
      if (textureCache.has(key)) return textureCache.get(key);

      const size = 64;
      const cv = document.createElement('canvas');
      cv.width = size; cv.height = size;
      const ctx = cv.getContext('2d');

      // Background with slight transparency
      ctx.fillStyle = colorHex;
      ctx.globalAlpha = 0.85;
      ctx.fillRect(0, 0, size, size);
      ctx.globalAlpha = 1;

      // Letter
      ctx.fillStyle = (colorHex === '#ffc107' || colorHex === '#00bcd4') ? '#000' : '#fff';
      ctx.font = 'bold 40px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(letter, size / 2, size / 2);

      const tex = new THREE.CanvasTexture(cv);
      tex.minFilter = THREE.LinearFilter;
      textureCache.set(key, tex);
      return tex;
    }

    // Init Three.js scene
    function init3DScene(container) {
      const w = container.clientWidth, h = container.clientHeight;

      scene3D = new THREE.Scene();
      scene3D.background = new THREE.Color('#1a1a2e');

      camera3D = new THREE.PerspectiveCamera(50, w / h, 0.1, 2000);
      camera3D.position.set(0, 0, 50);

      renderer3D = new THREE.WebGLRenderer({ antialias: true });
      renderer3D.setSize(w, h);
      renderer3D.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer3D.domElement);

      // Lights
      scene3D.add(new THREE.AmbientLight(0xffffff, 0.7));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.set(10, 20, 15);
      scene3D.add(dirLight);

      // Controls
      controls3D = new OrbitControls(camera3D, renderer3D.domElement);
      controls3D.enableDamping = true;
      controls3D.dampingFactor = 0.08;
      controls3D.autoRotate = true;
      controls3D.autoRotateSpeed = 1.0;

      // Raycaster
      raycaster3D = new THREE.Raycaster();
      mouse3D = new THREE.Vector2();

      // Mousemove for tooltips
      renderer3D.domElement.addEventListener('mousemove', onMouseMove3D);

      // Animation loop
      function animate() {
        animFrame3D = requestAnimationFrame(animate);
        controls3D.update();
        renderer3D.render(scene3D, camera3D);
      }
      animate();
    }

    // Render 3D matrix
    function render3DMatrix(hits, W, H) {
      if (!scene3D || !THREE) return;

      // Clear existing meshes
      const toRemove = [];
      scene3D.traverse(obj => { if (obj.isMesh) toRemove.push(obj); });
      toRemove.forEach(obj => { obj.geometry.dispose(); obj.material.dispose(); scene3D.remove(obj); });
      meshUserData = [];

      // Build posMap: position -> { termIdxs, letter }
      const posMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          if (p < 0 || p >= torahText.length) continue;
          if (!posMap.has(p)) posMap.set(p, { termIdxs: new Set(), letter: torahText[p] });
          posMap.get(p).termIdxs.add(h.termIdx);
        }
      }

      const cellSize = 1.2;
      const layerGap = 1.5;
      const group = new THREE.Group();
      const planeGeo = new THREE.PlaneGeometry(cellSize * 0.9, cellSize * 0.9);

      // Collect positions for context neighbors
      const contextPositions = new Set();
      for (const pos of posMap.keys()) {
        for (const dp of [-1, 1, -W, W]) {
          const np = pos + dp;
          if (np >= 0 && np < torahText.length && !posMap.has(np)) contextPositions.add(np);
        }
      }

      // Render highlighted term chars
      for (const [pos, data] of posMap) {
        const col = pos % W;
        const row = Math.floor(pos / W) % H;
        const layer = Math.floor(pos / (W * H));

        const color = data.termIdxs.size > 1 ? '#9c27b0' :
          TERM_COLORS[[...data.termIdxs][0] % 8];
        const tex = makeLetterTexture(data.letter, color);
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(planeGeo, mat);

        // Position: X = col (RTL so negate), Y = -row, Z = layer * gap
        mesh.position.set(-col * cellSize, -row * cellSize, layer * cellSize * layerGap);
        group.add(mesh);

        // Store data for raycasting
        const termNames = [...data.termIdxs].map(t => scanTerms[t] || `Term ${t}`).join(', ');
        const verse = getVerseForPosition(pos);
        mesh.userData = { pos, letter: data.letter, termNames, verse, col, row, layer };
        meshUserData.push(mesh);
      }

      // Render dim context neighbors
      for (const pos of contextPositions) {
        const col = pos % W;
        const row = Math.floor(pos / W) % H;
        const layer = Math.floor(pos / (W * H));
        const letter = torahText[pos];

        const tex = makeLetterTexture(letter, '#2d2d44');
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(planeGeo, mat);
        mesh.position.set(-col * cellSize, -row * cellSize, layer * cellSize * layerGap);
        group.add(mesh);
      }

      // Layer guide planes (semi-transparent)
      const allLayers = new Set();
      for (const pos of posMap.keys()) allLayers.add(Math.floor(pos / (W * H)));
      for (const layer of allLayers) {
        const guideGeo = new THREE.PlaneGeometry(W * cellSize, H * cellSize);
        const guideMat = new THREE.MeshBasicMaterial({
          color: 0x3a3a5d, transparent: true, opacity: 0.05, side: THREE.DoubleSide
        });
        const guide = new THREE.Mesh(guideGeo, guideMat);
        guide.position.set(-W * cellSize / 2, -H * cellSize / 2, layer * cellSize * layerGap);
        group.add(guide);
      }

      scene3D.add(group);

      // Center group
      const box = new THREE.Box3().setFromObject(group);
      const center = box.getCenter(new THREE.Vector3());
      group.position.sub(center);

      fitCameraToGroup(box);

      // Update info bar
      const layers = allLayers.size;
      const infoEl = document.getElementById('matrix3DInfo');
      infoEl.style.display = 'flex';
      infoEl.innerHTML = `
        <span>W: <span class="info-val">${W}</span></span>
        <span>H: <span class="info-val">${H}</span></span>
        <span>Layers: <span class="info-val">${layers}</span></span>
        <span>Cells: <span class="info-val">${posMap.size + contextPositions.size}</span></span>
        <span style="margin-right:auto;"></span>
        <span>Drag to orbit · Scroll to zoom · Right-drag to pan</span>
      `;
    }

    function fitCameraToGroup(box) {
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera3D.fov * (Math.PI / 180);
      let dist = maxDim / (2 * Math.tan(fov / 2));
      dist *= 1.4; // padding
      camera3D.position.set(dist * 0.5, dist * 0.3, dist);
      camera3D.lookAt(0, 0, 0);
      controls3D.target.set(0, 0, 0);
      controls3D.update();
    }

    // Tooltip raycasting
    function onMouseMove3D(event) {
      if (!raycaster3D || !camera3D || meshUserData.length === 0) return;
      const rect = renderer3D.domElement.getBoundingClientRect();
      mouse3D.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse3D.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster3D.setFromCamera(mouse3D, camera3D);
      const intersects = raycaster3D.intersectObjects(meshUserData);

      const tooltip = document.getElementById('matrix3DTooltip');
      if (intersects.length > 0) {
        const d = intersects[0].object.userData;
        if (d && d.termNames) {
          tooltip.innerHTML = `<strong>${d.letter}</strong> — ${d.termNames}` +
            (d.verse ? `<br>${d.verse}` : '') +
            `<br>pos: ${d.pos.toLocaleString()} | col: ${d.col} row: ${d.row} layer: ${d.layer}`;
          tooltip.style.display = 'block';
          tooltip.style.left = (event.clientX - rect.left + 12) + 'px';
          tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
        }
      } else {
        tooltip.style.display = 'none';
      }
    }

    // Toggle between 2D and 3D views
    window.toggle3DView = async function() {
      const btn = document.getElementById('btn3DToggle');
      const d2 = document.getElementById('scanMatrix2D');
      const d3 = document.getElementById('scanMatrix3D');
      const pauseBtn = document.getElementById('btn3DPause');
      const resetBtn = document.getElementById('btn3DReset');

      if (is3DActive) {
        // Switch back to 2D
        is3DActive = false;
        btn.textContent = '3D View';
        btn.classList.remove('active');
        d2.style.display = '';
        d3.style.display = 'none';
        pauseBtn.style.display = 'none';
        resetBtn.style.display = 'none';
        destroy3DScene();
        return;
      }

      // Switch to 3D
      btn.textContent = 'Loading 3D...';
      btn.disabled = true;
      try {
        await load3DDeps();
      } catch (e) {
        alert('Failed to load Three.js: ' + e.message);
        btn.textContent = '3D View';
        btn.disabled = false;
        return;
      }

      is3DActive = true;
      btn.textContent = '2D View';
      btn.classList.add('active');
      btn.disabled = false;
      d2.style.display = 'none';
      d3.style.display = '';
      pauseBtn.style.display = '';
      resetBtn.style.display = '';

      const container = document.getElementById('matrix3DCanvas');
      // Remove old canvas if any
      const oldCanvas = container.querySelector('canvas');
      if (oldCanvas) oldCanvas.remove();

      init3DScene(container);

      if (current3DHits && current3DHits.length > 0) {
        const { W, H } = findOptimalDimensions(current3DHits);
        render3DMatrix(current3DHits, W, H);
      }
    };

    window.toggle3DAutoRotate = function() {
      if (!controls3D) return;
      controls3D.autoRotate = !controls3D.autoRotate;
      document.getElementById('btn3DPause').textContent =
        controls3D.autoRotate ? 'Pause Rotation' : 'Resume Rotation';
    };

    window.reset3DCamera = function() {
      if (!scene3D || !camera3D) return;
      const box = new THREE.Box3().setFromObject(scene3D);
      fitCameraToGroup(box);
    };

    function destroy3DScene() {
      if (animFrame3D) { cancelAnimationFrame(animFrame3D); animFrame3D = null; }
      if (renderer3D) {
        renderer3D.domElement.removeEventListener('mousemove', onMouseMove3D);
        renderer3D.dispose();
        const container = document.getElementById('matrix3DCanvas');
        const canvas = container?.querySelector('canvas');
        if (canvas) canvas.remove();
        renderer3D = null;
      }
      if (controls3D) { controls3D.dispose(); controls3D = null; }
      // Dispose all textures in scene
      if (scene3D) {
        scene3D.traverse(obj => {
          if (obj.isMesh) {
            obj.geometry.dispose();
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        });
        scene3D = null;
      }
      camera3D = null;
      meshUserData = [];
      document.getElementById('matrix3DInfo').style.display = 'none';
      document.getElementById('matrix3DTooltip').style.display = 'none';
    }

    // Resize handler
    function onResize3D() {
      if (!renderer3D || !camera3D) return;
      const container = document.getElementById('matrix3DCanvas');
      const w = container.clientWidth, h = container.clientHeight;
      camera3D.aspect = w / h;
      camera3D.updateProjectionMatrix();
      renderer3D.setSize(w, h);
    }
    window.addEventListener('resize', onResize3D);

    // ============= INIT ON LOAD =============
    init();
  </script>
</body>
</html>
