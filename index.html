<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=5">
  <meta name="theme-color" content="#667eea">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ELS Search">
  <meta name="description" content="Search for Equidistant Letter Sequences (ELS) in the Hebrew Bible">
  <link rel="icon" type="image/png" href="img/favicon.png">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
  <link rel="manifest" href="manifest.json">
  <title>Bible Codes - ELS Search</title>
  <script>
    // Force-clear stale caches and update service worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js', { updateViaCache: 'none' }).then(reg => {
          reg.addEventListener('updatefound', () => {
            const newSW = reg.installing;
            newSW.addEventListener('statechange', () => {
              if (newSW.state === 'activated') location.reload();
            });
          });
          reg.update();
        });
      });
    }
    // Detect module load failure
    window._moduleLoaded = false;
    // Load Torah text preview independently (non-module, doesn't depend on imports)
    document.addEventListener('DOMContentLoaded', () => {
      fetch('data/torahNoSpaces.txt').then(r => r.text()).then(txt => {
        const el = document.getElementById('torahTextPreview');
        if (el && !el.textContent && txt) {
          let d = '';
          for (let i = 0; i < txt.length; i += 5) d += txt.slice(i, i + 5) + ' ';
          el.textContent = d;
        }
      }).catch(() => {});
    });
  </script>
  <style>
    :root {
      --blue: #1e5aa8;
      --blue-light: #e8f0f8;
      --blue-dark: #174a8a;
      --gray: #555;
      --gray-light: #f5f5f5;
      --border: #ccc;
      --green: #2e7d32;
      --red: #c62828;
      --orange: #e65100;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100dvh;
      overflow: hidden;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--gray-light);
      color: #333;
      line-height: 1.5;
      display: flex;
      flex-direction: column;
    }
    @media (max-width: 767px) {
      html, body { height: auto; overflow: auto; }
    }
    .header {
      background: var(--blue);
      color: white;
      padding: 4px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
      flex-wrap: wrap;
    }
    .header a { color: white; text-decoration: none; }
    .header img { width: 24px; height: 24px; }
    .header h1 { font-size: 15px; font-weight: 600; margin-right: auto; }
    .header-nav { display: flex; gap: 6px; flex-wrap: wrap; align-items: center; }
    .header-nav a { font-size: 12px; opacity: 0.85; padding: 2px 5px; border-radius: 3px; white-space: nowrap; }
    .header-nav a:hover { opacity: 1; background: rgba(255,255,255,0.15); }
    .header-menu-btn { display: none; }
    @media (max-width: 767px) {
      .header-nav { display: none; }
      .header-menu-btn { display: inline-block; background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 2px 6px; }
      .header-nav.open { display: flex; width: 100%; order: 3; padding: 4px 0; }
    }
    main.container {
      flex: 1;
      max-width: 1600px;
      width: 100%;
      margin: 0 auto;
      padding: 2px 10px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    @media (max-width: 767px) {
      main.container { overflow: visible; flex: none; }
    }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px; }

    /* Mode Tabs */
    .mode-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 4px;
      background: white;
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid var(--border);
      flex-shrink: 0;
    }
    .mode-tab {
      flex: 1;
      padding: 6px 12px;
      border: none;
      background: white;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      color: var(--gray);
      transition: all 0.2s;
      text-align: center;
    }
    .mode-tab:not(:last-child) { border-left: 1px solid var(--border); }
    .mode-tab:hover { background: var(--blue-light); }
    .mode-tab.active {
      background: var(--blue);
      color: white;
    }
    .mode-tab .mode-desc {
      font-size: 10px;
      font-weight: normal;
      opacity: 0.7;
      display: none;
    }

    /* Sections */
    .section {
      background: white;
      border-radius: 6px;
      padding: 20px;
      margin-bottom: 16px;
      border: 1px solid var(--border);
    }
    .section h2 {
      color: var(--blue);
      font-size: 16px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .section p { margin-bottom: 12px; color: var(--gray); font-size: 14px; }

    /* Mode content */
    .mode-content { display: none; }
    .mode-content.active { display: flex; flex-direction: column; flex: 1; overflow: hidden; }
    #wrr-mode.active, #index-mode.active, #dict-mode.active { overflow-y: auto; }
    @media (max-width: 767px) {
      .mode-content.active { overflow: visible; flex: none; }
    }

    /* Form elements */
    .input-row {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    input[type="text"], input[type="number"] {
      padding: 10px 12px;
      font-size: 16px;
      border: 1px solid var(--border);
      border-radius: 4px;
      min-width: 120px;
    }
    input:focus { border-color: var(--blue); outline: none; }
    .btn {
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      background: var(--blue);
      color: white;
      border: none;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .btn:hover { background: var(--blue-dark); }
    .btn:active { transform: scale(0.98); }
    .btn-secondary { background: var(--gray); }
    .btn-success { background: var(--green); }
    .btn-danger { background: var(--red); }
    .btn-small { padding: 8px 12px; font-size: 13px; }

    /* Term entries */
    .term-entries { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .term-entry { display: flex; gap: 10px; align-items: center; }
    .term-entry input { flex: 1; }
    .term-entry .remove-btn {
      background: var(--red);
      color: white;
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      cursor: pointer;
      font-size: 16px;
    }

    /* Results */
    .results {
      background: #fafafa;
      border-radius: 4px;
      padding: 15px;
      margin-top: 15px;
      border: 1px solid var(--border);
    }
    .results h3 { color: var(--blue); margin-bottom: 10px; font-size: 15px; }
    .results-scrollable { max-height: 500px; overflow-y: auto; }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .results-table th, .results-table td {
      border: 1px solid var(--border);
      padding: 8px;
      text-align: right;
    }
    .results-table th {
      background: var(--blue);
      color: white;
      position: sticky;
      top: 0;
    }
    .results-table tr:nth-child(even) { background: #f5f5f5; }
    .results-table tr:hover { background: var(--blue-light); }

    /* Stats grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .stat-box {
      background: var(--blue);
      color: white;
      padding: 14px;
      border-radius: 4px;
      text-align: center;
    }
    .stat-box .value { font-size: 20px; font-weight: bold; }
    .stat-box .label { font-size: 11px; opacity: 0.9; }

    /* Proximity matrix */
    .proximity-matrix { overflow-x: auto; margin-top: 15px; }
    .proximity-matrix table { border-collapse: collapse; font-size: 13px; width: 100%; }
    .proximity-matrix th, .proximity-matrix td {
      border: 1px solid var(--border);
      padding: 8px 12px;
      text-align: center;
    }
    .proximity-matrix th { background: var(--blue); color: white; }
    .cell-close { background: #d4edda; }
    .cell-medium { background: #fff3cd; }
    .cell-far { background: #f8d7da; }

    /* Clickable rows */
    .clickable-row { cursor: pointer; transition: background 0.15s; }
    .clickable-row:hover { background: #d0e4f7 !important; }
    .clickable-row.selected { background: var(--blue) !important; color: white; }
    .clickable-row.selected td { color: white; }

    /* Matrix view */
    .matrix-view {
      margin-top: 20px;
      padding: 20px;
      background: #2a2a3d;
      border-radius: 6px;
      color: white;
    }
    .matrix-view h3 { color: #8bb8e8; margin-bottom: 10px; }
    .matrix-view .hint { color: #999; font-size: 13px; }
    .els-matrix {
      font-family: 'Courier New', monospace;
      font-size: 16px;
      line-height: 1.8;
      direction: rtl;
      background: #1a1a28;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      white-space: pre;
      margin: 15px 0;
    }
    .els-matrix .hl1 { background: var(--red); color: white; padding: 2px; border-radius: 2px; }
    .els-matrix .hl2 { background: var(--green); color: white; padding: 2px; border-radius: 2px; }
    .els-matrix .hl-both { background: var(--orange); color: white; padding: 2px; border-radius: 2px; }
    .matrix-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }
    .matrix-stat {
      background: #3a3a4d;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    .matrix-stat .value { font-size: 16px; font-weight: bold; color: #8bb8e8; }
    .matrix-stat .label { font-size: 10px; color: #999; }

    /* Save/Load panel */
    .save-panel {
      background: var(--blue-light);
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 15px;
      border: 1px solid #c8dae8;
    }
    .saved-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: white;
      border-radius: 4px;
      margin-top: 8px;
      border: 1px solid var(--border);
    }
    .saved-item .name { font-weight: bold; color: var(--blue); }
    .saved-item .meta { font-size: 11px; color: #666; }

    /* Loading */
    .loading { text-align: center; padding: 40px; color: #666; }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #eee;
      border-top-color: var(--blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Action buttons */
    .action-row {
      display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px;
      position: sticky; top: 0; z-index: 20;
      background: white; padding: 10px 20px;
      border-bottom: 1px solid var(--border);
      margin-left: -20px; margin-right: -20px;
    }
    .scan-results-container {
      max-height: 60vh;
      overflow-y: auto;
      margin-top: 10px;
    }
    @media (max-width: 600px) {
      .scan-results-container { max-height: 50vh; }
    }

    /* Scan mode specific */
    .range-row {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 15px;
      font-size: 14px;
    }
    .range-row label { display: flex; align-items: center; gap: 6px; }
    .range-row input[type="number"] { width: 80px; }
    .result-item {
      padding: 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }
    .result-item:hover { background: var(--blue-light); }
    .result-item .term { font-weight: bold; color: var(--blue); font-size: 18px; }
    .result-item .info { font-size: 13px; color: var(--gray); margin-top: 4px; }

    .matrix-container {
      background: #1a1a2e;
      border-radius: 8px;
      padding: 20px;
      overflow: auto;
      max-width: 100vw;
      max-height: calc(100dvh - 150px);
    }
    .matrix-grid {
      display: grid;
      gap: 2px;
      direction: rtl;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      min-width: max-content;
    }
    .matrix-cell {
      width: 26px;
      height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #2d2d44;
      color: #e0e0e0;
      border-radius: 3px;
    }
    .matrix-cell.term1 { background: #ffc107; color: #000; font-weight: bold; }
    .matrix-cell.term2 { background: #00bcd4; color: #000; font-weight: bold; }
    .matrix-cell.term1.term2 { background: #9c27b0; color: #fff; }
    /* N-term color palette for scan mode */
    .matrix-cell.term-color-0 { background: #ffc107; color: #000; font-weight: bold; }
    .matrix-cell.term-color-1 { background: #00bcd4; color: #000; font-weight: bold; }
    .matrix-cell.term-color-2 { background: #ff5722; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-3 { background: #4caf50; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-4 { background: #e91e63; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-5 { background: #3f51b5; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-6 { background: #795548; color: #fff; font-weight: bold; }
    .matrix-cell.term-color-7 { background: #607d8b; color: #fff; font-weight: bold; }
    .matrix-cell.multi-term { background: #9c27b0; color: #fff; font-weight: bold; }
    /* (scan-term-entries removed — replaced by unified textarea input) */
    .cluster-row { padding: 14px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; }
    .cluster-row:hover { background: var(--blue-light); }
    .cluster-span { font-weight: bold; color: var(--green); font-size: 16px; }
    .cluster-terms { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .cluster-term-tag { padding: 4px 10px; border-radius: 4px; font-size: 13px; border: 1px solid; }
    .cluster-verses { font-size: 12px; color: #666; margin-top: 6px; }
    .matrix-legend {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      color: white;
      font-size: 13px;
      flex-wrap: wrap;
    }
    .legend-item { display: flex; align-items: center; gap: 6px; }
    .legend-color { width: 18px; height: 18px; border-radius: 3px; }
    .legend-color.t1 { background: #ffc107; }
    .legend-color.t2 { background: #00bcd4; }
    .legend-color.both { background: #9c27b0; }

    /* Info text */
    .info-text {
      background: #e8f5e9;
      border-radius: 4px;
      padding: 10px 14px;
      border-right: 3px solid var(--green);
      font-size: 13px;
      color: var(--green);
      margin-bottom: 15px;
    }

    /* Batch loader */
    .batch-panel {
      background: #f0f4ff;
      border: 1px solid #b0c4de;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 15px;
    }
    .batch-panel h3 { color: var(--blue-dark); font-size: 14px; margin-bottom: 10px; }
    .batch-textarea {
      width: 100%;
      height: 120px;
      font-size: 14px;
      font-family: inherit;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      direction: rtl;
      resize: vertical;
    }
    /* Hebrew virtual keyboard */
    .heb-kb-toggle {
      background: none;
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-size: 14px;
      color: var(--gray);
      transition: background 0.15s, border-color 0.15s;
      line-height: 1;
    }
    .heb-kb-toggle:hover { border-color: var(--blue); color: var(--blue); }
    .heb-kb-toggle.active { background: var(--blue); color: #fff; border-color: var(--blue); }
    .heb-kb-panel {
      display: none;
      background: #f8f9fb;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 12px;
      direction: ltr;
    }
    .heb-kb-panel.open { display: block; }
    .heb-kb-row { display: flex; gap: 4px; justify-content: center; margin-bottom: 4px; }
    .heb-kb-row:last-child { margin-bottom: 0; }
    .heb-kb-key {
      min-width: 32px; height: 36px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
      font-size: 18px;
      font-family: 'SBL Hebrew', 'David', 'Noto Sans Hebrew', serif;
      display: flex; align-items: center; justify-content: center;
      transition: background 0.1s, box-shadow 0.1s;
      user-select: none;
      padding: 0 6px;
    }
    .heb-kb-key:hover { background: #e3ecf7; box-shadow: 0 1px 3px rgba(0,0,0,0.12); }
    .heb-kb-key:active { background: var(--blue); color: #fff; }
    .heb-kb-key.wide { min-width: 56px; font-size: 12px; color: var(--gray); }
    @media (max-width: 500px) {
      .heb-kb-key { min-width: 26px; height: 32px; font-size: 16px; padding: 0 3px; }
      .heb-kb-key.wide { min-width: 42px; font-size: 10px; }
    }
    .batch-progress {
      width: 100%;
      height: 24px;
      background: #ddd;
      border-radius: 12px;
      overflow: hidden;
      margin: 10px 0;
    }
    .batch-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--blue), var(--green));
      border-radius: 12px;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      color: white;
      min-width: 40px;
    }
    .batch-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      margin-top: 12px;
    }
    .batch-table th, .batch-table td {
      border: 1px solid var(--border);
      padding: 8px 10px;
      text-align: right;
    }
    .batch-table th {
      background: var(--blue);
      color: white;
      position: sticky;
      top: 0;
      cursor: pointer;
    }
    .batch-table th:hover { background: var(--blue-dark); }
    .batch-table tr:nth-child(even) { background: #f5f5f5; }
    .batch-table tr:hover { background: var(--blue-light); }
    .batch-table tr.batch-selected { background: #c8e6c9 !important; }
    .batch-status-cell { font-size: 11px; }
    .batch-status-done { color: var(--green); font-weight: bold; }
    .batch-status-active { color: var(--orange); }
    .batch-status-pending { color: #999; }
    .batch-actions {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .batch-select-info {
      font-size: 12px;
      color: var(--gray);
      padding: 8px 0;
    }

    /* Verse hover highlight */
    .matrix-cell.verse-glow {
      box-shadow: 0 0 0 2px #fff, 0 0 8px 3px rgba(255,255,255,0.7);
      z-index: 2;
      position: relative;
    }
    #verseContextPanel.collapsed #verseContextBody { display: none; }
    .verse-ref-hover {
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 3px;
    }
    .verse-ref-hover:hover { text-decoration-style: solid; }
    #verseTooltip {
      position: fixed;
      background: rgba(0,0,0,0.92);
      color: #e0e0e0;
      padding: 10px 14px;
      border-radius: 6px;
      font-size: 15px;
      font-family: 'Courier New', monospace;
      direction: rtl;
      max-width: 500px;
      line-height: 1.8;
      pointer-events: none;
      display: none;
      z-index: 100;
      border: 1px solid #555;
    }
    #verseTooltip .verse-tooltip-ref {
      font-size: 11px;
      color: #8bb8e8;
      font-family: sans-serif;
      margin-bottom: 4px;
    }

    /* 3D Matrix View */
    .matrix-3d-container {
      height: calc(100dvh - 200px);
      min-height: 250px;
      max-height: 800px;
      background: #1a1a2e;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    .matrix-3d-container canvas { display: block; width: 100% !important; height: 100% !important; }
    #btn3DToggle.active { background: #9c27b0; }
    .btn-3d-ctrl { padding: 6px 12px; font-size: 12px; font-weight: 600; cursor: pointer; background: #555; color: #fff; border: none; border-radius: 4px; }
    .btn-3d-ctrl:hover { background: #777; }
    #matrix3DInfo {
      background: #2a2a3d;
      color: #aaa;
      font-size: 12px;
      padding: 8px 14px;
      border-radius: 0 0 8px 8px;
      display: flex;
      gap: 18px;
      flex-wrap: wrap;
    }
    #matrix3DInfo .info-val { color: #8bb8e8; font-weight: bold; }
    #matrix3DTooltip {
      position: absolute;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      z-index: 10;
      white-space: nowrap;
      direction: rtl;
    }

    /* 3D Video Capture Controls — shown when 3D mode is active */
    #videoControlPanel {
      background: #1a1a2e;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 6px 12px;
      margin-bottom: 6px;
    }
    #videoControlPanel .vid-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 6px;
    }
    #videoControlPanel .vid-row:last-child { margin-bottom: 0; }
    .vid-btn {
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      color: #fff;
      min-height: 32px;
    }
    .vid-btn-rec { background: #c62828; }
    .vid-btn-rec:hover { background: #e53935; }
    .vid-btn-rec.recording { background: #f44336; animation: rec-pulse 1s infinite; }
    @keyframes rec-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.6; } }
    .vid-btn-stop { background: #555; }
    .vid-btn-stop:hover { background: #777; }
    .vid-btn-frame { background: #37474f; }
    .vid-btn-frame:hover { background: #546e7a; }
    .vid-btn-dl { background: #2e7d32; }
    .vid-btn-dl:hover { background: #43a047; }
    #vidTimeline {
      flex: 1;
      min-width: 120px;
      height: 6px;
      appearance: none;
      background: #333;
      border-radius: 3px;
      outline: none;
    }
    #vidTimeline::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #8bb8e8;
      cursor: pointer;
    }
    #vidTimeline::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #8bb8e8;
      cursor: pointer;
      border: none;
    }
    #vidStatus {
      font-size: 12px;
      color: #aaa;
      min-width: 140px;
    }
    #vidStatus .rec-dot { color: #f44336; }
    .vid-label {
      font-size: 11px;
      color: #888;
      white-space: nowrap;
    }
    #vidSpeedSlider {
      width: 80px;
      height: 4px;
      appearance: none;
      background: #444;
      border-radius: 2px;
      outline: none;
    }
    #vidSpeedSlider::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ce93d8;
      cursor: pointer;
    }
    #vidSpeedSlider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ce93d8;
      cursor: pointer;
      border: none;
    }
    #vidFPSSelect {
      background: #2a2a3d;
      color: #ccc;
      border: 1px solid #555;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 11px;
    }

    /* Intro blurb */
    .intro-blurb {
      background: linear-gradient(135deg, var(--blue-light) 0%, #f0f4ff 100%);
      border: 1px solid #c8d8f0;
      border-radius: 4px;
      margin-bottom: 4px;
      padding: 0;
      flex-shrink: 0;
    }
    .intro-blurb summary {
      cursor: pointer;
      padding: 4px 12px;
      font-weight: 600;
      color: var(--blue-dark);
      font-size: 12px;
      list-style: none;
    }
    .intro-blurb summary::-webkit-details-marker { display: none; }
    .intro-blurb summary::before {
      content: '\25B6'; margin-left: 8px; font-size: 11px;
      display: inline-block; transition: transform 0.2s;
    }
    .intro-blurb[open] summary::before { transform: rotate(90deg); }
    .blurb-content {
      padding: 0 16px 14px;
      font-size: 14px; color: #444; line-height: 1.6;
    }
    .blurb-content a { color: var(--blue); }

    /* Site footer */
    .site-footer {
      display: none;
      text-align: center;
      padding: 20px 16px;
      margin-top: 30px;
      border-top: 1px solid var(--border);
      font-size: 13px;
      color: var(--gray);
    }
    .footer-links {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px 16px;
      margin-bottom: 8px;
    }
    .footer-links a { color: var(--blue); text-decoration: none; }
    .footer-links a:hover { text-decoration: underline; }

    /* === Two-column scan layout === */
    .scan-layout { padding: 0 !important; margin-bottom: 0 !important; flex: 1; overflow: hidden; display: flex; flex-direction: column; }
    .scan-grid { display: flex; flex-direction: column; flex: 1; overflow: hidden; }
    @media (max-width: 767px) {
      .scan-layout { overflow: visible; flex: none; }
      .scan-grid { overflow: visible; flex: none; }
    }

    @media (min-width: 1024px) {
      .scan-grid {
        display: grid;
        grid-template-columns: 7fr 3fr;
        gap: 12px;
        direction: ltr;
      }
      .scan-col-matrix, .scan-col-controls { direction: rtl; }

      .scan-col-matrix {
        overflow-y: auto;
        min-width: 0;
      }
      .scan-col-controls {
        min-width: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .scan-controls-frozen {
        flex-shrink: 0;
        background: white;
        padding: 6px 0 4px;
        border-bottom: 1px solid var(--border);
      }
      .scan-controls-frozen h2 { font-size: 14px; margin-bottom: 2px; }
      .scan-controls-frozen .action-row { margin: 0; padding: 4px 0; }
      .scan-controls-frozen .btn { padding: 4px 12px; font-size: 12px; }
      .scan-controls-frozen .range-row { font-size: 12px; margin: 2px 0; }
      .scan-controls-frozen .range-row input { width: 60px; padding: 2px 4px; font-size: 12px; }
      .scan-controls-frozen .save-panel { margin: 2px 0; font-size: 11px; }
      .scan-controls-frozen .save-panel .btn { padding: 2px 8px; font-size: 11px; }
      .scan-controls-scroll {
        flex: 1;
        overflow-y: auto;
        min-height: 0;
      }

      .scan-col-controls .batch-textarea { height: 80px; min-height: 60px; }
      .scan-col-controls #clusterListContainer { max-height: 35vh; }
      .scan-col-controls .scan-results-container { max-height: none; }
      .scan-col-controls .results-scrollable { max-height: 200px; }

      .matrix-toolbar {
        position: sticky; top: 0; z-index: 10;
        background: #2a2a3d; padding: 8px 0;
      }

      .scan-col-matrix .matrix-container { max-height: calc(100dvh - 160px) !important; }
    }

    .matrix-placeholder {
      background: #2a2a3d; border-radius: 8px;
      padding: 60px 20px; text-align: center;
      color: #8bb8e8; min-height: 300px;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
    }
    .matrix-placeholder h3 { color: #8bb8e8; margin-bottom: 12px; font-size: 18px; }
    .matrix-placeholder p { color: #999; font-size: 14px; line-height: 1.7; margin: 0; }

    @media (max-width: 767px) {
      .scan-col-controls { order: 1; }
      .scan-col-matrix { order: 2; }
      #scanMatrixPlaceholder { max-height: 40vh; }
      .header { padding: 6px 10px; }
      .header h1 { font-size: 14px; }
      main.container { padding: 2px 6px; }
      .section { padding: 12px 10px; }
      .mode-tab { padding: 8px 6px; font-size: 12px; }
      .btn { padding: 10px 14px; font-size: 14px; }
      .btn-small { padding: 6px 8px; font-size: 12px; }
      .batch-textarea { height: 80px; }
      .matrix-container { max-height: none !important; }
      .intro-blurb { margin-bottom: 6px; }
      .intro-blurb summary { padding: 6px 10px; font-size: 13px; }
      #verseTooltip { max-width: 90vw; font-size: 14px; }
    }

    @media (min-width: 768px) and (max-width: 1023px) {
      .scan-col-matrix { order: 1; }
      .scan-col-controls { order: 2; }
      .scan-col-controls #clusterListContainer { max-height: 300px; }
    }

    @media (max-width: 600px) {
      .mode-tab .mode-desc { display: none; }
      .matrix-cell { width: 20px; height: 20px; font-size: 13px; }
      .matrix-3d-container { height: min(60vh, 350px); min-height: 200px; }
      input[type="text"], input[type="number"] { min-width: 80px; font-size: 15px; padding: 8px; }
      .range-row input[type="number"] { width: 65px; }
    }

    @media (max-width: 420px) {
      .matrix-cell { width: 18px; height: 18px; font-size: 12px; }
      .mode-tab { padding: 8px 4px; font-size: 11px; }
      .header h1 { font-size: 13px; }
      .section { padding: 10px 8px; }
      .btn { padding: 8px 10px; font-size: 13px; }
    }

    /* Mobile: video controls & toolbar */
    @media (max-width: 767px) {
      #videoControlPanel { padding: 6px 8px; }
      #videoControlPanel .vid-row { gap: 6px; }
      .vid-btn { padding: 8px 10px; font-size: 11px; min-height: 36px; }
      .vid-label { font-size: 11px; }
      #vidTimeline { min-width: 80px; }
      #matrixToolbar { gap: 4px; }
      #matrixToolbar .btn-small { padding: 6px 8px; font-size: 11px; }
      .heb-kb-key { min-width: 28px; height: 34px; font-size: 17px; }
      .heb-kb-key.wide { min-width: 44px; font-size: 11px; }
    }
    @media (max-width: 420px) {
      #videoControlPanel .vid-label { display: none; }
      #vidSpeedSlider { width: 60px; }
    }

    /* ===== DATE MAP HEATMAP ===== */
    #datemap-mode { padding: 12px; overflow-y: auto; }
    .dm-section { margin-bottom: 20px; }
    .dm-section h3 { margin: 0 0 10px; font-size: 15px; color: var(--white); }
    .dm-heatmap-wrap { overflow-x: auto; }
    .dm-heatmap { border-collapse: collapse; font-size: 11px; direction: rtl; }
    .dm-heatmap th { padding: 3px 6px; font-weight: normal; color: var(--gray); white-space: nowrap; position: sticky; top: 0; background: var(--bg); }
    .dm-heatmap td { padding: 0; text-align: center; cursor: pointer; position: relative; }
    .dm-heatmap td.dm-cell { width: 28px; height: 24px; border: 1px solid #333; transition: transform .1s; }
    .dm-heatmap td.dm-cell:hover { transform: scale(1.4); z-index: 2; border-color: #fff; }
    .dm-heatmap td.dm-cell.selected { outline: 2px solid #fff; outline-offset: -1px; z-index: 3; }
    .dm-heatmap .dm-month-label { font-weight: bold; color: var(--white); padding-right: 8px; text-align: left; white-space: nowrap; }
    .dm-year-grid { display: flex; flex-wrap: wrap; gap: 4px; direction: rtl; }
    .dm-year-cell { width: 48px; height: 32px; display: flex; align-items: center; justify-content: center;
      font-size: 11px; border-radius: 4px; cursor: pointer; border: 1px solid #333; transition: transform .1s; }
    .dm-year-cell:hover { transform: scale(1.15); z-index: 2; border-color: #fff; }
    .dm-year-cell.selected { outline: 2px solid #fff; outline-offset: -1px; }
    .dm-month-bar { display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 8px; }
    .dm-month-pill { padding: 4px 10px; border-radius: 12px; font-size: 12px; cursor: pointer; border: 1px solid #555; }
    .dm-month-pill:hover { border-color: #fff; }
    .dm-month-pill.selected { outline: 2px solid #fff; }
    #dmDetail { background: var(--card); border-radius: 8px; padding: 14px; margin-top: 12px; display: none; }
    #dmDetail h4 { margin: 0 0 8px; color: var(--white); }
    #dmDetail .dm-hits-list { max-height: 200px; overflow-y: auto; font-size: 12px; font-family: monospace; }
    #dmDetail .dm-hit-row { padding: 2px 0; color: var(--gray); }
    #dmDetail .dm-hit-row:hover { color: var(--white); }
    .dm-legend { display: flex; align-items: center; gap: 4px; font-size: 11px; color: var(--gray); margin-bottom: 8px; }
    .dm-legend-bar { width: 120px; height: 10px; border-radius: 3px; }
    .dm-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 16px; }
    .dm-stat-card { background: linear-gradient(135deg,#667eea22,#764ba222); padding: 12px; border-radius: 8px; text-align: center; }
    .dm-stat-val { font-size: 22px; font-weight: bold; color: var(--blue); }
    .dm-stat-label { font-size: 11px; color: var(--gray); }
    .dm-nodata { text-align: center; padding: 40px; color: var(--gray); }
    .dm-nodata code { background: #333; padding: 2px 6px; border-radius: 3px; font-size: 12px; }
    .dm-compute-btn { margin-top: 12px; }
  </style>
</head>
<body>
  <header class="header">
    <a href="./"><img src="img/favicon.png" alt=""></a>
    <h1>Bible Codes</h1>
    <button class="header-menu-btn" onclick="document.querySelector('.header-nav').classList.toggle('open')" aria-label="Menu">&#9776;</button>
    <nav class="header-nav">
      <a href="text-search.html">Text Search</a>
      <a href="gematria.html">Gematria</a>
      <a href="acronym.html">Acronyms</a>
      <a href="tsirufim.html">Tsirufim</a>
      <a href="matrix-view.html">Matrix</a>
      <a href="book-view.html">Book View</a>
      <a href="hebrew-date.html">Hebrew Date</a>
      <a href="dashboard.html">All Tools</a>
    </nav>
  </header>

  <main class="container">
    <details class="intro-blurb" id="introBlurb">
      <summary>About Bible Codes</summary>
      <div class="blurb-content">
        <p>Search for equidistant letter sequences (ELS) in the Torah.
        Multi-term clustering, 2D/3D matrix visualization, and statistical
        significance testing.</p>
        <p><a href="https://www.math.toronto.edu/drorbn/Codes/Nations/WRR2/index.html"
           target="_blank" rel="noopener">Learn more about Bible Codes research &#8594;</a></p>
      </div>
    </details>

    <div class="sacred-names-notice" style="background:#fff3cd;color:#856404;border:1px solid #ffc107;border-radius:6px;padding:10px 14px;margin:8px 0;font-size:13px;line-height:1.5;">
      <strong>Notice:</strong> This site displays Torah text containing Sacred Names of God.
      Sacred Names are redacted with <code>*</code> in display and exports to avoid <em>genizah</em> obligations.
      Please use electronic viewing when possible. If you print any output, treat the materials with appropriate reverence.
    </div>

    <!-- Mode Tabs -->
    <div class="mode-tabs">
      <button class="mode-tab" data-mode="index" style="opacity:0.5;">
        Index Lookup
        <span class="mode-desc">Instant search (110K words)</span>
      </button>
      <button class="mode-tab active" data-mode="scan">
        Full Scan
        <span class="mode-desc">Search any term</span>
      </button>
      <button class="mode-tab" data-mode="dict" style="opacity:0.5;">
        References
        <span class="mode-desc">Dictionary & Texts</span>
      </button>
      <button class="mode-tab" data-mode="wrr">
        WRR 1994
        <span class="mode-desc">Famous experiment</span>
      </button>
      <button class="mode-tab" data-mode="datemap">
        Date Map
        <span class="mode-desc">Hebrew date ELS density</span>
      </button>
    </div>

    <!-- INDEX MODE -->
    <div id="index-mode" class="mode-content">
      <div id="indexLoading" class="loading">
        <div class="spinner"></div>
        <div>Loading ELS Index...</div>
        <div id="loadProgress" style="margin-top: 10px; font-size: 12px;"></div>
      </div>

      <div id="indexContent" style="display: none;">
        <!-- Stats -->
        <section class="section">
          <h2>Index Statistics</h2>
          <div class="stats-grid" id="statsGrid"></div>
        </section>

        <!-- Multi-term search -->
        <section class="section">
          <h2>Search Terms</h2>

          <div class="save-panel">
            <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
              <button class="btn btn-secondary btn-small" onclick="exportResults()">Export</button>
              <button class="btn btn-secondary btn-small" onclick="clearSession()">Clear</button>
            </div>
            <div id="savedSessions"></div>
          </div>

          <div class="term-entries" id="termEntries">
            <div class="term-entry">
              <input type="text" class="term-input" placeholder="Term 1" dir="rtl">
              <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
            </div>
            <div class="term-entry">
              <input type="text" class="term-input" placeholder="Term 2" dir="rtl">
              <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
            </div>
          </div>

          <div class="action-row">
            <button class="btn btn-secondary" onclick="addTerm()">+ Add Term</button>
            <button class="btn" onclick="searchIndex()">Search</button>
          </div>

          <div id="indexResults"></div>
        </section>
      </div>
    </div>

    <!-- SCAN MODE -->
    <div id="scan-mode" class="mode-content active">
      <section class="section scan-layout">
       <div class="scan-grid">
        <!-- LEFT: Matrix/3D (70% on desktop) -->
        <div class="scan-col-matrix">
          <div id="scanMatrixPlaceholder" style="background:#2a2a3d;border-radius:8px;height:100%;overflow-y:auto;direction:rtl;">
            <div id="torahTextPreview" style="padding:16px;font-family:'SBL Hebrew','David','Noto Sans Hebrew',serif;font-size:18px;line-height:2;text-align:right;color:#d4d4d4;letter-spacing:0.5px;word-break:break-all;"></div>
          </div>
          <div id="scanMatrixViewAnchor"></div>
        <!-- RIGHT: Controls+Results (30% on desktop) -->
        </div>
        <div class="scan-col-controls">
        <div class="scan-controls-frozen">
        <h2>Real-time ELS Scan</h2>

        <div class="save-panel">
          <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
            <span id="autoSaveStatus" style="font-size:11px;color:#666;">Not saved yet</span>
            <button class="btn btn-secondary btn-small" onclick="exportScanResults()">Export JSON</button>
            <button class="btn btn-secondary btn-small" onclick="clearScanSession()">Clear</button>
          </div>
        </div>

        <div class="range-row">
          <label>Skip range: <input type="number" id="minSkip" value="-500"> to <input type="number" id="maxSkip" value="500"></label>
        </div>

        <div class="action-row">
          <button class="btn" id="scanBtn" onclick="startScan()">Search</button>
          <button class="btn btn-danger" id="scanCancelBtn" onclick="cancelScan()" style="display:none;">Cancel</button>
          <span id="scanStatus" style="font-size: 12px; color: #666;"></span>
        </div>

        <div class="batch-progress" id="scanProgress" style="display:none;">
          <div class="batch-progress-bar" id="scanProgressBar" style="width:0%;">0%</div>
        </div>
        </div><!-- /scan-controls-frozen -->

        <div class="scan-controls-scroll">

        <!-- Search terms input -->
        <div class="batch-panel">
          <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;margin-bottom:10px;">
            <h3 style="margin:0;">Search Terms</h3>
            <div style="display:flex;gap:8px;align-items:center;">
              <button class="heb-kb-toggle" id="hebKbToggle" onclick="toggleHebrewKeyboard()" title="Hebrew Keyboard">⌨ אב</button>
              <input type="file" id="batchFileInput" accept=".txt" onchange="loadBatchFile(this)" style="font-size:13px;max-width:180px;">
              <button class="btn btn-small btn-secondary" onclick="clearBatchInput()">Clear</button>
            </div>
          </div>

          <!-- Hebrew virtual keyboard -->
          <div class="heb-kb-panel" id="hebKbPanel">
            <div class="heb-kb-row">
              <button class="heb-kb-key" data-char="ק">ק</button>
              <button class="heb-kb-key" data-char="ר">ר</button>
              <button class="heb-kb-key" data-char="א">א</button>
              <button class="heb-kb-key" data-char="ט">ט</button>
              <button class="heb-kb-key" data-char="ו">ו</button>
              <button class="heb-kb-key" data-char="ן">ן</button>
              <button class="heb-kb-key" data-char="ם">ם</button>
              <button class="heb-kb-key" data-char="פ">פ</button>
            </div>
            <div class="heb-kb-row">
              <button class="heb-kb-key" data-char="ש">ש</button>
              <button class="heb-kb-key" data-char="ד">ד</button>
              <button class="heb-kb-key" data-char="ג">ג</button>
              <button class="heb-kb-key" data-char="כ">כ</button>
              <button class="heb-kb-key" data-char="ע">ע</button>
              <button class="heb-kb-key" data-char="י">י</button>
              <button class="heb-kb-key" data-char="ח">ח</button>
              <button class="heb-kb-key" data-char="ל">ל</button>
              <button class="heb-kb-key" data-char="ך">ך</button>
              <button class="heb-kb-key" data-char="ף">ף</button>
            </div>
            <div class="heb-kb-row">
              <button class="heb-kb-key" data-char="ז">ז</button>
              <button class="heb-kb-key" data-char="ס">ס</button>
              <button class="heb-kb-key" data-char="ב">ב</button>
              <button class="heb-kb-key" data-char="ה">ה</button>
              <button class="heb-kb-key" data-char="נ">נ</button>
              <button class="heb-kb-key" data-char="מ">מ</button>
              <button class="heb-kb-key" data-char="צ">צ</button>
              <button class="heb-kb-key" data-char="ת">ת</button>
              <button class="heb-kb-key" data-char="ץ">ץ</button>
            </div>
            <div class="heb-kb-row">
              <button class="heb-kb-key wide" data-action="newline">↵ New Line</button>
              <button class="heb-kb-key wide" data-action="space">Space</button>
              <button class="heb-kb-key wide" data-action="backspace">⌫</button>
            </div>
          </div>

          <div style="font-size:13px;color:var(--gray);margin-bottom:10px;line-height:1.6;">
            <strong>One term per line.</strong> Names are auto-cleaned to Hebrew consonants.<br>
            <strong>Alternate spellings:</strong> put variants on the <em>same line</em> separated by spaces.<br>
            <span style="font-size:12px;color:#999;">
              All alternates are searched but only the best-matching one is used per cluster/matrix.<br>
              Example: <code style="background:#f0f0f0;padding:1px 4px;border-radius:2px;direction:rtl;">דוד דויד</code> &larr; two spellings of David
            </span>
          </div>
          <textarea id="batchTextarea" class="batch-textarea" placeholder="Enter terms, one per line...&#10;Alternate spellings: same line, space-separated&#10;e.g.&#10;משה&#10;אברהם אבראהם&#10;ירושלים"></textarea>
          <div style="margin-top:8px;">
            <span id="batchParseStatus" style="font-size:13px;color:var(--gray);"></span>
          </div>

          <!-- Parsed preview (shown after search parses terms) -->
          <div id="batchPreview" style="display:none;margin-top:12px;">
            <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
              <strong id="batchPreviewCount" style="color:var(--blue);"></strong>
              <div style="font-size:12px;color:var(--gray);" id="batchTimeEstimate"></div>
            </div>
            <div id="batchPreviewList" class="results-scrollable" style="max-height:200px;margin:10px 0;font-size:13px;border:1px solid var(--border);border-radius:4px;background:white;padding:8px;direction:rtl;"></div>
          </div>

          <!-- Batch results table (populated during search) -->
          <div id="batchResults" style="display:none;margin-top:15px;">
            <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;margin-bottom:8px;">
              <strong style="color:var(--blue);">Batch Results</strong>
              <button class="btn btn-secondary btn-small" id="batchExportBtn" onclick="exportBatchResults()">Export CSV</button>
            </div>
            <div class="results-scrollable" style="max-height:500px;">
              <table class="batch-table" id="batchTable">
                <thead>
                  <tr>
                    <th onclick="sortBatchTable(0)">#</th>
                    <th onclick="sortBatchTable(1)">Original</th>
                    <th onclick="sortBatchTable(2)">Search Term</th>
                    <th onclick="sortBatchTable(3)">Letters</th>
                    <th onclick="sortBatchTable(4)">Hits</th>
                    <th onclick="sortBatchTable(5)">Best Skip</th>
                    <th class="batch-status-cell" onclick="sortBatchTable(6)">Status</th>
                  </tr>
                </thead>
                <tbody id="batchTableBody"></tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="scan-results-container">
          <div id="scanResults"></div>
        </div>

        </div><!-- /scan-controls-scroll -->
        </div><!-- /scan-col-controls -->
       </div><!-- /scan-grid -->

        <!-- Inline Matrix View (inside left column via JS move, or here as fallback) -->
        <div id="scanMatrixView" class="matrix-view" style="display:none;">
          <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
            <h3 id="scanMatrixTitle">Matrix View</h3>
            <div id="matrixToolbar" style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
              <button class="btn btn-small" id="btn3DToggle" onclick="toggle3DView()">3D View</button>
              <button class="btn-3d-ctrl" id="btn3DPause" onclick="toggle3DAutoRotate()" style="display:none;">Pause Rotation</button>
              <button class="btn-3d-ctrl" id="btn3DReset" onclick="reset3DCamera()" style="display:none;">Reset Camera</button>
              <button class="btn btn-small" onclick="downloadMatrixPNG()" style="background:#666;">PNG</button>
              <button class="btn btn-small" onclick="exportMatrixJSON()" style="background:#555;">JSON</button>
              <button class="btn btn-small" onclick="downloadReportHTML()" style="background:#1565c0;">Report</button>
              <button class="btn btn-small" id="btnDiscoverTerms" onclick="discoverMatrixTerms()" style="background:#2e7d32;" title="Find all dictionary-validated ELS terms in this matrix region">Discover</button>
              <span style="display:inline-flex;gap:6px;align-items:center;font-size:11px;color:#ddd;">
                <label style="cursor:pointer;color:#ddd;" title="Show all dictionary terms"><input type="checkbox" id="discFilterAll" checked onchange="applyDiscoverFilter()"> All</label>
                <label style="cursor:pointer;color:#ddd;" title="Show only names"><input type="checkbox" id="discFilterNames" onchange="applyDiscoverFilter()"> Names</label>
                <label style="cursor:pointer;color:#ddd;" title="Show only dates/numbers"><input type="checkbox" id="discFilterDates" onchange="applyDiscoverFilter()"> Dates</label>
              </span>
            </div>
          </div>
          <div id="scanMatrixStats" class="matrix-stats"></div>
          <div id="videoControlPanel" style="display:none;">
            <div class="vid-row">
              <button class="vid-btn vid-btn-rec" id="vidRecBtn" onclick="vidToggleRecord()">Record</button>
              <button class="vid-btn vid-btn-frame" onclick="vidCaptureFrame()" title="Capture single frame">+ Frame</button>
              <button class="vid-btn vid-btn-frame" onclick="vidStepRotation(-1)" title="Step back 5 degrees">&#9664; Step</button>
              <button class="vid-btn vid-btn-frame" onclick="vidStepRotation(1)" title="Step forward 5 degrees">Step &#9654;</button>
              <span id="vidStatus">Ready</span>
              <span class="vid-label" style="margin-left:8px;">Format:</span>
              <select id="vidFormatSelect" title="Select format BEFORE recording" style="font-size:13px;">
              </select>
              <span class="vid-label" style="margin-left:4px;">FPS:</span>
              <select id="vidFPSSelect" style="font-size:13px;">
                <option value="24">24</option>
                <option value="30" selected>30</option>
                <option value="60">60</option>
              </select>
              <!-- MP4 conversion removed: ffmpeg.wasm too heavy (32MB download + slow WASM encode) -->
              <button class="vid-btn vid-btn-dl" id="vidDownloadBtn" onclick="vidDownload()" style="display:none;">Download</button>
            </div>
            <div class="vid-row">
              <span class="vid-label">Timeline:</span>
              <input type="range" id="vidTimeline" min="0" max="100" value="0" step="1" oninput="vidSeekTimeline(this.value)" disabled>
              <span class="vid-label" id="vidTimeDisplay">0:00 / 0:00</span>
              <span class="vid-label" style="margin-left:8px;">Speed:</span>
              <input type="range" id="vidSpeedSlider" min="0" max="5" value="1" step="0.1" oninput="vidSetSpeed(this.value)" style="width:80px;">
              <span class="vid-label" id="vidSpeedLabel">1.0x</span>
            </div>
          </div>
          <div id="scanMatrix2D">
            <div class="matrix-container" id="scanMatrixContainer" style="max-height:calc(100dvh - 250px);">
              <div class="matrix-grid" id="scanMatrixGrid"></div>
            </div>
          </div>
          <div id="scanMatrix3D" style="display:none;">
            <div class="matrix-3d-container" id="matrix3DCanvas">
              <div id="matrix3DTooltip"></div>
            </div>
            <div id="matrix3DInfo" style="display:none;"></div>
          </div><!-- /scanMatrix3D -->
          <div class="matrix-legend" id="scanMatrixLegend"></div>
          <div id="verseContextPanel" style="display:none;margin-top:8px;border:1px solid #37474f;border-radius:8px;padding:10px;background:#1a2332;color:#cfd8dc;font-size:13px;">
            <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;" onclick="this.parentElement.classList.toggle('collapsed');this.querySelector('.vc-arrow').textContent=this.parentElement.classList.contains('collapsed')?'\u25B6':'\u25BC';">
              <span style="font-weight:bold;color:#90caf9;font-size:13px;">Verse Context Analysis</span>
              <span class="vc-arrow" style="color:#90caf9;font-size:11px;">\u25BC</span>
            </div>
            <div id="verseContextBody" style="margin-top:6px;border-top:1px solid #37474f;padding-top:6px;"></div>
          </div>
          <div id="discoverTermsPanel" style="display:none;margin-top:12px;border:1px solid #ddd;border-radius:8px;padding:12px;background:#f9f9f9;color:#000;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
              <h4 style="margin:0;font-size:14px;color:#000;">Discovered ELS Terms in Matrix Region</h4>
              <span id="discoverTermsStatus" style="font-size:12px;color:#444;"></span>
            </div>
            <div id="discoverTermsResults" style="max-height:500px;overflow-y:auto;"></div>
          </div>
        </div>
      </section>
    </div>

    <!-- DICTIONARY MODE -->
    <div id="dict-mode" class="mode-content">
      <section class="section">
        <h2>References & Texts</h2>

        <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px;margin-bottom:20px;">
          <a href="test-dictionaries.html" style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--green);text-decoration:none;display:block;cursor:pointer;">
            <strong style="color:var(--blue);">Hebrew Dictionary</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">BDB, Strong's, 260K words</p>
            <span style="font-size:11px;color:var(--green);">Active</span>
          </a>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Mikraot Gedolot</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Rashi, Ibn Ezra, Ramban, etc.</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Talmud Bavli</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Babylonian Talmud full text</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Mishna</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Six orders, full text</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Zohar</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Mystical commentary</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
          <div style="padding:16px;background:var(--gray-light);border-radius:8px;border-left:4px solid var(--blue);">
            <strong style="color:var(--blue);">Midrash</strong>
            <p style="font-size:13px;color:var(--gray);margin:6px 0 0;">Midrash Rabbah, Tanchuma</p>
            <span style="font-size:11px;color:var(--orange);">Planned</span>
          </div>
        </div>

        <p style="font-size:13px;color:var(--gray);">Cross-reference and search across classical Hebrew texts. Data sourced from Sefaria and open-access repositories.</p>
      </section>
    </div>

    <!-- WRR 1994 MODE -->
    <div id="wrr-mode" class="mode-content">
      <section class="section">
        <h2 style="display:flex;align-items:center;gap:10px;">
          WRR 1994 Experiment
          <span style="font-size:12px;padding:3px 8px;background:linear-gradient(135deg,#667eea,#764ba2);color:white;border-radius:12px;">Academic Replication</span>
        </h2>
        <p id="wrrDescription" style="font-size:14px;color:var(--gray);margin-bottom:16px;">
          Replication of the famous experiment by Witztum, Rips &amp; Rosenberg published in
          <em>Statistical Science</em> (1994). 32 rabbis from the <em>Encyclopedia of Great Men in Israel</em>,
          each paired with Hebrew death dates. The proximity of name-date ELS pairs in Genesis was found to be
          statistically significant at <strong>p = 0.000016</strong> (1 in 62,500).
        </p>

        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:20px;">
          <div style="background:linear-gradient(135deg,#667eea22,#764ba222);padding:14px;border-radius:8px;text-align:center;">
            <div style="font-size:28px;font-weight:bold;color:var(--blue);" id="wrrStatRabbis">32</div>
            <div style="font-size:12px;color:var(--gray);" id="wrrStatRabbisLabel">Rabbis (List 2)</div>
          </div>
          <div style="background:linear-gradient(135deg,#667eea22,#764ba222);padding:14px;border-radius:8px;text-align:center;">
            <div style="font-size:28px;font-weight:bold;color:var(--blue);">78,064</div>
            <div style="font-size:12px;color:var(--gray);" id="wrrStatTextLabel">Letters in Genesis</div>
          </div>
          <div style="background:linear-gradient(135deg,#667eea22,#764ba222);padding:14px;border-radius:8px;text-align:center;">
            <div style="font-size:28px;font-weight:bold;color:var(--blue);" id="wrrStatPValue">p &lt; 1/62,500</div>
            <div style="font-size:12px;color:var(--gray);" id="wrrStatPLabel">Published P-value (List 2)</div>
          </div>
        </div>

        <!-- List & Text selectors -->
        <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;align-items:center;">
          <label style="font-size:13px;color:var(--gray);display:flex;align-items:center;gap:4px;">
            Dataset:
            <select id="wrrListSelect" onchange="wrrSwitchList(this.value)" style="padding:4px 8px;border:1px solid var(--border);border-radius:4px;font-size:13px;">
              <option value="list2" selected>List 2 (32 rabbis)</option>
              <option value="list1">List 1 (34 rabbis)</option>
              <option value="nations">Nations B3 (68 nations)</option>
            </select>
          </label>
          <label style="font-size:13px;color:var(--gray);display:flex;align-items:center;gap:4px;">
            Text:
            <select id="wrrTextSelect" onchange="wrrSwitchText(this.value)" style="padding:4px 8px;border:1px solid var(--border);border-radius:4px;font-size:13px;">
              <option value="genesis" selected>Genesis (Koren)</option>
              <option value="tolstoy">War and Peace (Tolstoy)</option>
            </select>
          </label>
          <span id="wrrTextNote" style="font-size:11px;color:#999;"></span>
        </div>

        <!-- Controls -->
        <div style="display:flex;gap:10px;margin-bottom:16px;flex-wrap:wrap;align-items:center;">
          <button class="btn" id="wrrRunBtn" onclick="runWRRExperiment()" style="background:linear-gradient(135deg,#667eea,#764ba2);font-size:15px;padding:10px 24px;">
            Quick Run
          </button>
          <button class="btn" id="wrrFullBtn" onclick="wrrRunFullExperiment()" style="background:linear-gradient(135deg,#1b5e20,#388e3c);font-size:15px;padding:10px 24px;color:#fff;border:none;border-radius:6px;cursor:pointer;" title="Full WRR replication with c(w,w') perturbation statistic, P&#8321;-P&#8324;">
            Run Full WRR (c statistic)
          </button>
          <button class="btn btn-secondary" id="wrrCancelBtn" onclick="cancelWRR()" style="display:none;">Cancel</button>
          <label style="font-size:13px;color:var(--gray);display:flex;align-items:center;gap:4px;" title="Maximum |skip| searched per term. Higher = more thorough but slower.">
            Skip cap:
            <input type="number" id="wrrSkipCap" value="1000" min="100" max="10000" step="100"
              style="width:80px;padding:4px 6px;border:1px solid var(--border);border-radius:4px;font-size:13px;">
          </label>
          <span id="wrrProgress" style="font-size:13px;color:var(--gray);"></span>
        </div>

        <!-- Progress bar -->
        <div id="wrrProgressBar" style="display:none;margin-bottom:16px;">
          <div style="background:#eee;border-radius:4px;height:8px;overflow:hidden;">
            <div id="wrrProgressFill" style="background:linear-gradient(90deg,#667eea,#764ba2);height:100%;width:0%;transition:width 0.3s;border-radius:4px;"></div>
          </div>
          <div id="wrrProgressText" style="font-size:12px;color:var(--gray);margin-top:4px;"></div>
        </div>

        <!-- Results summary -->
        <div id="wrrSummary" style="display:none;margin-bottom:16px;padding:16px;background:linear-gradient(135deg,#e8f5e9,#c8e6c9);border-radius:8px;border:1px solid #a5d6a7;">
        </div>

        <!-- Rabbi table -->
        <div style="margin-bottom:8px;font-weight:600;color:var(--blue);" id="wrrTableLabel">Rabbi List (WRR List 2)</div>
        <div style="overflow-x:auto;max-height:500px;overflow-y:auto;border:1px solid var(--border);border-radius:6px;">
          <table id="wrrTable" style="width:100%;border-collapse:collapse;font-size:13px;">
            <thead style="position:sticky;top:0;background:var(--blue);color:white;z-index:1;">
              <tr>
                <th style="padding:8px 4px;text-align:center;font-weight:600;">#</th>
                <th style="padding:8px 4px;text-align:left;font-weight:600;" id="wrrColSubject">Rabbi</th>
                <th style="padding:8px 4px;text-align:right;font-weight:600;direction:rtl;" id="wrrColNames">Appellations</th>
                <th style="padding:8px 4px;text-align:right;font-weight:600;direction:rtl;" id="wrrColSecondary">Date</th>
                <th style="padding:8px 4px;text-align:center;font-weight:600;">Pairs</th>
                <th style="padding:8px 4px;text-align:center;font-weight:600;" title="Dynamic max |skip| searched (based on expected ELS occurrences)">D(w)</th>
                <th style="padding:8px 4px;text-align:center;font-weight:600;" title="Quick Run: Δ = min 2D distance. Full WRR: c(w,w') = perturbation rank (0..1, lower = more significant)" id="wrrColHeader">&Delta;</th>
              </tr>
            </thead>
            <tbody id="wrrTableBody"></tbody>
          </table>
        </div>

        <!-- Methodology -->
        <details style="margin-top:16px;">
          <summary style="cursor:pointer;font-weight:600;color:var(--blue);font-size:14px;">Methodology Details</summary>
          <div style="padding:12px;font-size:13px;color:#555;line-height:1.7;">
            <p><strong>Source:</strong> Witztum, Rips &amp; Rosenberg, &ldquo;Equidistant Letter Sequences in the Book of Genesis&rdquo;,
            <em>Statistical Science</em>, Vol. 9, No. 3, August 1994, pp. 429&ndash;438.</p>
            <p><strong>Text:</strong> Genesis (Koren edition), 78,064 consonantal Hebrew letters. Final letter forms (sofiot)
            normalized to standard forms for matching.</p>
            <p><strong>ELS Definition:</strong> For skip value d (|d| &ge; 2), letters at positions h, h+d, h+2d, &hellip;, h+(n&minus;1)d.
            Skip &plusmn;1 (open text) is excluded per the WRR protocol.</p>
            <p><strong>Skip Range D(w):</strong> Dynamic per term. For word w of length k with letter probabilities p<sub>i</sub>,
            expected ELS count at skip d: E(w,d) = (L &minus; (k&minus;1)d) &sdot; &prod;p<sub>i</sub>.
            D(w) is the smallest d where &sum;<sub>d=2..D</sub> E(w,d) &ge; 10, capped at user maximum.</p>
            <p><strong>Distance &Delta;:</strong> Text arranged as 2D array with |d| columns. Position p maps to
            row&nbsp;=&nbsp;&lfloor;p/|d|&rfloor;, col&nbsp;=&nbsp;p&nbsp;mod&nbsp;|d|.
            &Delta; = min Euclidean distance between any name-ELS letter and any date-ELS letter.
            Both array widths (|d<sub>name</sub>| and |d<sub>date</sub>|) tested; smaller distance reported.</p>
            <p><strong>Original significance:</strong> 999,999 random permutations of name-date assignments tested.
            Actual assignment ranked 4th of 1,000,000, yielding <strong>p &lt; 1/62,500</strong>.</p>
            <p><strong>This replication:</strong> Two modes available:
            <em>Quick Run</em> uses the 2D cylindrical proximity measure with dynamic D(w) and
            both forward and backward ELS (|d|&nbsp;&ge;&nbsp;2).
            <em>Full WRR</em> additionally computes the <strong>c(w,w&prime;) perturbation statistic</strong>:
            125 spatial perturbations (triples (x,y,z) &isin; {&minus;2..2}&sup3;) shift the last 3 ELS letter positions
            by cumulative (x, x+y, x+y+z). Proximity &omega; = max(1/&delta;) across 10 row lengths
            h<sub>i</sub>&nbsp;=&nbsp;round(|d|/i). Then P&#8321; (binomial tail on c&lt;0.2 count) and
            P&#8322; (Gamma CDF on &prod;c) yield the overall statistic P&nbsp;=&nbsp;2&middot;min(P&#8321;,P&#8322;).</p>
            <p><strong>Data:</strong> Appellations and dates from WRR Table 3 (Appendix). Rabbis #4 and #8
            excluded&mdash;no recorded death dates.</p>
          </div>
        </details>
      </section>
    </div>

    <!-- DATE MAP MODE -->
    <div id="datemap-mode" class="mode-content">
      <section class="section" style="padding:4px;">
        <h2 style="display:flex;align-items:center;gap:10px;">
          Hebrew Date ELS Density Map
          <span style="font-size:12px;padding:3px 8px;background:linear-gradient(135deg,#f093fb,#f5576c);color:white;border-radius:12px;">Pre-computed</span>
        </h2>
        <p style="font-size:13px;color:var(--gray);margin-bottom:12px;">
          ELS density heatmap for all Hebrew calendar dates and years across the Koren Edition Torah (304,805 letters).
          Each cell aggregates equidistant letter sequences encoding that date across all skip values.
        </p>
        <div style="font-size:11px;color:var(--gray);margin-bottom:10px;line-height:1.5;">
          <span style="cursor:help;text-decoration:underline dotted;" title="Generated by tools/build-date-els-index.py. Searches ~652 Hebrew date terms across all skip distances in the 304,805-letter Koren Torah text (same text used by Witztum, Rips & Rosenberg, 1994). Sofiot (final letters) normalized to regular forms for matching.">&#x2139; How it works</span>
          &nbsp;|&nbsp;
          <span style="cursor:help;text-decoration:underline dotted;" title="14 months searched: 12 standard (Tishrei–Elul) + Adar I (אדרא, leap-year first Adar) + Adar II (אדרב, leap-year second Adar). Variant spellings also searched: חשוון for Cheshvan, אדרראשון for Adar I, אדרשני for Adar II.">&#x1F4C5; 14 Months</span>
          &nbsp;|&nbsp;
          <span style="cursor:help;text-decoration:underline dotted;" title="Days 15 and 16 are searched in BOTH forms: Standard (טו/טז — avoids spelling the divine name) and Mathematical (יה/יו — pure gematria values). ELS sequences follow letter values, not typographic convention, so both forms are valid.">&#x1F522; Dual 15/16 forms</span>
          &nbsp;|&nbsp;
          <span style="cursor:help;text-decoration:underline dotted;" title="Year values 5700–5799 (~1940–2039 CE). Hebrew year encoding drops the millennia digit (5): e.g., 5786 → תשפו (400+300+80+6). Uses standard convention where 15→טו, 16→טז.">&#x1F4C6; Years 5700–5799</span>
        </div>

        <!-- Stats cards -->
        <div class="dm-stats" id="dmStats" style="display:none;">
          <div class="dm-stat-card">
            <div class="dm-stat-val" id="dmStatTerms">—</div>
            <div class="dm-stat-label">Date Terms</div>
          </div>
          <div class="dm-stat-card">
            <div class="dm-stat-val" id="dmStatHits">—</div>
            <div class="dm-stat-label">Total ELS Hits</div>
          </div>
          <div class="dm-stat-card">
            <div class="dm-stat-val" id="dmStatSkip">—</div>
            <div class="dm-stat-label">Skip Range</div>
          </div>
        </div>

        <!-- No-data message (shown when index not loaded) -->
        <div id="dmNoData" class="dm-nodata">
          <p>Date ELS index not loaded yet.</p>
          <p>Generate it with: <code>python3 tools/build-date-els-index.py</code></p>
          <p style="margin-top:8px;font-size:12px;">Or compute in-browser (slower):</p>
          <button class="btn btn-secondary dm-compute-btn" onclick="dmComputeInBrowser()">
            Compute Date Map Now
          </button>
          <div id="dmComputeProgress" style="display:none;margin-top:8px;font-size:12px;color:var(--gray);"></div>
        </div>

        <!-- Day × Month Heatmap -->
        <div class="dm-section" id="dmHeatmapSection" style="display:none;">
          <h3>Day × Month Heatmap <span style="cursor:help;font-size:11px;font-weight:normal;text-decoration:underline dotted;color:var(--gray);" title="14 rows (months) × 30 columns (days). Each cell's color intensity = log-scaled ELS hit count. Days 15/16 aggregate both standard (טו/טז) and mathematical (יה/יו) forms. Adar appears 3 times: non-leap Adar, leap Adar I, leap Adar II. Click any cell for details.">?</span></h3>
          <div class="dm-legend">
            <span>Fewer ELS</span>
            <div class="dm-legend-bar" style="background:linear-gradient(to right,#1a1a2e,#16213e,#0f3460,#533483,#e94560,#ff6b6b);"></div>
            <span>More ELS</span>
          </div>
          <div class="dm-heatmap-wrap">
            <table class="dm-heatmap" id="dmHeatmapTable"></table>
          </div>
        </div>

        <!-- Month Summary -->
        <div class="dm-section" id="dmMonthSection" style="display:none;">
          <h3>Month Summary <span style="cursor:help;font-size:11px;font-weight:normal;text-decoration:underline dotted;color:var(--gray);" title="ELS hits for standalone month names. Includes variant spellings (e.g., חשוון for Cheshvan). Hit count reflects how many times the month name itself appears as an equidistant letter sequence in the Torah.">?</span></h3>
          <div class="dm-month-bar" id="dmMonthBar"></div>
        </div>

        <!-- Year Timeline -->
        <div class="dm-section" id="dmYearSection" style="display:none;">
          <h3>Year Timeline (5700–5799) <span style="cursor:help;font-size:11px;font-weight:normal;text-decoration:underline dotted;color:var(--gray);" title="Hebrew years 5700–5799 (~1940–2039 CE). Each year encoded as Hebrew letters: drop the 5000, encode remainder. E.g., 5786 → תשפו (ת=400, ש=300, פ=80, ו=6). Color = ELS density. Click for details.">?</span></h3>
          <div class="dm-legend">
            <span>Fewer ELS</span>
            <div class="dm-legend-bar" style="background:linear-gradient(to right,#1a1a2e,#16213e,#0f3460,#533483,#e94560,#ff6b6b);"></div>
            <span>More ELS</span>
          </div>
          <div class="dm-year-grid" id="dmYearGrid"></div>
        </div>

        <!-- Detail panel -->
        <div id="dmDetail">
          <h4 id="dmDetailTitle">—</h4>
          <div style="display:flex;gap:8px;margin-bottom:8px;">
            <span id="dmDetailCount" style="font-size:13px;color:var(--gray);"></span>
            <span id="dmDetailMinSkip" style="font-size:13px;color:var(--gray);"></span>
          </div>
          <div class="dm-hits-list" id="dmDetailHits"></div>
          <div style="margin-top:8px;">
            <button class="btn btn-secondary btn-small" id="dmSearchInScan" onclick="dmTransferToScan()">Search in Full Scan</button>
            <button class="btn btn-secondary btn-small" style="margin-left:6px;" onclick="dmExportCSV()">Export CSV</button>
          </div>
        </div>
      </section>
    </div>
  </main>

  <div id="verseTooltip"></div>

  <script type="module">
    // Dynamic imports — if these fail, the rest of the module still executes
    let getElsIndexService, initElsIndex, getDictionaryService, initDictionaries;
    try {
      const m1 = await import('./engines/els-index.js');
      getElsIndexService = m1.getElsIndexService;
      initElsIndex = m1.initElsIndex;
    } catch (e) {
      console.error('Failed to import els-index.js:', e);
    }
    try {
      const m2 = await import('./engines/dictionary-service.js');
      getDictionaryService = m2.getDictionaryService;
      initDictionaries = m2.initDictionaries;
    } catch (e) {
      console.error('Failed to import dictionary-service.js:', e);
    }
    window._moduleLoaded = true;

    let elsService = null;
    let dictService = null;
    let torahText = null;
    let currentResults = null;

    // ============= MODE SWITCHING =============
    document.querySelectorAll('.mode-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.mode + '-mode').classList.add('active');
        // Lazy-load 32MB ELS index only when Index Lookup tab is first activated
        if (tab.dataset.mode === 'index') initIndexTab();
      });
    });

    // ============= TWO-COLUMN LAYOUT: Move matrix view into left column =============
    {
      const anchor = document.getElementById('scanMatrixViewAnchor');
      const matrixView = document.getElementById('scanMatrixView');
      if (anchor && matrixView) {
        anchor.parentNode.insertBefore(matrixView, anchor);
        anchor.remove();
      }
    }

    // ============= INIT =============

    // Core init: loads Torah text (needed by Scan tab, the default)
    async function init() {
      try {
        document.getElementById('loadProgress').textContent = 'Loading Torah text...';
        const resp = await fetch('data/torahNoSpaces.txt');
        torahText = await resp.text();

        // Show Torah text preview (placeholder until charDB loads with real word spaces)
        const preview = document.getElementById('torahTextPreview');
        if (preview && torahText && !preview.dataset.wordsLoaded) {
          let display = '';
          for (let i = 0; i < torahText.length; i += 5) {
            display += torahText.slice(i, i + 5) + ' ';
          }
          preview.textContent = display;
        }

        // Load character database in background for word-spaced preview
        loadCharDB().catch(() => {});

        document.getElementById('loadProgress').style.display = 'none';

      } catch (error) {
        console.error('Init failed:', error);
        document.getElementById('loadProgress').textContent = 'Error loading Torah text.';
      }
    }

    // Lazy init for Index Lookup tab: loads the 32MB ELS index only when needed
    let indexInitDone = false;
    async function initIndexTab() {
      if (indexInitDone) return;
      indexInitDone = true;
      try {
        document.getElementById('loadProgress').style.display = 'block';
        document.getElementById('loadProgress').textContent = 'Loading ELS index (32MB)...';
        if (!initElsIndex) throw new Error('ELS index module not available — try reloading the page');
        const metadata = await initElsIndex('data/els-index/els-index-50-min4.json.gz');
        elsService = getElsIndexService();

        document.getElementById('indexLoading').style.display = 'none';
        document.getElementById('indexContent').style.display = 'block';

        displayStats(metadata);
        loadSavedSessions();

        // Auto-restore previous session
        try {
          await autoRestoreSession();
        } catch (e) {
          console.warn('Auto-restore failed:', e);
        }
      } catch (error) {
        console.error('ElsIndex init failed:', error);
        document.getElementById('indexLoading').innerHTML =
          `<div style="color: red;">Error loading index: ${error.message}</div>`;
      }
    }

    async function autoRestoreSession() {
      const raw = localStorage.getItem('elsAutoSession');
      if (!raw) return;
      try {
        const s = JSON.parse(raw);
        if (!s.terms || s.terms.length === 0) return;

        scanTerms = s.terms;
        scanClusters = s.clusters || [];
        clusterPValues = s.clusterPValues || [];
        permSpanDistribution = s.permSpanDistribution || null;
        currentSelectedClusterIdx = s.selectedClusterIdx || 0;

        // Restore skip range
        if (s.skipRange) {
          const minEl = document.getElementById('minSkip');
          const maxEl = document.getElementById('maxSkip');
          if (minEl) minEl.value = s.skipRange[0];
          if (maxEl) maxEl.value = s.skipRange[1];
        }

        // Restore textarea and batch terms
        const ta = document.getElementById('batchTextarea');
        if (ta) {
          ta.value = s.terms.join('\n');
          parseBatchInput();
        }

        // Load hits from IndexedDB
        const status = document.getElementById('scanStatus');
        if (status) status.textContent = 'Restoring session...';
        try {
          scanAllResults = await readAllFromScanDB(s.terms);
        } catch (e) {
          scanAllResults = {};
          for (const t of s.terms) scanAllResults[t] = [];
        }

        await loadCharDB();
        displayScanResults(scanTerms, scanAllResults, scanClusters);

        // Restore discovered terms
        if (s.discoveredResults) discoveredResults = s.discoveredResults;

        // Restore selected cluster and matrix
        if (scanClusters.length > 0) {
          showClusterMatrix(currentSelectedClusterIdx);
          if (discoveredResults.length > 0) {
            const panel = document.getElementById('discoverTermsPanel');
            if (panel) panel.style.display = 'block';
            renderDiscoveredResults();
          }
        }

        // Update auto-save status indicator
        const autoEl = document.getElementById('autoSaveStatus');
        if (autoEl && s.savedAt) {
          autoEl.textContent = 'Restored from ' + new Date(s.savedAt).toLocaleTimeString();
        }

        if (status) status.textContent = '';
      } catch (e) {
        console.warn('Auto-restore failed:', e);
      }
    }

    function displayStats(meta) {
      document.getElementById('statsGrid').innerHTML = `
        <div class="stat-box"><div class="value">${meta.total_words?.toLocaleString() || '?'}</div><div class="label">Words</div></div>
        <div class="stat-box"><div class="value">${meta.total_occurrences?.toLocaleString() || '?'}</div><div class="label">Occurrences</div></div>
        <div class="stat-box"><div class="value">±${meta.skip_range?.[1] || '?'}</div><div class="label">Skip Range</div></div>
        <div class="stat-box"><div class="value">${meta.torah_length?.toLocaleString() || '?'}</div><div class="label">Letters</div></div>
      `;
    }

    // ============= INDEX MODE: TERM MANAGEMENT =============
    window.addTerm = function() {
      const container = document.getElementById('termEntries');
      const n = container.querySelectorAll('.term-entry').length + 1;
      const div = document.createElement('div');
      div.className = 'term-entry';
      div.innerHTML = `<input type="text" class="term-input" placeholder="Term ${n}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
      container.appendChild(div);
    };

    window.removeTerm = function(btn) {
      const container = document.getElementById('termEntries');
      if (container.querySelectorAll('.term-entry').length > 1) {
        btn.parentElement.remove();
      }
    };

    // ============= INDEX MODE: SEARCH =============
    window.searchIndex = function() {
      const inputs = document.querySelectorAll('.term-input');
      const terms = Array.from(inputs).map(i => i.value.trim()).filter(t => t);

      if (terms.length < 1) { alert('Enter at least one term'); return; }

      const termData = {};
      for (const term of terms) {
        const occs = elsService.findWord(term);
        termData[term] = { occurrences: occs, count: occs.length };
      }

      // Compute proximity pairs if multiple terms
      const proximityPairs = [];
      if (terms.length > 1) {
        for (let i = 0; i < terms.length; i++) {
          for (let j = i + 1; j < terms.length; j++) {
            const prox = elsService.pairProximity(terms[i], terms[j]);
            if (prox) {
              proximityPairs.push({
                term1: terms[i], term2: terms[j],
                distance: prox.distance,
                pos1: prox.word1.pos, skip1: prox.word1.skip,
                pos2: prox.word2.pos, skip2: prox.word2.skip
              });
            }
          }
        }
        proximityPairs.sort((a, b) => a.distance - b.distance);
      }

      currentResults = { terms, termData, proximityPairs, timestamp: new Date().toISOString() };
      displayIndexResults(currentResults);
    };

    function displayIndexResults(results) {
      const { terms, termData, proximityPairs } = results;

      let html = '<div class="results"><h3>Term Occurrences</h3>';
      html += '<table class="results-table"><tr><th>Term</th><th>Count</th><th>First Pos</th></tr>';
      for (const term of terms) {
        const d = termData[term];
        const firstPos = d.occurrences[0]?.pos ?? 'N/A';
        html += `<tr><td><strong>${term}</strong></td><td>${d.count.toLocaleString()}</td><td>${typeof firstPos === 'number' ? firstPos.toLocaleString() : firstPos}</td></tr>`;
      }
      html += '</table>';

      if (terms.length > 1) {
        // Proximity matrix
        const { matrix } = elsService.computeProximityMatrix(terms);
        html += '<h3 style="margin-top:20px;">Proximity Matrix</h3><div class="proximity-matrix"><table><tr><th></th>';
        terms.forEach(t => html += `<th>${t}</th>`);
        html += '</tr>';
        for (let i = 0; i < terms.length; i++) {
          html += `<tr><th>${terms[i]}</th>`;
          for (let j = 0; j < terms.length; j++) {
            const d = matrix[i][j];
            const cls = d === 0 ? '' : d < 500 ? 'cell-close' : d < 2000 ? 'cell-medium' : 'cell-far';
            html += `<td class="${cls}">${d === Infinity ? '∞' : d.toLocaleString()}</td>`;
          }
          html += '</tr>';
        }
        html += '</table></div>';

        // Pair details
        html += `<h3 style="margin-top:20px;">Proximity Pairs (${proximityPairs.length})</h3>`;
        html += '<div class="results-scrollable"><table class="results-table">';
        html += '<tr><th>#</th><th>Term 1</th><th>Term 2</th><th>Distance</th><th>Pos 1</th><th>Skip 1</th><th>Pos 2</th><th>Skip 2</th></tr>';
        proximityPairs.forEach((p, idx) => {
          const cls = p.distance < 500 ? 'cell-close' : p.distance < 2000 ? 'cell-medium' : 'cell-far';
          html += `<tr class="clickable-row" onclick="showIndexMatrix(${idx})" data-idx="${idx}">
            <td>${idx + 1}</td><td>${sanitizeSacredNames(p.term1)}</td><td>${sanitizeSacredNames(p.term2)}</td>
            <td class="${cls}">${p.distance.toLocaleString()}</td>
            <td>${p.pos1.toLocaleString()}</td><td>${p.skip1}</td>
            <td>${p.pos2.toLocaleString()}</td><td>${p.skip2}</td>
          </tr>`;
        });
        html += '</table></div>';

        // Matrix view area
        html += `<div id="indexMatrixView" class="matrix-view">
          <h3>Matrix View</h3>
          <p class="hint">Click a row above to view the matrix.</p>
          <div id="indexMatrixDisplay"></div>
        </div>`;
      }

      html += '</div>';
      document.getElementById('indexResults').innerHTML = html;
    }

    window.showIndexMatrix = function(idx) {
      if (!currentResults || !torahText) return;
      const pair = currentResults.proximityPairs[idx];
      if (!pair) return;

      document.querySelectorAll('.clickable-row').forEach(r => r.classList.remove('selected'));
      document.querySelector(`.clickable-row[data-idx="${idx}"]`)?.classList.add('selected');

      // Use skip value as width for proper alignment, or default to 30
      const width = Math.max(Math.abs(pair.skip1), Math.abs(pair.skip2), 30);

      const t1Pos = new Set();
      const t2Pos = new Set();
      for (let i = 0; i < pair.term1.length; i++) t1Pos.add(pair.pos1 + i * pair.skip1);
      for (let i = 0; i < pair.term2.length; i++) t2Pos.add(pair.pos2 + i * pair.skip2);

      // Compute row range from actual term positions (with context padding)
      const allTermPositions = [...t1Pos, ...t2Pos];
      const padding = 3;
      const startRow = Math.max(0, Math.floor(Math.min(...allTermPositions) / width) - padding);
      const endRow = Math.floor(Math.max(...allTermPositions) / width) + padding;

      // Build grid-based matrix like the popup
      let gridHtml = '';
      for (let row = startRow; row <= endRow; row++) {
        const rowStart = row * width;
        if (rowStart < 0) continue;
        for (let col = 0; col < width; col++) {
          const pos = rowStart + col;
          if (pos >= torahText.length) break;
          const ch = torahText[pos];
          const in1 = t1Pos.has(pos), in2 = t2Pos.has(pos);
          let cls = 'matrix-cell';
          if (in1 && in2) cls += ' term1 term2';
          else if (in1) cls += ' term1';
          else if (in2) cls += ' term2';
          gridHtml += `<div class="${cls}">${ch}</div>`;
        }
      }

      const statsHtml = `
        <div class="matrix-stats" style="margin-bottom:15px;">
          <div class="matrix-stat"><div class="value" style="color:#ffc107;">${sanitizeSacredNames(pair.term1)}</div><div class="label">Term 1</div></div>
          <div class="matrix-stat"><div class="value" style="color:#00bcd4;">${sanitizeSacredNames(pair.term2)}</div><div class="label">Term 2</div></div>
          <div class="matrix-stat"><div class="value">${pair.distance.toLocaleString()}</div><div class="label">Distance</div></div>
          <div class="matrix-stat"><div class="value">${pair.skip1}</div><div class="label">Skip 1</div></div>
          <div class="matrix-stat"><div class="value">${pair.skip2}</div><div class="label">Skip 2</div></div>
          <div class="matrix-stat"><div class="value">${pair.pos1.toLocaleString()}</div><div class="label">Pos 1</div></div>
          <div class="matrix-stat"><div class="value">${pair.pos2.toLocaleString()}</div><div class="label">Pos 2</div></div>
        </div>
        <div class="matrix-container" style="max-height:400px;">
          <div class="matrix-grid" style="grid-template-columns:repeat(${width}, 26px);">${gridHtml}</div>
        </div>
        <div class="matrix-legend" style="margin-top:15px;">
          <div class="legend-item"><div class="legend-color t1"></div><span>${sanitizeSacredNames(pair.term1)}</span></div>
          <div class="legend-item"><div class="legend-color t2"></div><span>${sanitizeSacredNames(pair.term2)}</span></div>
          <div class="legend-item"><div class="legend-color both"></div><span>Overlap</span></div>
        </div>
      `;

      document.getElementById('indexMatrixDisplay').innerHTML = statsHtml;

      // Set current3DHits for index mode (convert pair to hits format)
      current3DHits = [
        { pos: pair.pos1, skip: pair.skip1, term: pair.term1, termIdx: 0 },
        { pos: pair.pos2, skip: pair.skip2, term: pair.term2, termIdx: 1 }
      ];
    };

    // ============= INDEX MODE: SESSIONS =============
    window.saveSession = function() {
      if (!currentResults) { alert('No results to save'); return; }
      const name = `Search ${new Date().toLocaleTimeString()}`;
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      sessions.unshift({ name, results: currentResults, savedAt: new Date().toISOString() });
      if (sessions.length > 20) sessions.length = 20;
      localStorage.setItem('elsSearchSessions', JSON.stringify(sessions));
      loadSavedSessions();
    };

    window.loadSession = function(idx) {
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      if (!sessions[idx]) return;
      const session = sessions[idx];
      currentResults = session.results;
      const container = document.getElementById('termEntries');
      container.innerHTML = '';
      session.results.terms.forEach(term => {
        const div = document.createElement('div');
        div.className = 'term-entry';
        div.innerHTML = `<input type="text" class="term-input" value="${term}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
        container.appendChild(div);
      });
      displayIndexResults(currentResults);
    };

    window.deleteSession = function(idx) {
      if (!confirm('Delete session?')) return;
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      sessions.splice(idx, 1);
      localStorage.setItem('elsSearchSessions', JSON.stringify(sessions));
      loadSavedSessions();
    };

    function loadSavedSessions() {
      const sessions = JSON.parse(localStorage.getItem('elsSearchSessions') || '[]');
      const container = document.getElementById('savedSessions');
      if (sessions.length === 0) {
        container.innerHTML = '<p style="font-size: 12px; color: #666; margin-top: 10px;">No saved sessions</p>';
        return;
      }
      let html = '';
      sessions.forEach((s, i) => {
        html += `<div class="saved-item">
          <div><span class="name">${s.name}</span><br><span class="meta">${s.results.terms.join(', ')}</span></div>
          <div><button class="btn btn-small btn-secondary" onclick="loadSession(${i})">Load</button>
          <button class="btn btn-small btn-danger" onclick="deleteSession(${i})">×</button></div>
        </div>`;
      });
      container.innerHTML = html;
    }

    window.exportResults = function() {
      if (!currentResults) { alert('No results'); return; }
      const blob = new Blob([JSON.stringify(currentResults, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = `els-search-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    };

    window.clearSession = function() {
      if (!confirm('Clear all?')) return;
      document.getElementById('termEntries').innerHTML = `
        <div class="term-entry"><input type="text" class="term-input" placeholder="Term 1" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button></div>
        <div class="term-entry"><input type="text" class="term-input" placeholder="Term 2" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button></div>`;
      document.getElementById('indexResults').innerHTML = '';
      currentResults = null;
    };

    // ============= SCAN MODE =============
    const TERM_COLORS = ['#ffc107','#00bcd4','#ff5722','#4caf50','#e91e63','#3f51b5','#795548','#607d8b'];
    const BOOK_NAMES = {
      1:'Genesis',2:'Exodus',3:'Leviticus',4:'Numbers',5:'Deuteronomy',
      6:'Joshua',7:'Judges',8:'1 Samuel',9:'2 Samuel',10:'1 Kings',
      11:'2 Kings',12:'Isaiah',13:'Jeremiah',14:'Ezekiel',15:'Hosea',
      16:'Joel',17:'Amos',18:'Obadiah',19:'Jonah',20:'Micah',
      21:'Nahum',22:'Habakkuk',23:'Zephaniah',24:'Haggai',25:'Zechariah',
      26:'Malachi',27:'Psalms',28:'Proverbs',29:'Job',30:'Song of Songs',
      31:'Ruth',32:'Lamentations',33:'Ecclesiastes',34:'Esther',35:'Daniel',
      36:'Ezra',37:'Nehemiah',38:'1 Chronicles',39:'2 Chronicles'
    };
    const TORAH_BOOKS = ['genesis','exodus','leviticus','numbers','deuteronomy'];

    // --- Hebrew virtual keyboard ---
    let hebKbTarget = null; // the textarea/input that receives keyboard chars

    window.toggleHebrewKeyboard = function() {
      const panel = document.getElementById('hebKbPanel');
      const btn = document.getElementById('hebKbToggle');
      const isOpen = panel.classList.toggle('open');
      btn.classList.toggle('active', isOpen);
      if (isOpen) {
        hebKbTarget = document.getElementById('batchTextarea');
        hebKbTarget.focus();
      }
    };

    // Prevent keyboard keys from stealing focus from textarea
    document.addEventListener('mousedown', function(e) {
      if (e.target.closest('.heb-kb-key')) e.preventDefault();
    });

    // Keyboard click handler — insert character at cursor position in target
    document.addEventListener('click', function(e) {
      const key = e.target.closest('.heb-kb-key');
      if (!key) return;
      e.preventDefault();
      const target = hebKbTarget || document.getElementById('batchTextarea');
      const action = key.dataset.action;
      const ch = key.dataset.char;
      const start = target.selectionStart;
      const end = target.selectionEnd;
      const val = target.value;

      if (action === 'backspace') {
        if (start > 0 || start !== end) {
          const delStart = start === end ? start - 1 : start;
          target.value = val.slice(0, delStart) + val.slice(end);
          target.selectionStart = target.selectionEnd = delStart;
        }
      } else if (action === 'newline') {
        target.value = val.slice(0, start) + '\n' + val.slice(end);
        target.selectionStart = target.selectionEnd = start + 1;
      } else if (action === 'space') {
        target.value = val.slice(0, start) + ' ' + val.slice(end);
        target.selectionStart = target.selectionEnd = start + 1;
      } else if (ch) {
        target.value = val.slice(0, start) + ch + val.slice(end);
        target.selectionStart = target.selectionEnd = start + 1;
      }
      target.focus();
    });

    // --- Character database for verse attribution ---
    let charDatabase = null;

    async function loadCharDB() {
      if (charDatabase) return;
      try {
        const allChars = [];
        for (const book of TORAH_BOOKS) {
          const resp = await fetch(`data/${book}-chars.json.gz`);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const ds = new DecompressionStream('gzip');
          const text = await new Response(blob.stream().pipeThrough(ds)).text();
          allChars.push(...JSON.parse(text));
        }
        if (allChars.length > 0) {
          charDatabase = allChars;
          // Rebuild Torah preview with real word boundaries
          updateTorahPreviewWithWords();
        }
      } catch (e) {
        console.log('Character database not available:', e.message);
      }
    }

    function updateTorahPreviewWithWords() {
      const preview = document.getElementById('torahTextPreview');
      if (!preview || !charDatabase || !torahText) return;
      let display = '';
      let lastWordIdx = -1;
      let lastBook = -1, lastChap = -1, lastVerse = -1;
      for (let i = 0; i < charDatabase.length && i < torahText.length; i++) {
        const ch = charDatabase[i];
        // Verse boundary: newline + reset word tracking
        if (ch.book !== lastBook || ch.chapter !== lastChap || ch.verse !== lastVerse) {
          if (lastBook !== -1) display += '\n';
          lastBook = ch.book; lastChap = ch.chapter; lastVerse = ch.verse;
          lastWordIdx = -1;
        }
        // Insert space on word boundary (within same verse)
        if (ch.word_index !== undefined && ch.word_index !== lastWordIdx && lastWordIdx !== -1) {
          display += ' ';
        }
        display += ch.base_char || torahText[i];
        if (ch.word_index !== undefined) lastWordIdx = ch.word_index;
      }
      preview.textContent = sanitizeSacredNames(display);
      preview.dataset.wordsLoaded = '1';
    }

    function getVerseForPosition(pos) {
      if (!charDatabase || pos < 0 || pos >= charDatabase.length) return null;
      const ch = charDatabase[pos];
      if (!ch) return null;
      const bookName = BOOK_NAMES[ch.book] || `Book ${ch.book}`;
      return `${bookName} ${ch.chapter}:${ch.verse}`;
    }

    function getVersesForHit(pos, skip, termLen) {
      if (!charDatabase) return [];
      const seen = new Set();
      const verses = [];
      for (let i = 0; i < termLen; i++) {
        const p = pos + i * skip;
        const v = getVerseForPosition(p);
        if (v && !seen.has(v)) { seen.add(v); verses.push(v); }
      }
      return verses;
    }

    // --- Verse semantic summaries (pre-computed context) ---
    let verseSummaries = null;

    async function loadVerseSummaries() {
      if (verseSummaries) return;
      try {
        const resp = await fetch('data/verse-summaries.json.gz');
        if (!resp.ok) return;
        const blob = await resp.blob();
        const ds = new DecompressionStream('gzip');
        const text = await new Response(blob.stream().pipeThrough(ds)).text();
        verseSummaries = JSON.parse(text);
      } catch (e) {
        console.log('Verse summaries not available:', e.message);
      }
    }

    function getVerseSummary(verseKey) {
      if (!verseSummaries) return null;
      const sum = verseSummaries[verseKey];
      if (!sum) return null;
      if (!sum._sanitized) {
        if (sum.s) sum.s = sanitizeSacredNames(sum.s);
        if (sum.feel) sum.feel = sanitizeSacredNames(sum.feel);
        if (sum.who) sum.who = sum.who.map(w => sanitizeSacredNames(w));
        if (sum.t) sum.t = sum.t.map(t => sanitizeSacredNames(t));
        sum._sanitized = true;
      }
      return sum;
    }

    function formatSummaryLine(verseKey, verseLabel) {
      const sum = getVerseSummary(verseKey);
      if (!sum) return '';
      const parts = [sum.s];
      if (sum.feel) parts.push('— ' + sum.feel);
      return parts.join(' ');
    }

    function formatSummaryHTML(verseKey) {
      const sum = getVerseSummary(verseKey);
      if (!sum) return '';
      let html = `<div style="font-size:12px;color:#b0bec5;margin-top:2px;font-style:italic;">`;
      html += sum.s;
      if (sum.feel) html += ` — <span style="color:#90caf9;">${sum.feel}</span>`;
      if (sum.who && sum.who.length) html += ` <span style="color:#a5d6a7;">[${sum.who.join(', ')}]</span>`;
      html += `</div>`;
      return html;
    }

    function updateVerseContextPanel(hits) {
      const panel = document.getElementById('verseContextPanel');
      const body = document.getElementById('verseContextBody');
      if (!panel || !body) return;

      if (!verseSummaries || !charDatabase || !hits || hits.length === 0) {
        panel.style.display = 'none';
        return;
      }

      // Collect unique verses from all hits
      const seenVk = new Set();
      const entries = [];
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          const vk = getVerseKey(p);
          if (vk && !seenVk.has(vk)) {
            seenVk.add(vk);
            const sum = getVerseSummary(vk);
            if (sum) {
              const label = getVerseForPosition(p) || vk;
              entries.push({ label, sum });
            }
          }
        }
      }

      if (entries.length === 0) {
        panel.style.display = 'none';
        return;
      }

      let html = '';
      for (const e of entries) {
        html += `<div style="padding:3px 0;border-bottom:1px solid #263238;">`;
        html += `<strong style="color:#e3f2fd;">${e.label}</strong> — ${e.sum.s}`;
        const meta = [];
        if (e.sum.who && e.sum.who.length) meta.push(`<span style="color:#a5d6a7;">Subjects: ${e.sum.who.join(', ')}</span>`);
        if (e.sum.feel) meta.push(`<span style="color:#ffcc80;">Sentiment: ${e.sum.feel}</span>`);
        if (e.sum.t && e.sum.t.length) meta.push(`<span style="color:#ce93d8;">Themes: ${e.sum.t.join(', ')}</span>`);
        if (meta.length) html += `<div style="font-size:11px;margin-top:1px;">${meta.join(' | ')}</div>`;
        html += `</div>`;
      }

      body.innerHTML = html;
      panel.style.display = 'block';
      panel.classList.remove('collapsed');
    }

    // --- Verse hover: text reconstruction + matrix highlight ---
    let verseTextCache = new Map();

    function getVerseKey(pos) {
      if (!charDatabase || pos < 0 || pos >= charDatabase.length) return null;
      const ch = charDatabase[pos];
      if (!ch) return null;
      return `${ch.book}:${ch.chapter}:${ch.verse}`;
    }

    function getVerseTextByKey(key) {
      if (verseTextCache.has(key)) return verseTextCache.get(key);
      if (!charDatabase) return null;
      const [bookStr, chapStr, verseStr] = key.split(':');
      const book = +bookStr, chap = +chapStr, verse = +verseStr;
      let text = '';
      let lastWordIdx = -1;
      for (let i = 0; i < charDatabase.length; i++) {
        const ch = charDatabase[i];
        if (ch.book === book && ch.chapter === chap && ch.verse === verse) {
          if (ch.word_index !== undefined && ch.word_index !== lastWordIdx && lastWordIdx !== -1) {
            text += ' ';
          }
          text += ch.base_char || torahText[i];
          if (ch.word_index !== undefined) lastWordIdx = ch.word_index;
        } else if (ch.book > book || (ch.book === book && ch.chapter > chap) ||
                   (ch.book === book && ch.chapter === chap && ch.verse > verse)) {
          break; // past our verse, stop early
        }
      }
      if (text) {
        // Cap cache at 500 entries to limit memory growth
        if (verseTextCache.size > 500) {
          const first = verseTextCache.keys().next().value;
          verseTextCache.delete(first);
        }
        text = sanitizeSacredNames(text);
        verseTextCache.set(key, text);
      }
      return text || null;
    }

    // Positions of current hits by verse key: Map<verseKey, Set<pos>>
    let currentHitVerseMap = null;

    function buildHitVerseMap(hits) {
      currentHitVerseMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          const vk = getVerseKey(p);
          if (vk) {
            if (!currentHitVerseMap.has(vk)) currentHitVerseMap.set(vk, new Set());
            currentHitVerseMap.get(vk).add(p);
          }
        }
      }
    }

    window.onVerseHover = function(verseKey, verseLabel, event) {
      // 1. Show tooltip with verse text
      const tooltip = document.getElementById('verseTooltip');
      const text = getVerseTextByKey(verseKey);
      if (text) {
        const summaryLine = formatSummaryLine(verseKey, verseLabel);
        const summaryDiv = summaryLine ? `<div style="color:#90caf9;font-size:12px;font-style:italic;margin:2px 0;">${summaryLine}</div>` : '';
        tooltip.innerHTML = `<div class="verse-tooltip-ref">${verseLabel}</div>${summaryDiv}${text}`;
        tooltip.style.display = 'block';
        // Position near cursor — use requestAnimationFrame so offsetHeight is computed
        const x = event.clientX, y = event.clientY;
        requestAnimationFrame(() => {
          const th = tooltip.offsetHeight || 60;
          const maxLeft = Math.max(0, window.innerWidth - tooltip.offsetWidth - 20);
          tooltip.style.left = Math.min(x + 15, maxLeft) + 'px';
          tooltip.style.top = (y > window.innerHeight / 2 ? Math.max(0, y - th - 10) : y + 20) + 'px';
        });
      } else if (verseLabel) {
        // Fallback: show just the reference even without verse text
        tooltip.innerHTML = `<div class="verse-tooltip-ref">${verseLabel}</div><em style="color:#888;">Verse text not available</em>`;
        tooltip.style.display = 'block';
        tooltip.style.left = (event.clientX + 15) + 'px';
        tooltip.style.top = (event.clientY + 20) + 'px';
      }

      // 2. Highlight matching cells in matrix
      if (currentHitVerseMap && currentHitVerseMap.has(verseKey)) {
        const positions = currentHitVerseMap.get(verseKey);
        const grid = document.getElementById('scanMatrixGrid');
        if (grid) {
          for (const cell of grid.children) {
            const pos = parseInt(cell.dataset.pos);
            if (positions.has(pos)) cell.classList.add('verse-glow');
          }
        }
      }
    };

    window.onVerseLeave = function() {
      document.getElementById('verseTooltip').style.display = 'none';
      const grid = document.getElementById('scanMatrixGrid');
      if (grid) {
        for (const cell of grid.children) cell.classList.remove('verse-glow');
      }
    };

    // Helper to create hoverable verse span HTML
    function makeVerseSpans(versesArray) {
      if (!versesArray || versesArray.length === 0) return '';
      return versesArray.map(v => {
        // Parse "BookName chapter:verse" to get key
        // We need to reverse-map: find a position with this verse label to get the key
        const verseKey = findVerseKeyByLabel(v);
        if (!verseKey) return v;
        const escaped = v.replace(/"/g, '&quot;');
        return `<span class="verse-ref-hover" onmouseenter="onVerseHover('${verseKey}','${escaped}',event)" onmouseleave="onVerseLeave()">${v}</span>`;
      }).join(', ');
    }

    function findVerseKeyByLabel(label) {
      // label is like "Genesis 1:1" — reverse lookup through BOOK_NAMES
      if (!charDatabase) return null;
      for (const [num, name] of Object.entries(BOOK_NAMES)) {
        if (label.startsWith(name + ' ')) {
          const ref = label.substring(name.length + 1);
          const [chap, verse] = ref.split(':').map(Number);
          if (chap && verse) return `${num}:${chap}:${verse}`;
        }
      }
      return null;
    }

    // --- ELS search ---
    // Uses normalized text (sofiot → regular) for matching, original text for display
    let torahTextNorm = null; // normalized version (sofiot replaced)

    function findELS(normText, term, skip, ch0Pos) {
      const results = [];
      const len = normText.length;
      const k = term.length;

      // Auto-build ch0Pos if not provided (backward compat)
      if (!ch0Pos) {
        ch0Pos = [];
        const ch0 = term[0];
        for (let i = 0; i < len; i++) {
          if (normText[i] === ch0) ch0Pos.push(i);
        }
      }

      if (skip === 1) {
        // Optimized forward open-text search using indexOf
        let idx = 0;
        while ((idx = normText.indexOf(term, idx)) !== -1) {
          results.push(idx);
          idx++;
        }
      } else if (skip > 0) {
        const maxStart = len - (k - 1) * skip;
        for (const s of ch0Pos) {
          if (s >= maxStart) break;
          let match = true;
          for (let i = 1; i < k; i++) {
            if (normText[s + i * skip] !== term[i]) { match = false; break; }
          }
          if (match) results.push(s);
        }
      } else {
        // Negative skip
        const minStart = (k - 1) * (-skip);
        for (const s of ch0Pos) {
          if (s < minStart) continue;
          let match = true;
          for (let i = 1; i < k; i++) {
            const pos = s + i * skip;
            if (pos < 0 || pos >= len || normText[pos] !== term[i]) { match = false; break; }
          }
          if (match) results.push(s);
        }
      }
      return results;
    }

    // --- IndexedDB for scan results (streaming storage) ---
    const SCAN_DB_NAME = 'ELSScanResults';
    const SCAN_DB_VER = 1;
    const MAX_HITS_MEMORY = 50000;

    function openScanResultsDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(SCAN_DB_NAME, SCAN_DB_VER);
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('hits')) {
            const store = db.createObjectStore('hits', { autoIncrement: true });
            store.createIndex('by_term', 'term', { unique: false });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    // Read all hits from IndexedDB, grouped by term
    async function readAllFromScanDB(termsToLoad) {
      const db = await openScanResultsDB();
      const results = {};
      for (const t of termsToLoad) results[t] = [];
      return new Promise((resolve, reject) => {
        const tx = db.transaction('hits', 'readonly');
        const store = tx.objectStore('hits');
        const req = store.openCursor();
        req.onsuccess = (e) => {
          const cursor = e.target.result;
          if (cursor) {
            const h = cursor.value;
            if (results[h.term]) {
              results[h.term].push({ pos: h.pos, skip: h.skip, form: h.form });
            }
            cursor.continue();
          }
        };
        tx.oncomplete = () => {
          db.close();
          for (const term of termsToLoad) {
            if (results[term].length > MAX_HITS_MEMORY) {
              results[term].sort((a, b) => Math.abs(a.skip) - Math.abs(b.skip));
              results[term].length = MAX_HITS_MEMORY;
            }
          }
          resolve(results);
        };
        tx.onerror = () => { db.close(); reject(tx.error); };
      });
    }

    // --- N-term scan ---
    let scanAbort = false;
    let scanActiveWorker = null;     // Web Worker for scan
    let scanAllResults = {};  // { term: [{pos, skip}, ...] }
    let scanTerms = [];
    let scanClusters = [];
    let currentSelectedClusterIdx = 0;
    let clusterPermRunning = false;
    let clusterPValues = [];         // P-value per cluster
    let clusterSortMode = 'span';    // 'span', 'pvalue', or 'minskip'
    let permSpanDistribution = null; // sorted permuted spans for re-use
    let discoveredResults = []; // stored for filter toggling
    let discSortCol = 'default'; // current sort column
    let discSortAsc = true;      // sort direction
    let namesEnglishMap = null;  // Hebrew → English name lookup

    // --- Wikipedia definition cache (IndexedDB + session) ---
    const WIKI_DEF_DB = 'WikiDefinitions';
    const WIKI_DEF_VER = 1;
    let wikiDefCache = {};  // word -> definition (session cache)

    function openWikiDefDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(WIKI_DEF_DB, WIKI_DEF_VER);
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('defs')) {
            db.createObjectStore('defs', { keyPath: 'word' });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function getWikiDefsFromIDB(words) {
      try {
        const db = await openWikiDefDB();
        const tx = db.transaction('defs', 'readonly');
        const store = tx.objectStore('defs');
        const results = {};
        await Promise.all(words.map(w => new Promise((resolve) => {
          const req = store.get(w);
          req.onsuccess = () => { if (req.result) results[w] = req.result.definition; resolve(); };
          req.onerror = () => resolve();
        })));
        db.close();
        return results;
      } catch { return {}; }
    }

    async function saveWikiDefsToIDB(defs) {
      try {
        const db = await openWikiDefDB();
        const tx = db.transaction('defs', 'readwrite');
        const store = tx.objectStore('defs');
        for (const [word, definition] of Object.entries(defs)) {
          store.put({ word, definition, fetchedAt: Date.now() });
        }
        await new Promise((resolve, reject) => { tx.oncomplete = resolve; tx.onerror = reject; });
        db.close();
      } catch {}
    }

    async function fetchWikiDef(term) {
      const url = `https://he.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(term)}`;
      try {
        const resp = await fetch(url, {
          headers: { 'Accept': 'application/json' }
        });
        if (!resp.ok) return '';
        const data = await resp.json();
        const extract = data.extract || '';
        if (!extract) return '';
        // First sentence
        for (const sep of ['. ', '? ', '! ']) {
          const idx = extract.indexOf(sep);
          if (idx !== -1 && idx < 300) return extract.substring(0, idx + 1);
        }
        return extract.length > 200 ? extract.substring(0, 200).replace(/\s+\S*$/, '...') : extract;
      } catch { return ''; }
    }

    async function enrichDiscoveredWithWiki(discovered) {
      // Collect terms needing definitions (in-dict but no def), max 30
      const needDef = discovered
        .filter(d => d.inDict && !d.hasDef && !(d.word in wikiDefCache))
        .sort((a, b) => a.pValue - b.pValue) // most significant first
        .slice(0, 30);
      if (needDef.length === 0) return false;

      // Check IndexedDB first
      const words = needDef.map(d => d.word);
      const cached = await getWikiDefsFromIDB(words);
      const toFetch = [];
      for (const d of needDef) {
        if (d.word in cached) {
          wikiDefCache[d.word] = cached[d.word];
          if (cached[d.word]) {
            d.definition = cached[d.word];
            d.hasDef = true;
          }
        } else {
          toFetch.push(d);
        }
      }

      // Fetch remaining from Wikipedia API
      if (toFetch.length > 0) {
        const newDefs = {};
        for (const d of toFetch) {
          const def = await fetchWikiDef(d.word);
          await new Promise(r => setTimeout(r, 50)); // rate limit
          if (def) {
            wikiDefCache[d.word] = def;
            newDefs[d.word] = def;
            d.definition = def;
            d.hasDef = true;
          } else {
            // Cache empty result to avoid re-fetching
            wikiDefCache[d.word] = '';
            newDefs[d.word] = '';
          }
        }
        // Persist to IndexedDB
        if (Object.keys(newDefs).length > 0) {
          await saveWikiDefsToIDB(newDefs);
        }
      }

      return true; // at least attempted enrichment
    }

    window.cancelScan = function() {
      scanAbort = true;
      batchAbort = true;
      if (scanActiveWorker) {
        scanActiveWorker.terminate();
        scanActiveWorker = null;
      }
    };

    window.startScan = async function() {
      if (!torahText) {
        const resp = await fetch('data/torahNoSpaces.txt');
        torahText = await resp.text();
      }
      // Build normalized Torah text (sofiot → regular) once
      if (!torahTextNorm) {
        torahTextNorm = normalizeSofiot(torahText);
      }

      // Always parse from textarea (auto-parse on search)
      parseBatchInput();

      // Build term list: one entry per line (primary form), with alternates
      const seen = new Set();
      const terms = [];       // primary cleaned forms (for clustering)
      const termAlts = {};    // primary -> [all alternate forms]
      for (const bt of batchTerms) {
        if (bt.alternates.length === 0) continue;
        const primary = bt.cleaned;
        if (seen.has(primary)) continue;
        seen.add(primary);
        terms.push(primary);
        termAlts[primary] = bt.alternates;
      }
      if (terms.length < 1) { alert('Enter at least one Hebrew search term (one per line)'); return; }

      const minSkip = parseInt(document.getElementById('minSkip').value) || -500;
      const maxSkip = parseInt(document.getElementById('maxSkip').value) || 500;

      const btn = document.getElementById('scanBtn');
      const cancelBtn = document.getElementById('scanCancelBtn');
      const status = document.getElementById('scanStatus');
      const progressDiv = document.getElementById('scanProgress');
      const progressBar = document.getElementById('scanProgressBar');
      btn.disabled = true;
      btn.textContent = 'Scanning...';
      cancelBtn.style.display = '';
      progressDiv.style.display = '';
      progressBar.style.width = '0%';
      progressBar.textContent = '0%';
      scanAbort = false;

      // Load character database for verse attribution + semantic summaries
      status.textContent = 'Loading verse database...';
      await Promise.all([loadCharDB(), loadVerseSummaries()]);

      // --- Memory cleanup before new scan ---
      scanAllResults = {};
      scanClusters = [];
      clusterPValues = [];
      permSpanDistribution = null;
      verseTextCache.clear();
      scanTerms = terms;
      for (const term of terms) scanAllResults[term] = [];

      // Reset batch term statuses if batch is active
      const hasBatch = batchTerms.length > 0;
      if (hasBatch) {
        for (const t of batchTerms) { t.hits = 0; t.bestSkip = null; t.bestPos = null; t.status = 'pending'; }
        document.getElementById('batchResults').style.display = '';
        renderBatchTable();
      }

      const totalForms = terms.reduce((s, t) => s + (termAlts[t] || [t]).length, 0);
      const startTime = performance.now();

      // --- Run scan in Web Worker (streams to IndexedDB) with main-thread fallback ---
      const scanHitCounts = {};  // term -> hit count (for progress, before DB read)
      let workerUsed = false;
      try {
        const worker = new Worker('engines/scan.worker.js');
        scanActiveWorker = worker;
        workerUsed = true;

        await new Promise((resolve, reject) => {
          worker.onmessage = function(msg) {
            const d = msg.data;
            switch (d.type) {
              case 'progress': {
                const pct = Math.round((d.formsSearched / d.totalForms) * 100);
                progressBar.style.width = pct + '%';
                progressBar.textContent = pct + '%';
                const elapsed = (performance.now() - startTime) / 1000;
                const rate = d.formsSearched > 0 ? elapsed / d.formsSearched : 0;
                const remaining = Math.round(rate * (d.totalForms - d.formsSearched));
                const remMin = Math.floor(remaining / 60);
                const remSec = remaining % 60;
                status.textContent = `Term ${d.termIdx + 1}/${terms.length}: "${d.primary}" — ${d.hitsSoFar.toLocaleString()} hits` +
                  (remaining > 0 ? ` | ~${remMin}m ${remSec}s remaining` : '');
                break;
              }
              case 'term-done': {
                scanHitCounts[d.primary] = d.hitCount;
                if (hasBatch) {
                  const bt = batchTerms.find(b => b.cleaned === d.primary);
                  if (bt) {
                    bt.hits = d.hitCount;
                    bt.bestSkip = d.bestSkip;
                    bt.bestPos = d.bestPos;
                    bt.status = 'done';
                    updateBatchRow(batchTerms.indexOf(bt));
                  }
                }
                break;
              }
              case 'complete':
              case 'cancelled':
                resolve(d.type);
                break;
              case 'error':
                reject(new Error(d.error));
                break;
            }
          };
          worker.onerror = function(err) { reject(err); };
          worker.postMessage({
            action: 'scan',
            torahText: torahTextNorm,
            terms,
            termAlts,
            minSkip,
            maxSkip
          });
        });

        worker.terminate();
        scanActiveWorker = null;

        // Read ALL results from IndexedDB into scanAllResults
        if (!scanAbort) {
          status.textContent = 'Loading results from database...';
          await new Promise(r => setTimeout(r, 0));
          scanAllResults = await readAllFromScanDB(terms);
        }
      } catch (workerErr) {
        scanActiveWorker = null;
        if (workerUsed) console.warn('Scan worker failed, falling back to main thread:', workerErr);

        // --- Main-thread fallback: write to IndexedDB + memory with frequent yields ---
        let fallbackDB = null;
        try { fallbackDB = await openScanResultsDB(); } catch(e) { /* no DB, memory only */ }
        if (fallbackDB) {
          // Clear old data
          await new Promise((resolve, reject) => {
            const tx = fallbackDB.transaction('hits', 'readwrite');
            tx.objectStore('hits').clear();
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        }

        let formsSearched = 0;
        for (let ti = 0; ti < terms.length; ti++) {
          if (scanAbort) break;
          const primary = terms[ti];
          const alts = termAlts[primary] || [primary];
          const mergedResults = [];
          let dbBuffer = [];

          for (const form of alts) {
            if (scanAbort) break;
            // Pre-compute first-char positions for ~22x speedup
            const ch0 = form[0];
            const ch0Pos = [];
            for (let i = 0; i < torahTextNorm.length; i++) {
              if (torahTextNorm[i] === ch0) ch0Pos.push(i);
            }
            for (let skip = minSkip; skip <= maxSkip; skip++) {
              if (scanAbort) break;
              if (skip === 0) continue;
              const found = findELS(torahTextNorm, form, skip, ch0Pos);
              for (const pos of found) {
                mergedResults.push({ pos, skip, form });
                if (fallbackDB) dbBuffer.push({ term: primary, pos, skip, form });
              }
              // Flush to IndexedDB + yield every 50 skips
              if ((skip - minSkip) % 50 === 0) {
                if (fallbackDB && dbBuffer.length > 0) {
                  await new Promise((resolve, reject) => {
                    const tx = fallbackDB.transaction('hits', 'readwrite');
                    const store = tx.objectStore('hits');
                    for (const h of dbBuffer) store.put(h);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                  });
                  dbBuffer = [];
                }
                const pct = Math.round(((formsSearched + (skip - minSkip) / (maxSkip - minSkip + 1)) / totalForms) * 100);
                progressBar.style.width = pct + '%';
                progressBar.textContent = pct + '%';
                await new Promise(r => setTimeout(r, 0));
              }
            }
            formsSearched++;
          }
          // Flush remaining
          if (fallbackDB && dbBuffer.length > 0) {
            await new Promise((resolve, reject) => {
              const tx = fallbackDB.transaction('hits', 'readwrite');
              const store = tx.objectStore('hits');
              for (const h of dbBuffer) store.put(h);
              tx.oncomplete = () => resolve();
              tx.onerror = () => reject(tx.error);
            });
          }
          scanAllResults[primary] = mergedResults;

          if (hasBatch) {
            const bt = batchTerms.find(b => b.cleaned === primary);
            if (bt) {
              bt.hits = mergedResults.length;
              if (mergedResults.length > 0) {
                let bestSkip = Infinity, bestPos = 0;
                for (const r of mergedResults) {
                  if (Math.abs(r.skip) < Math.abs(bestSkip)) { bestSkip = r.skip; bestPos = r.pos; }
                }
                bt.bestSkip = bestSkip;
                bt.bestPos = bestPos;
              }
              bt.status = 'done';
              updateBatchRow(batchTerms.indexOf(bt));
            }
          }
          const pct = Math.round((formsSearched / totalForms) * 100);
          progressBar.style.width = pct + '%';
          progressBar.textContent = pct + '%';
          status.textContent = `Term ${ti + 1}/${terms.length}: "${primary}" — ${mergedResults.length.toLocaleString()} hits`;
          await new Promise(r => setTimeout(r, 0));
        }
        if (fallbackDB) fallbackDB.close();
      }

      btn.disabled = false;
      btn.textContent = 'Search';
      cancelBtn.style.display = 'none';
      progressDiv.style.display = 'none';

      const totalTime = Math.round((performance.now() - startTime) / 1000);
      const totalHits = Object.values(scanAllResults).reduce((s, r) => s + r.length, 0);
      status.textContent = scanAbort
        ? 'Cancelled.'
        : `Done! ${terms.length} terms (${totalForms} forms), ${totalHits.toLocaleString()} hits in ${Math.floor(totalTime/60)}m ${totalTime%60}s`;

      // Auto-cluster all terms with hits (if 2+)
      scanClusters = [];
      const termsWithHits = terms.filter(t => scanAllResults[t].length > 0);
      if (termsWithHits.length >= 2) {
        status.textContent += ' — Finding clusters...';
        await new Promise(r => setTimeout(r, 0));
        scanClusters = findClusters(termsWithHits, scanAllResults, 10000);
        // Update scanTerms to only include terms with hits for display
        scanTerms = termsWithHits;
      }

      displayScanResults(scanTerms, scanAllResults, scanClusters);

      // Auto-select first cluster so matrix (2D & 3D) updates immediately
      if (scanClusters.length > 0) {
        showClusterMatrix(0);
      }

      // Auto-run significance test if 2+ terms and clusters exist
      if (scanTerms.length >= 2 && scanClusters.length > 0) {
        setTimeout(() => runClusterPermTest(), 100);
      }

      if (hasBatch) {
        renderBatchTable();
        document.getElementById('batchExportBtn').style.display = '';
      }

      autoSaveSession();
    };

    // --- Sliding window cluster finder ---
    function findClusters(terms, allResults, maxSpan) {
      // Merge all hits tagged by term index, with per-term cap for memory safety
      const MAX_HITS_FOR_CLUSTERING = 5000;
      const merged = [];
      terms.forEach((term, idx) => {
        const hits = allResults[term];
        // If a term has too many hits, keep only the smallest-|skip| ones for clustering
        let useHits = hits;
        if (hits.length > MAX_HITS_FOR_CLUSTERING) {
          useHits = hits.slice().sort((a, b) => Math.abs(a.skip) - Math.abs(b.skip));
          useHits.length = MAX_HITS_FOR_CLUSTERING;
        }
        for (const hit of useHits) {
          merged.push({ pos: hit.pos, skip: hit.skip, termIdx: idx, term: hit.form || term });
        }
      });
      if (merged.length === 0) return [];

      merged.sort((a, b) => a.pos - b.pos);

      const clusters = [];
      const termCount = terms.length;
      // Count of each term in current window
      const counts = new Array(termCount).fill(0);
      let presentTerms = 0;
      let left = 0;

      for (let right = 0; right < merged.length; right++) {
        const rHit = merged[right];
        if (counts[rHit.termIdx] === 0) presentTerms++;
        counts[rHit.termIdx]++;

        // Shrink window from left while all terms still present
        while (presentTerms === termCount) {
          const span = merged[right].pos - merged[left].pos;
          if (span <= maxSpan) {
            // Record cluster: pick one hit per term (closest to center)
            const centerPos = (merged[left].pos + merged[right].pos) / 2;
            const hits = [];
            for (let t = 0; t < termCount; t++) {
              // Find best hit for this term in window
              let best = null, bestDist = Infinity;
              for (let k = left; k <= right; k++) {
                if (merged[k].termIdx === t) {
                  const d = Math.abs(merged[k].pos - centerPos);
                  if (d < bestDist) { bestDist = d; best = merged[k]; }
                }
              }
              if (best) hits.push({ ...best });
            }
            clusters.push({ span, hits, minPos: merged[left].pos, maxPos: merged[right].pos });
          }

          const lHit = merged[left];
          counts[lHit.termIdx]--;
          if (counts[lHit.termIdx] === 0) presentTerms--;
          left++;
        }
      }

      // Sort by span ascending
      clusters.sort((a, b) => a.span - b.span);

      // Deduplicate overlapping clusters (keep smallest span variant)
      const deduped = [];
      const usedKeys = new Set();
      for (const c of clusters) {
        // Key = sorted positions of chosen hits
        const key = c.hits.map(h => `${h.termIdx}:${h.pos}:${h.skip}`).sort().join('|');
        if (!usedKeys.has(key)) {
          usedKeys.add(key);
          deduped.push(c);
          if (deduped.length >= 200) break;
        }
      }

      return deduped;
    }

    // --- Display scan results ---
    function displayScanResults(terms, allResults, clusters) {
      let html = '<div class="results">';

      // Clusters section (2+ terms)
      if (terms.length >= 2 && clusters.length > 0) {
        html += `<div style="background:#fff3e0;padding:16px;border-radius:8px;border-right:4px solid #ff9800;margin-bottom:20px;">`;
        html += `<div style="display:flex;align-items:center;flex-wrap:wrap;gap:10px;margin-bottom:12px;">`;
        html += `<h3 style="color:#e65100;margin:0;">Clusters (${clusters.length}) — sorted by smallest region</h3>`;
        html += `<button onclick="runClusterPermTest()" id="clusterPermBtn" style="background:linear-gradient(135deg,#7b1fa2,#9c27b0);color:#fff;border:none;padding:6px 14px;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;">Significance Test</button>`;
        html += `<label style="font-size:12px;color:#666;">N=<input id="clusterPermN" type="number" value="1000" min="100" max="100000" step="100" style="width:70px;margin-left:4px;padding:2px 4px;border:1px solid #ccc;border-radius:4px;font-size:12px;"></label>`;
        html += `<button id="clusterSortSpan" onclick="sortClusters('span')" style="background:#e65100;color:#fff;border:none;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600;opacity:1;">Sort: Span</button>`;
        html += `<button id="clusterSortP" onclick="sortClusters('pvalue')" disabled style="background:#7b1fa2;color:#fff;border:none;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600;opacity:0.4;">Sort: P-value</button>`;
        html += `<button id="clusterSortSkip" onclick="sortClusters('minskip')" style="background:#00695c;color:#fff;border:none;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600;opacity:0.5;">Sort: Min |Skip|</button>`;
        html += `<button id="clusterSortShared" onclick="sortClusters('shared')" style="background:#4a148c;color:#fff;border:none;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600;opacity:0.5;">Shared Letters First</button>`;
        html += `</div>`;
        html += `<div id="clusterPermResults" style="display:none;margin-bottom:12px;"></div>`;
        html += `<p style="font-size:13px;color:#666;margin-bottom:12px;">Click to view matrix with all terms</p>`;
        html += '<div id="clusterListContainer" class="results-scrollable" style="max-height:500px;">';
        html += '</div></div>';
        // Reset sort state and render cluster list
        clusterSortMode = 'span';
        clusterPValues = [];
        permSpanDistribution = null;
        setTimeout(() => renderClusterList(), 0);
      } else if (terms.length >= 2) {
        html += `<div style="background:#fff3e0;padding:16px;border-radius:8px;border-right:4px solid #ff9800;margin-bottom:20px;">`;
        html += `<h3 style="color:#e65100;margin-bottom:12px;">Clusters</h3>`;
        html += `<p>No clusters found — some terms may have no results.</p></div>`;
      }

      // Individual term results (paginated — render first 200 per term)
      const DISPLAY_LIMIT = 200;
      terms.forEach((term, tIdx) => {
        const results = allResults[term];
        const color = TERM_COLORS[tIdx % 8];
        const forms = new Set(results.map(r => r.form || term));
        const formLabel = forms.size > 1 ? ` (${[...forms].join(' / ')})` : '';
        const capped = results.length > DISPLAY_LIMIT;
        html += `<h3 style="margin-top:20px;border-right:4px solid ${color};padding-right:10px;">${sanitizeSacredNames(term)}${formLabel}: ${results.length.toLocaleString()} occurrences${capped ? ` (showing first ${DISPLAY_LIMIT})` : ''}</h3>`;
        if (results.length > 0) {
          html += `<div class="results-scrollable" style="max-height:300px;" id="termResults_${tIdx}">`;
          const showCount = Math.min(results.length, DISPLAY_LIMIT);
          for (let i = 0; i < showCount; i++) {
            const r = results[i];
            const actualForm = r.form || term;
            const verses = getVersesForHit(r.pos, r.skip, actualForm.length);
            const verseStr = verses.length > 0 ? `<span style="color:#888;font-size:12px;"> — ${verses.join(', ')}</span>` : '';
            const formNote = actualForm !== term ? `<span style="color:#999;font-size:11px;">[${sanitizeSacredNames(actualForm)}]</span> ` : '';
            // Inline verse summary (first verse only, for brevity)
            let summaryStr = '';
            if (verseSummaries && charDatabase) {
              const vk = getVerseKey(r.pos);
              if (vk) {
                const sum = getVerseSummary(vk);
                if (sum) summaryStr = `<span style="color:#78909c;font-size:11px;font-style:italic;"> (${sum.s})</span>`;
              }
            }
            html += `<div class="result-item" onclick="showSingleTermMatrix(${tIdx}, ${i})">
              <span class="term" style="color:${color};">${formNote}${sanitizeSacredNames(actualForm)}</span>
              <span class="info">Position: ${r.pos.toLocaleString()} | Skip: ${r.skip}${verseStr}${summaryStr}</span>
            </div>`;
          }
          if (capped) {
            html += `<div style="text-align:center;padding:8px;">
              <button onclick="loadMoreResults(${tIdx}, ${DISPLAY_LIMIT})" id="loadMoreBtn_${tIdx}"
                style="background:#1976d2;color:#fff;border:none;padding:6px 16px;border-radius:4px;cursor:pointer;font-size:12px;">
                Show more (${(results.length - DISPLAY_LIMIT).toLocaleString()} remaining)
              </button></div>`;
          }
          html += '</div>';
        }
      });

      html += '</div>';
      document.getElementById('scanResults').innerHTML = html;
    }

    // Load more results for a term (paginated display)
    window.loadMoreResults = function(tIdx, alreadyShown) {
      const term = scanTerms[tIdx];
      const results = scanAllResults[term];
      if (!results) return;
      const color = TERM_COLORS[tIdx % 8];
      const container = document.getElementById('termResults_' + tIdx);
      if (!container) return;

      // Remove the "load more" button
      const btn = document.getElementById('loadMoreBtn_' + tIdx);
      if (btn) btn.parentElement.remove();

      // Render next batch (200 more at a time)
      const BATCH = 200;
      const end = Math.min(results.length, alreadyShown + BATCH);
      let html = '';
      for (let i = alreadyShown; i < end; i++) {
        const r = results[i];
        const actualForm = r.form || term;
        const verses = getVersesForHit(r.pos, r.skip, actualForm.length);
        const verseStr = verses.length > 0 ? `<span style="color:#888;font-size:12px;"> — ${verses.join(', ')}</span>` : '';
        const formNote = actualForm !== term ? `<span style="color:#999;font-size:11px;">[${sanitizeSacredNames(actualForm)}]</span> ` : '';
        let summaryStr2 = '';
        if (verseSummaries && charDatabase) {
          const vk2 = getVerseKey(r.pos);
          if (vk2) { const sm = getVerseSummary(vk2); if (sm) summaryStr2 = `<span style="color:#78909c;font-size:11px;font-style:italic;"> (${sm.s})</span>`; }
        }
        html += `<div class="result-item" onclick="showSingleTermMatrix(${tIdx}, ${i})">
          <span class="term" style="color:${color};">${formNote}${sanitizeSacredNames(actualForm)}</span>
          <span class="info">Position: ${r.pos.toLocaleString()} | Skip: ${r.skip}${verseStr}${summaryStr2}</span>
        </div>`;
      }
      if (end < results.length) {
        html += `<div style="text-align:center;padding:8px;">
          <button onclick="loadMoreResults(${tIdx}, ${end})" id="loadMoreBtn_${tIdx}"
            style="background:#1976d2;color:#fff;border:none;padding:6px 16px;border-radius:4px;cursor:pointer;font-size:12px;">
            Show more (${(results.length - end).toLocaleString()} remaining)
          </button></div>`;
      }
      container.insertAdjacentHTML('beforeend', html);
    };

    // --- Count shared letter positions between terms in a cluster ---
    function countSharedPositions(cluster) {
      const posMap = new Map();
      for (const h of cluster.hits) {
        const termLen = h.term.length;
        for (let i = 0; i < termLen; i++) {
          const p = h.pos + i * h.skip;
          if (!posMap.has(p)) posMap.set(p, new Set());
          posMap.get(p).add(h.termIdx);
        }
      }
      let shared = 0;
      for (const termSet of posMap.values()) {
        if (termSet.size > 1) shared++;
      }
      return shared;
    }

    // --- Render cluster list (called initially and on sort change) ---
    function renderClusterList() {
      const container = document.getElementById('clusterListContainer');
      if (!container || scanClusters.length === 0) return;

      // Build sorted index array
      const indices = scanClusters.map((_, i) => i);
      if (clusterSortMode === 'pvalue' && clusterPValues.length === scanClusters.length) {
        indices.sort((a, b) => clusterPValues[a] - clusterPValues[b]);
      } else if (clusterSortMode === 'minskip') {
        // Sort by smallest |skip| in the cluster (smallest first)
        indices.sort((a, b) => {
          const minA = Math.min(...scanClusters[a].hits.map(h => Math.abs(h.skip)));
          const minB = Math.min(...scanClusters[b].hits.map(h => Math.abs(h.skip)));
          return minA - minB || scanClusters[a].span - scanClusters[b].span;
        });
      } else if (clusterSortMode === 'shared') {
        // Sort clusters by number of shared letter positions (most shared first)
        indices.sort((a, b) => {
          const sharedA = countSharedPositions(scanClusters[a]);
          const sharedB = countSharedPositions(scanClusters[b]);
          return sharedB - sharedA || scanClusters[a].span - scanClusters[b].span;
        });
      }
      // else keep original order (by span, smallest first)

      // Update sort button active states
      const btnSpan = document.getElementById('clusterSortSpan');
      const btnP = document.getElementById('clusterSortP');
      const btnSkip = document.getElementById('clusterSortSkip');
      const btnShared = document.getElementById('clusterSortShared');
      if (btnSpan) btnSpan.style.opacity = clusterSortMode === 'span' ? '1' : '0.5';
      if (btnP) btnP.style.opacity = clusterSortMode === 'pvalue' ? '1' : '0.5';
      if (btnSkip) btnSkip.style.opacity = clusterSortMode === 'minskip' ? '1' : '0.5';
      if (btnShared) btnShared.style.opacity = clusterSortMode === 'shared' ? '1' : '0.5';

      let html = '';
      for (const idx of indices) {
        const c = scanClusters[idx];
        html += `<div class="cluster-row" onclick="showClusterMatrix(${idx})">`;
        html += `<div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">`;
        html += `<span class="cluster-span">${c.span.toLocaleString()} chars</span>`;
        // Min |skip| badge
        const minSkip = Math.min(...c.hits.map(h => Math.abs(h.skip)));
        html += `<span style="font-size:11px;font-weight:bold;color:#00695c;background:#e0f2f1;padding:2px 6px;border-radius:4px;">|skip|≥${minSkip}</span>`;
        // Shared letter badge
        const sharedCount = countSharedPositions(c);
        if (sharedCount > 0) {
          html += `<span style="font-size:11px;font-weight:bold;color:#4a148c;background:#f3e5f5;padding:2px 6px;border-radius:4px;">🔗 ${sharedCount} shared</span>`;
        }
        // P-value badge if computed
        if (clusterPValues.length > idx && permSpanDistribution) {
          const p = clusterPValues[idx];
          const pColor = p < 0.01 ? '#1b5e20' : p < 0.05 ? '#2e7d32' : p < 0.1 ? '#f57f17' : '#c62828';
          const pBg = p < 0.01 ? '#c8e6c9' : p < 0.05 ? '#dcedc8' : p < 0.1 ? '#fff9c4' : '#ffcdd2';
          const pStr = p === 0 ? '< ' + (1 / permSpanDistribution.length).toFixed(6) : p < 0.001 ? p.toExponential(2) : p.toFixed(4);
          html += `<span style="font-size:11px;font-weight:bold;color:${pColor};background:${pBg};padding:2px 6px;border-radius:4px;">P=${pStr}</span>`;
        }
        html += `</div>`;
        html += `<div class="cluster-terms">`;
        c.hits.forEach(h => {
          const color = TERM_COLORS[h.termIdx % 8];
          const verses = getVersesForHit(h.pos, h.skip, h.term.length);
          const verseStr = verses.length > 0 ? ` [${verses.join(', ')}]` : '';
          html += `<span class="cluster-term-tag" style="background:${color}20;border-color:${color};color:#333;">
            "${sanitizeSacredNames(h.term)}" pos:${h.pos.toLocaleString()} skip:${h.skip}${verseStr}
          </span>`;
        });
        html += `</div></div>`;
      }
      container.innerHTML = html;
    }

    // --- Compute per-cluster P-values via binary search on sorted permuted spans ---
    function computeClusterPValues(clusters, permSpans) {
      return clusters.map(c => {
        // Binary search: find count of permSpans <= c.span
        let lo = 0, hi = permSpans.length;
        while (lo < hi) {
          const mid = (lo + hi) >> 1;
          if (permSpans[mid] <= c.span) lo = mid + 1;
          else hi = mid;
        }
        return lo / permSpans.length;
      });
    }

    // --- Sort clusters by span or P-value ---
    window.sortClusters = function(mode) {
      clusterSortMode = mode;
      renderClusterList();
    };

    // --- Cluster significance permutation test ---
    window.runClusterPermTest = async function() {
      if (clusterPermRunning) { clusterPermRunning = false; return; }
      if (scanTerms.length < 2 || scanClusters.length === 0) return;

      const numTrials = parseInt(document.getElementById('clusterPermN')?.value) || 1000;
      const btn = document.getElementById('clusterPermBtn');
      const resDiv = document.getElementById('clusterPermResults');
      clusterPermRunning = true;
      btn.textContent = 'Cancel';
      btn.style.background = 'linear-gradient(135deg,#c62828,#e53935)';
      resDiv.style.display = 'block';
      resDiv.innerHTML = `<div style="background:#f3e5f5;padding:10px;border-radius:6px;">
        <div style="font-size:13px;color:#6a1b9a;margin-bottom:6px;">Running permutation test...</div>
        <div style="background:#e1bee7;border-radius:4px;height:8px;overflow:hidden;">
          <div id="clusterPermBar" style="height:100%;width:0%;background:linear-gradient(90deg,#7b1fa2,#ab47bc);transition:width 0.2s;"></div>
        </div>
        <div id="clusterPermProgress" style="font-size:11px;color:#888;margin-top:4px;"></div>
      </div>`;

      // Pool all hits from all terms
      const termCount = scanTerms.length;
      const pooled = [];
      for (const term of scanTerms) {
        const results = scanAllResults[term];
        if (!results) continue;
        const tIdx = scanTerms.indexOf(term);
        for (const hit of results) {
          pooled.push({ pos: hit.pos, termIdx: tIdx });
        }
      }
      pooled.sort((a, b) => a.pos - b.pos);
      const M = pooled.length;
      if (M < termCount) {
        resDiv.innerHTML = '<div style="color:#c62828;padding:8px;">Not enough hits for permutation test.</div>';
        btn.textContent = 'Significance Test';
        btn.style.background = 'linear-gradient(135deg,#7b1fa2,#9c27b0)';
        clusterPermRunning = false;
        return;
      }

      // Actual best (smallest) cluster span
      const actualBestSpan = scanClusters[0].span;

      // Sliding-window minimum-span finder for given labels
      function findMinSpan(labels) {
        const counts = new Array(termCount).fill(0);
        let present = 0, left = 0, minSpan = Infinity;
        for (let right = 0; right < M; right++) {
          const rLabel = labels[right];
          if (counts[rLabel] === 0) present++;
          counts[rLabel]++;
          while (present === termCount) {
            const span = pooled[right].pos - pooled[left].pos;
            if (span < minSpan) minSpan = span;
            const lLabel = labels[left];
            counts[lLabel]--;
            if (counts[lLabel] === 0) present--;
            left++;
          }
        }
        return minSpan;
      }

      // Build label array preserving count-per-term
      const labels = pooled.map(h => h.termIdx);

      // Fisher-Yates shuffle (in-place)
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
        }
      }

      const permSpans = [];
      let betterCount = 0;
      const bar = document.getElementById('clusterPermBar');
      const progText = document.getElementById('clusterPermProgress');

      for (let t = 0; t < numTrials; t++) {
        if (!clusterPermRunning) break;

        shuffle(labels);
        const span = findMinSpan(labels);
        permSpans.push(span);
        if (span <= actualBestSpan) betterCount++;

        if (t % 50 === 0) {
          const pct = ((t + 1) / numTrials * 100).toFixed(1);
          bar.style.width = pct + '%';
          const runningP = (betterCount / (t + 1)).toFixed(4);
          progText.textContent = `Trial ${t + 1}/${numTrials} — running P ≈ ${runningP}`;
          await new Promise(r => setTimeout(r, 0));
        }
      }

      btn.textContent = 'Significance Test';
      btn.style.background = 'linear-gradient(135deg,#7b1fa2,#9c27b0)';
      const wasAborted = !clusterPermRunning;
      clusterPermRunning = false;

      if (wasAborted) {
        progText.textContent = 'Cancelled.';
        return;
      }

      const completed = permSpans.length;
      const pValue = betterCount / completed;
      permSpans.sort((a, b) => a - b);
      const median = permSpans[Math.floor(completed / 2)];
      const mean = permSpans.reduce((s, v) => s + v, 0) / completed;

      // Store sorted distribution and compute per-cluster P-values
      permSpanDistribution = permSpans;
      clusterPValues = computeClusterPValues(scanClusters, permSpans);

      // Enable P-value sort button
      const btnP = document.getElementById('clusterSortP');
      if (btnP) { btnP.disabled = false; btnP.style.opacity = '0.5'; }

      // Refresh cluster list with P-value badges
      renderClusterList();

      showClusterPermResults({
        pValue, betterCount, numTrials: completed,
        actualSpan: actualBestSpan, median, mean,
        distribution: permSpans
      });

      autoSaveSession();
    };

    function showClusterPermResults(msg) {
      const resDiv = document.getElementById('clusterPermResults');
      const pVal = msg.pValue;
      const pColor = pVal < 0.01 ? '#1b5e20' : pVal < 0.05 ? '#2e7d32' : pVal < 0.1 ? '#f57f17' : '#c62828';
      const sigLabel = pVal < 0.001 ? 'Highly significant' :
                       pVal < 0.01  ? 'Very significant' :
                       pVal < 0.05  ? 'Significant' :
                       pVal < 0.1   ? 'Marginally significant' : 'Not significant';
      const ratio = pVal > 0 ? Math.round(1 / pVal) : msg.numTrials;

      // Mini histogram
      let histHTML = '';
      if (msg.distribution && msg.distribution.length > 10) {
        const dist = msg.distribution;
        const minV = dist[0], maxV = dist[dist.length - 1];
        const bins = 30;
        const binW = (maxV - minV) / bins || 1;
        const counts = new Array(bins).fill(0);
        for (const v of dist) {
          const bi = Math.min(bins - 1, Math.floor((v - minV) / binW));
          counts[bi]++;
        }
        const maxCount = Math.max(...counts);
        const actualBin = Math.min(bins - 1, Math.floor((msg.actualSpan - minV) / binW));

        histHTML = '<div style="margin-top:8px;"><div style="font-size:11px;color:#555;margin-bottom:4px;">Distribution of permuted minimum spans:</div>';
        histHTML += '<div style="display:flex;align-items:flex-end;height:60px;gap:1px;">';
        for (let b = 0; b < bins; b++) {
          const h = maxCount > 0 ? Math.round((counts[b] / maxCount) * 56) : 0;
          const isActual = b === actualBin;
          const bg = isActual ? '#c62828' : '#ce93d8';
          const title = `${(minV + b * binW).toLocaleString()}\u2013${(minV + (b + 1) * binW).toLocaleString()}: ${counts[b]}`;
          histHTML += `<div style="width:${Math.max(4, Math.floor(200 / bins))}px;height:${Math.max(1, h)}px;background:${bg};border-radius:1px 1px 0 0;" title="${title}"></div>`;
        }
        histHTML += '</div>';
        histHTML += `<div style="font-size:10px;color:#999;display:flex;justify-content:space-between;"><span>${minV.toLocaleString()}</span><span>Red = actual (${msg.actualSpan.toLocaleString()})</span><span>${maxV.toLocaleString()}</span></div>`;
        histHTML += '</div>';
      }

      resDiv.innerHTML = `
        <div style="background:#f3e5f5;padding:12px;border-radius:6px;border:1px solid #ce93d8;">
          <div style="font-weight:bold;color:#6a1b9a;font-size:14px;margin-bottom:8px;">Cluster Significance Test Results</div>
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:6px;font-size:13px;">
            <div>P-value: <strong style="color:${pColor};font-size:15px;">${pVal === 0 ? '< ' + (1/msg.numTrials).toFixed(6) : pVal.toFixed(6)}</strong></div>
            <div>Significance: <strong style="color:${pColor};">${sigLabel}</strong></div>
            <div>Rank: <strong>${msg.betterCount}</strong> / ${msg.numTrials.toLocaleString()} (1/${ratio.toLocaleString()})</div>
            <div>Actual best span: <strong>${msg.actualSpan.toLocaleString()} chars</strong></div>
            <div>Permuted median: <strong>${msg.median.toLocaleString()} chars</strong></div>
            <div>Permuted mean: <strong>${Math.round(msg.mean).toLocaleString()} chars</strong></div>
          </div>
          ${histHTML}
          <div style="margin-top:6px;font-size:11px;color:#777;">
            ${msg.numTrials.toLocaleString()} random shuffles of term labels across ${scanTerms.length} terms.
            P = fraction of shuffled arrangements producing a minimum span \u2264 actual best span (${msg.actualSpan.toLocaleString()}).
          </div>
        </div>`;
    }

    // --- Show cluster matrix ---
    window.showClusterMatrix = function(idx) {
      const cluster = scanClusters[idx];
      if (!cluster || !torahText) return;

      const view = document.getElementById('scanMatrixView');
      view.style.display = 'block';
      document.getElementById('scanMatrixTitle').textContent =
        `Cluster — ${cluster.hits.map(h => `"${h.term}"`).join(' + ')}`;

      // Stats
      let statsHtml = `<div class="matrix-stat"><div class="value">${cluster.span.toLocaleString()}</div><div class="label">Span</div></div>`;
      cluster.hits.forEach(h => {
        const color = TERM_COLORS[h.termIdx % 8];
        statsHtml += `<div class="matrix-stat">
          <div class="value" style="color:${color};">${h.term}</div>
          <div class="label">pos ${h.pos.toLocaleString()} skip ${h.skip}</div>
        </div>`;
      });
      document.getElementById('scanMatrixStats').innerHTML = statsHtml;

      // Legend with hoverable verse references + semantic summaries
      buildHitVerseMap(cluster.hits);
      let legendHtml = '';
      cluster.hits.forEach(h => {
        const color = TERM_COLORS[h.termIdx % 8];
        const verses = getVersesForHit(h.pos, h.skip, h.term.length);
        const verseSpans = makeVerseSpans(verses);
        const verseStr = verseSpans ? ` (${verseSpans})` : '';
        legendHtml += `<div class="legend-item"><div class="legend-color" style="background:${color};"></div><span>${sanitizeSacredNames(h.term)}${verseStr}</span></div>`;
        // Per-verse semantic summaries
        if (verseSummaries && charDatabase) {
          const seen = new Set();
          for (let i = 0; i < h.term.length; i++) {
            const p = h.pos + i * h.skip;
            const vk = getVerseKey(p);
            if (vk && !seen.has(vk)) {
              seen.add(vk);
              const sum = getVerseSummary(vk);
              if (sum) {
                const vLabel = getVerseForPosition(p) || vk;
                legendHtml += `<div style="margin-right:26px;font-size:11px;color:#b0bec5;font-style:italic;padding:1px 0;">${vLabel}: ${sum.s}${sum.feel ? ' — ' + sum.feel : ''}</div>`;
              }
            }
          }
        }
      });
      if (cluster.hits.length > 1) {
        legendHtml += `<div class="legend-item"><div class="legend-color" style="background:#9c27b0;"></div><span>Overlap</span></div>`;
      }
      document.getElementById('scanMatrixLegend').innerHTML = legendHtml;
      // Update verse context panel
      updateVerseContextPanel(cluster.hits);

      // Hide placeholder when matrix is shown
      const ph = document.getElementById('scanMatrixPlaceholder');
      if (ph) ph.style.display = 'none';

      current3DHits = cluster.hits;
      renderScanMatrix(cluster.hits);

      if (is3DActive && THREE) {
        const { W, H } = findOptimalDimensions(current3DHits);
        render3DMatrix(current3DHits, W, H);
      }

      // Only scroll into view on mobile (desktop has sticky side-by-side)
      if (window.innerWidth < 1024) view.scrollIntoView({ behavior: 'smooth' });

      currentSelectedClusterIdx = idx;
      autoSaveSession();
    };

    // --- Show single term matrix ---
    window.showSingleTermMatrix = function(termIdx, resultIdx) {
      const primaryTerm = scanTerms[termIdx];
      const results = scanAllResults[primaryTerm];
      if (!results || !results[resultIdx] || !torahText) return;

      const r = results[resultIdx];
      const actualForm = r.form || primaryTerm;
      const hit = { pos: r.pos, skip: r.skip, term: actualForm, termIdx };

      const view = document.getElementById('scanMatrixView');
      view.style.display = 'block';
      const titleSuffix = actualForm !== primaryTerm ? ` [alt: ${sanitizeSacredNames(primaryTerm)}]` : '';
      document.getElementById('scanMatrixTitle').textContent = `"${sanitizeSacredNames(actualForm)}"${titleSuffix}`;

      const color = TERM_COLORS[termIdx % 8];
      const verses = getVersesForHit(r.pos, r.skip, actualForm.length);

      document.getElementById('scanMatrixStats').innerHTML = `
        <div class="matrix-stat"><div class="value" style="color:${color};">${sanitizeSacredNames(actualForm)}</div><div class="label">Term</div></div>
        <div class="matrix-stat"><div class="value">${r.pos.toLocaleString()}</div><div class="label">Position</div></div>
        <div class="matrix-stat"><div class="value">${r.skip}</div><div class="label">Skip</div></div>
      `;

      // Legend with hoverable verse references + summaries
      buildHitVerseMap([hit]);
      const verseSpans = makeVerseSpans(verses);
      const verseStr = verseSpans ? ` — ${verseSpans}` : '';
      let singleLegend = `<div class="legend-item"><div class="legend-color" style="background:${color};"></div><span>${sanitizeSacredNames(actualForm)}${verseStr}</span></div>`;
      // Per-verse semantic summaries
      if (verseSummaries && charDatabase) {
        const seen = new Set();
        for (let i = 0; i < actualForm.length; i++) {
          const p = r.pos + i * r.skip;
          const vk = getVerseKey(p);
          if (vk && !seen.has(vk)) {
            seen.add(vk);
            const sum = getVerseSummary(vk);
            if (sum) {
              const vLabel = getVerseForPosition(p) || vk;
              singleLegend += `<div style="margin-right:26px;font-size:11px;color:#b0bec5;font-style:italic;padding:1px 0;">${vLabel}: ${sum.s}${sum.feel ? ' — ' + sum.feel : ''}</div>`;
            }
          }
        }
      }
      document.getElementById('scanMatrixLegend').innerHTML = singleLegend;
      // Update verse context panel
      updateVerseContextPanel([hit]);

      // Hide placeholder when matrix is shown
      const ph = document.getElementById('scanMatrixPlaceholder');
      if (ph) ph.style.display = 'none';

      current3DHits = [hit];
      renderScanMatrix([hit]);

      if (is3DActive && THREE) {
        const { W, H } = findOptimalDimensions(current3DHits);
        render3DMatrix(current3DHits, W, H);
      }

      // Only scroll into view on mobile (desktop has sticky side-by-side)
      if (window.innerWidth < 1024) view.scrollIntoView({ behavior: 'smooth' });
    };

    // --- Discover dictionary-validated ELS terms within current matrix region ---
    window.discoverMatrixTerms = async function() {
      if (!current3DHits || current3DHits.length === 0) {
        alert('No matrix displayed. Click a cluster first.');
        return;
      }
      if (!elsService) {
        alert('ELS index not loaded yet.');
        return;
      }

      const panel = document.getElementById('discoverTermsPanel');
      const resultsDiv = document.getElementById('discoverTermsResults');
      const statusSpan = document.getElementById('discoverTermsStatus');
      panel.style.display = 'block';
      resultsDiv.innerHTML = '<div style="text-align:center;padding:20px;color:#333;font-weight:600;">Searching...</div>';
      statusSpan.textContent = '';

      try {

      // Compute the bounding region of the current matrix hits
      const allPositions = [];
      const searchTermSet = new Set();
      for (const h of current3DHits) {
        searchTermSet.add(h.term);
        for (let i = 0; i < h.term.length; i++) {
          allPositions.push(h.pos + i * h.skip);
        }
      }
      const minPos = Math.min(...allPositions);
      const maxPos = Math.max(...allPositions);
      const center = Math.round((minPos + maxPos) / 2);
      const radius = Math.max(Math.round((maxPos - minPos) / 2) + 100, 500);

      // Load names English map if not yet loaded
      if (!namesEnglishMap) {
        try {
          const resp = await fetch('data/dictionaries/names-english.json');
          if (resp.ok) namesEnglishMap = await resp.json();
        } catch (e) { namesEnglishMap = {}; }
      }

      // Load dictionary if not yet loaded
      if (!dictService) {
        if (typeof initDictionaries !== 'function') {
          statusSpan.textContent = 'Dictionary module unavailable — try reloading the page.';
          resultsDiv.innerHTML = '<div style="text-align:center;padding:20px;color:#c00;font-weight:600;">Dictionary module failed to load. Clear cache and reload.</div>';
          return;
        }
        statusSpan.textContent = 'Loading dictionaries...';
        try {
          await initDictionaries(['unified', 'bdb', 'strongs', 'wiktionary', 'names', 'wikipedia-fulltext']);
          dictService = getDictionaryService();
        } catch (e) {
          console.warn('Full dictionary load failed, trying minimal:', e);
          // Try minimal fallback
          try {
            await initDictionaries(['unified']);
            dictService = getDictionaryService();
          } catch (e2) {
            console.error('Dictionary fallback also failed:', e2);
            dictService = null;
          }
        }
      }

      statusSpan.textContent = `Searching ±${radius} around position ${center}...`;

      // Use setTimeout to allow UI to update before heavy computation
      await new Promise(r => setTimeout(r, 50));

      // Find all ELS-indexed words near the cluster
      const nearby = elsService.findNearby(center, radius, {
        minWordLength: 2,
        maxResults: 500
      });

      // Filter: exclude the search terms themselves, ELS-only (|skip| >= 2), validate against dictionary
      const discovered = [];
      for (const item of nearby) {
        // Skip the original search terms
        if (searchTermSet.has(item.word)) continue;

        // Keep only true ELS occurrences (|skip| >= 2), sorted by distance
        item.occurrences = item.occurrences.filter(o => Math.abs(o.skip) >= 2);
        if (item.occurrences.length === 0) continue;
        item.occurrences.sort((a, b) => a.distance - b.distance);
        item.minDistance = item.occurrences[0].distance;

        // Must be in dictionary — skip non-dictionary words entirely
        let definition = '';
        let root = '';
        let dictSource = '';
        if (!dictService) continue;
        const lookups = dictService.lookup(item.word);
        if (!lookups || lookups.length === 0) continue;

        // Get source names — use short abbreviations
        const SHORT_SRC = {'Unified Hebrew Dictionary':'Unified','Brown-Driver-Briggs':'BDB',
          "Strong's Hebrew Concordance":"Strong's",'Hebrew Wiktionary':'Wikt','Tanakh Extracted':'Tanakh',
          'Hebrew Wikipedia':'Wiki','Wikipedia Full-Text':'Wiki-FT','Hebrew Names':'Names'};
        const srcNames = [...new Set(lookups.map(l => {
          const name = l.sourceName || l.source || '';
          return SHORT_SRC[name] || name;
        }))].filter(Boolean);
        dictSource = srcNames.join(', ');
        // Get best definition
        for (const l of lookups) {
          if (l.definitions && l.definitions.length > 0) {
            definition = l.definitions[0];
            break;
          }
        }
        // Fall back to session-cached Wikipedia definition
        if (!definition && wikiDefCache[item.word]) {
          definition = wikiDefCache[item.word];
        }
        const rootInfo = dictService.getRoot(item.word);
        if (rootInfo) root = rootInfo.root;

        // Get significance
        const sig = elsService.significanceScore(item.word);

        // Categorize: is it a name?
        const isName = dictSource.includes('Names') || dictSource.includes('names');
        // English equivalent from names map
        const english = (namesEnglishMap && namesEnglishMap[item.word]) || '';

        // Categorize: is it a date-related term? (Hebrew months, days, years)
        const isDate = /^(ניסן|אייר|סיון|תמוז|אלול|תשרי|חשון|חשוון|כסלו|טבת|שבט|אדר|יום|חדש|שנה|שנת|נולד|נפטר)$/.test(item.word);

        // Analytical P-value: probability of at least one ELS occurrence within minDistance by chance
        const L = 304805;
        const region = 2 * item.minDistance + 1;
        const pProximity = 1 - Math.pow(1 - Math.min(region, L) / L, item.totalOccurrences);

        discovered.push({
          word: item.word,
          english,
          minDistance: item.minDistance,
          occurrences: item.occurrences.length,
          totalOccurrences: item.totalOccurrences,
          zScore: sig.zScore,
          pValue: pProximity,
          inDict: true,
          definition,
          hasDef: definition !== '',
          root,
          dictSource,
          isName,
          isDate,
          bestOcc: item.occurrences[0] // closest occurrence
        });
      }

      // Sort by z-score descending (all are dictionary-validated)
      discovered.sort((a, b) => b.zScore - a.zScore);

      // Store for filter toggling
      discoveredResults = discovered;

      // Render initial results immediately
      renderDiscoveredResults();
      if (window.innerWidth < 1024) panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

      // Enrich undefined terms with Wikipedia (async, re-renders when done)
      enrichDiscoveredWithWiki(discovered).then(changed => {
        if (changed) renderDiscoveredResults();
      });

      autoSaveSession();

      } catch (err) {
        console.error('Discover Terms error:', err);
        const rd = document.getElementById('discoverTermsResults');
        const ss = document.getElementById('discoverTermsStatus');
        if (rd) rd.innerHTML = `<div style="text-align:center;padding:20px;color:#c00;font-weight:600;">Error: ${err.message}</div>`;
        if (ss) ss.textContent = 'Discovery failed';
      }
    };

    // --- Render discovered results with active filter and sorting ---
    function renderDiscoveredResults() {
      const resultsDiv = document.getElementById('discoverTermsResults');
      const statusSpan = document.getElementById('discoverTermsStatus');
      if (!resultsDiv || discoveredResults.length === 0) {
        if (resultsDiv) resultsDiv.innerHTML = '<div style="text-align:center;padding:20px;color:#333;">No additional terms found in this region.</div>';
        return;
      }

      // Determine active filter
      const fAll = document.getElementById('discFilterAll');
      const fNames = document.getElementById('discFilterNames');
      const fDates = document.getElementById('discFilterDates');
      const fDefined = document.getElementById('discFilterDefined');
      let filtered = discoveredResults.slice(); // copy for sorting
      let filterLabel = '';
      if (fNames && fNames.checked) {
        filtered = filtered.filter(d => d.isName);
        filterLabel = ' (Names only)';
      } else if (fDates && fDates.checked) {
        filtered = filtered.filter(d => d.isDate);
        filterLabel = ' (Dates only)';
      }
      // "Defined" is an additive filter — layers on top of category
      if (fDefined && fDefined.checked) {
        filtered = filtered.filter(d => d.hasDef);
        filterLabel += ' + Defined';
      }

      // Apply sort
      const col = discSortCol;
      const dir = discSortAsc ? 1 : -1;
      if (col === 'length') {
        filtered.sort((a, b) => dir * (a.word.length - b.word.length));
      } else if (col === 'distance') {
        filtered.sort((a, b) => dir * (a.minDistance - b.minDistance));
      } else if (col === 'skip') {
        filtered.sort((a, b) => dir * (Math.abs(a.bestOcc.skip) - Math.abs(b.bestOcc.skip)));
      } else if (col === 'zscore') {
        filtered.sort((a, b) => dir * (a.zScore - b.zScore));
      } else if (col === 'occurrences') {
        filtered.sort((a, b) => dir * (a.totalOccurrences - b.totalOccurrences));
      } else if (col === 'pvalue') {
        filtered.sort((a, b) => dir * ((a.pValue || 1) - (b.pValue || 1)));
      } else {
        // default: z-score descending (all are dictionary-validated)
        filtered.sort((a, b) => b.zScore - a.zScore);
      }

      const totalAll = discoveredResults.length;
      statusSpan.textContent = `${filtered.length} shown / ${totalAll} total (ELS + dict)${filterLabel}`;

      if (filtered.length === 0) {
        resultsDiv.innerHTML = `<div style="text-align:center;padding:20px;color:#333;">No matching terms found. Try adjusting filters.</div>`;
        return;
      }

      // Sort arrow indicator
      const arrow = (c) => discSortCol === c ? (discSortAsc ? ' ▲' : ' ▼') : '';
      const thStyle = 'padding:5px 6px;cursor:pointer;user-select:none;';

      let html = `<div style="display:flex;gap:6px;align-items:center;margin-bottom:6px;flex-wrap:wrap;">
        <button class="btn btn-small" style="padding:3px 10px;font-size:11px;background:#1565c0;" onclick="discSelectAll(true)">Check All</button>
        <button class="btn btn-small" style="padding:3px 10px;font-size:11px;background:#666;" onclick="discSelectAll(false)">Clear All</button>
        <button class="btn btn-small" style="padding:3px 10px;font-size:11px;background:#2e7d32;" onclick="addSelectedTerms()">Add Selected</button>
        <span id="discSelectedCount" style="font-size:11px;color:#555;">0 selected</span>
      </div>
      <table style="width:100%;border-collapse:collapse;font-size:13px;color:#000;table-layout:fixed;">
        <colgroup>
          <col style="width:28px;">
          <col style="width:30px;">
          <col style="width:70px;">
          <col style="width:50px;">
          <col style="width:36px;">
          <col style="width:42px;">
          <col style="width:46px;">
          <col style="width:34px;">
          <col style="width:46px;">
          <col style="width:70px;">
          <col>
        </colgroup>
        <thead><tr style="background:#d0d0d0;text-align:left;color:#000;font-weight:bold;">
          <th style="padding:5px 4px;"><input type="checkbox" id="discCheckAllHeader" onchange="discSelectAll(this.checked)" title="Check/uncheck all"></th>
          <th style="padding:5px 3px;">#</th>
          <th style="${thStyle}" onclick="sortDiscovered('length')">Term${arrow('length')}</th>
          <th style="padding:5px 3px;">Root</th>
          <th style="${thStyle}" onclick="sortDiscovered('distance')">Dist${arrow('distance')}</th>
          <th style="${thStyle}" onclick="sortDiscovered('skip')">Skip${arrow('skip')}</th>
          <th style="${thStyle}" onclick="sortDiscovered('zscore')">z${arrow('zscore')}</th>
          <th style="${thStyle}" onclick="sortDiscovered('occurrences')">Occ${arrow('occurrences')}</th>
          <th style="${thStyle}" onclick="sortDiscovered('pvalue')">P${arrow('pvalue')}</th>
          <th style="padding:5px 3px;">Src</th>
          <th style="padding:5px 3px;">Definition</th>
        </tr></thead><tbody>`;

      for (let i = 0; i < filtered.length; i++) {
        const d = filtered[i];
        const bgColor = d.isName ? '#e3f2fd' : d.isDate ? '#fff3e0' : d.inDict ? '#dcedc8' : '#fff';
        const zColor = d.zScore > 3 ? '#b71c1c' : d.zScore > 2 ? '#bf360c' : '#000';
        const catBadge = d.isName ? '<span style="font-size:9px;background:#1565c0;color:#fff;padding:1px 4px;border-radius:3px;margin-left:3px;">Name</span>' :
                         d.isDate ? '<span style="font-size:9px;background:#e65100;color:#fff;padding:1px 4px;border-radius:3px;margin-left:3px;">Date</span>' : '';
        const safeWord = d.word.replace(/'/g, "\\'");
        html += `<tr style="background:${bgColor};border-bottom:1px solid #ccc;color:#000;" title="Position: ${d.bestOcc.pos}, Total ELS occurrences: ${d.totalOccurrences}">
          <td style="padding:4px 3px;text-align:center;"><input type="checkbox" class="disc-term-cb" data-word="${safeWord}" data-pos="${d.bestOcc.pos}" data-skip="${d.bestOcc.skip}" onchange="updateDiscSelectedCount()"></td>
          <td style="padding:4px 3px;font-size:11px;">${i + 1}</td>
          <td style="padding:4px 3px;font-weight:bold;font-size:14px;direction:rtl;color:#000;overflow:hidden;">${d.word}<span style="font-size:9px;color:#888;margin-left:2px;">${d.word.length}</span>${catBadge}${d.english ? `<br><span style="font-size:10px;color:#1565c0;font-weight:normal;direction:ltr;display:inline-block;">${d.english}</span>` : ''}</td>
          <td style="padding:4px 3px;direction:rtl;color:#000;font-weight:600;font-size:12px;overflow:hidden;">${d.root}</td>
          <td style="padding:4px 3px;color:#000;font-size:11px;">${d.minDistance}</td>
          <td style="padding:4px 3px;color:#000;font-size:11px;">${d.bestOcc.skip}</td>
          <td style="padding:4px 3px;color:${zColor};font-weight:bold;font-size:11px;">${d.zScore.toFixed(1)}</td>
          <td style="padding:4px 3px;color:#000;font-size:11px;">${d.totalOccurrences}</td>
          <td style="padding:4px 3px;font-size:10px;font-weight:bold;color:${d.pValue < 0.01 ? '#1b5e20' : d.pValue < 0.05 ? '#2e7d32' : d.pValue < 0.1 ? '#f57f17' : '#c62828'};" title="P = ${d.pValue != null ? d.pValue.toExponential(3) : 'N/A'}">${d.pValue != null ? (d.pValue < 0.001 ? d.pValue.toExponential(1) : d.pValue.toFixed(3)) : ''}</td>
          <td style="padding:4px 3px;font-size:10px;color:#555;overflow:hidden;text-overflow:ellipsis;" title="${d.dictSource || ''}">${d.dictSource || (d.inDict ? '✓' : '')}</td>
          <td style="padding:4px 4px;font-size:12px;color:#000;word-wrap:break-word;overflow-wrap:break-word;white-space:normal;line-height:1.3;">${d.definition || ''}</td>
        </tr>`;
      }

      html += '</tbody></table>';
      resultsDiv.innerHTML = html;
    }

    // --- Filter checkbox handler (radio-style: only one active) ---
    window.applyDiscoverFilter = function() {
      const fAll = document.getElementById('discFilterAll');
      const fNames = document.getElementById('discFilterNames');
      const fDates = document.getElementById('discFilterDates');
      const fDefined = document.getElementById('discFilterDefined');
      // Radio-style: uncheck others when one is checked (except Defined which layers on top)
      const clicked = event && event.target;
      if (clicked === fAll && fAll.checked) { fNames.checked = false; fDates.checked = false; }
      else if (clicked === fNames && fNames.checked) { fAll.checked = false; fDates.checked = false; }
      else if (clicked === fDates && fDates.checked) { fAll.checked = false; fNames.checked = false; }
      // Defined is independent — can combine with All/Names/Dates
      // If no category checked, default to All
      if (!fAll.checked && !fNames.checked && !fDates.checked) fAll.checked = true;
      if (discoveredResults.length > 0) renderDiscoveredResults();
    };

    // --- Sort discovered terms by column ---
    window.sortDiscovered = function(col) {
      if (discSortCol === col) {
        discSortAsc = !discSortAsc; // toggle direction
      } else {
        discSortCol = col;
        discSortAsc = (col === 'length' || col === 'occurrences') ? false : true; // default asc for pvalue/distance/skip/zscore
      }
      renderDiscoveredResults();
    };

    // --- Check/uncheck all discovered term checkboxes ---
    window.discSelectAll = function(checked) {
      document.querySelectorAll('.disc-term-cb').forEach(cb => cb.checked = checked);
      const hdr = document.getElementById('discCheckAllHeader');
      if (hdr) hdr.checked = checked;
      updateDiscSelectedCount();
    };

    // --- Update selected count display ---
    window.updateDiscSelectedCount = function() {
      const all = document.querySelectorAll('.disc-term-cb');
      const checked = document.querySelectorAll('.disc-term-cb:checked');
      const span = document.getElementById('discSelectedCount');
      if (span) span.textContent = `${checked.length} selected`;
      const hdr = document.getElementById('discCheckAllHeader');
      if (hdr) hdr.checked = all.length > 0 && checked.length === all.length;
    };

    // --- Add all checked terms to textarea ---
    window.addSelectedTerms = function() {
      const checked = document.querySelectorAll('.disc-term-cb:checked');
      if (checked.length === 0) { alert('No terms selected. Check the boxes first.'); return; }
      const textarea = document.getElementById('batchTextarea');
      if (!textarea) return;
      const current = textarea.value.trim();
      const lines = current ? current.split('\n') : [];
      const existingWords = new Set();
      for (const line of lines) {
        for (const w of line.split(/\s+/)) existingWords.add(w);
      }
      let added = 0, skipped = 0;
      for (const cb of checked) {
        const word = cb.dataset.word;
        if (existingWords.has(word)) { skipped++; continue; }
        lines.push(word);
        existingWords.add(word);
        added++;
      }
      textarea.value = lines.join('\n');
      const msg = `Added ${added} term${added !== 1 ? 's' : ''}` + (skipped > 0 ? ` (${skipped} already present)` : '');
      const span = document.getElementById('discSelectedCount');
      if (span) { span.textContent = msg; span.style.color = '#2e7d32'; setTimeout(() => { span.style.color = '#555'; updateDiscSelectedCount(); }, 2000); }
      // Auto re-scan so matrix updates with new terms
      if (added > 0) setTimeout(() => startScan(), 300);
    };

    // Add a discovered term to the search textarea and re-scan
    window.addDiscoveredTerm = function(word, pos, skip) {
      const textarea = document.getElementById('batchTextarea');
      if (!textarea) return;
      // Add term on new line if not already present
      const current = textarea.value.trim();
      const lines = current ? current.split('\n') : [];
      // Check if already present (as primary or alternate)
      const alreadyPresent = lines.some(line => line.split(/\s+/).some(w => w === word));
      if (alreadyPresent) {
        alert(`"${word}" is already in the search terms.`);
        return;
      }
      textarea.value = current + (current ? '\n' : '') + word;
      // Auto re-scan so matrix updates with new term
      setTimeout(() => startScan(), 300);
    };

    // --- Render N-term matrix ---
    function renderScanMatrix(hits) {
      // Determine grid width from max |skip|
      const width = Math.max(...hits.map(h => Math.abs(h.skip)), 30);

      // Center on cluster midpoint
      const allPositions = [];
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) allPositions.push(h.pos + i * h.skip);
      }
      const minPos = Math.min(...allPositions);
      const maxPos = Math.max(...allPositions);

      // Compute row range from actual term positions (with context padding)
      const padding = 3;
      const startRow = Math.max(0, Math.floor(minPos / width) - padding);
      const endRow = Math.floor(maxPos / width) + padding;

      // Build posMap: position -> Set of termIdx
      const posMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          if (!posMap.has(p)) posMap.set(p, new Set());
          posMap.get(p).add(h.termIdx);
        }
      }

      let html = '';
      for (let row = startRow; row <= endRow; row++) {
        const rowStart = row * width;
        if (rowStart < 0) continue;
        for (let col = 0; col < width; col++) {
          const pos = rowStart + col;
          if (pos >= torahText.length) break;
          const ch = torahText[pos];
          const termSet = posMap.get(pos);
          let cls = 'matrix-cell';
          let tooltip = '';

          if (termSet) {
            if (termSet.size > 1) {
              cls += ' multi-term';
            } else {
              const idx = termSet.values().next().value;
              cls += ` term-color-${idx % 8}`;
            }
            // Tooltip with verse reference + summary
            const verse = getVerseForPosition(pos);
            const termNames = [...termSet].map(t => scanTerms[t]).join(', ');
            const vk = getVerseKey(pos);
            const cellSum = vk ? getVerseSummary(vk) : null;
            const cellSumStr = cellSum ? ` — ${cellSum.s}` : '';
            tooltip = verse ? `${termNames} — ${verse}${cellSumStr}` : termNames;
          }

          html += `<div class="${cls}" data-pos="${pos}"${tooltip ? ` title="${tooltip}"` : ''}>${ch}</div>`;
        }
      }

      const grid = document.getElementById('scanMatrixGrid');
      grid.style.gridTemplateColumns = `repeat(${width}, 26px)`;
      grid.innerHTML = html;
    }

    // ============= BATCH TERM LOADER =============
    // batchTerms: each entry is one "term slot" (one line from textarea).
    // If a line has space-separated words, they're alternate spellings.
    // alternates: array of cleaned forms (all searched, best used in matrix).
    let batchTerms = [];       // [{original, cleaned, alternates, hits, bestSkip, bestPos, status}]
    let batchAbort = false;

    // toggleBatchPanel removed — terms panel is always visible

    window.loadBatchFile = function(input) {
      const file = input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        document.getElementById('batchTextarea').value = e.target.result;
        document.getElementById('batchParseStatus').textContent = `Loaded: ${file.name}`;
      };
      reader.readAsText(file);
    };

    window.clearBatchInput = function() {
      document.getElementById('batchTextarea').value = '';
      document.getElementById('batchParseStatus').textContent = '';
      document.getElementById('batchPreview').style.display = 'none';
      document.getElementById('batchResults').style.display = 'none';
      batchTerms = [];
    };

    // Strip name to consonantal Hebrew only
    // Normalize sofit (final-form) letters to regular form for search matching
    const SOFIT_MAP = { 'ך':'כ', 'ם':'מ', 'ן':'נ', 'ף':'פ', 'ץ':'צ' };
    function normalizeSofiot(s) {
      return s.replace(/[ךםןףץ]/g, ch => SOFIT_MAP[ch]);
    }

    // Sacred Names protection — redact last letter (or ל in אלוה/אלוהים) to prevent genizah obligation if printed
    const SACRED_NAMES_PATTERNS = [
      [/אלוהים/g, 'א*והים'],   // modern spelling
      [/אלהים/g,  'א*הים'],    // Torah consonantal
      [/אלוה/g,   'א*וה'],
      [/יהוה/g,   'יהו*'],     // Tetragrammaton
      [/אהיה/g,   'אהי*'],     // Ehyeh
      [/אדני/g,   'אדנ*'],     // Adonai
      [/שדי/g,    'שד*'],      // Shaddai
    ];
    const SACRED_EL_RE = /(^|\s)(אל)(?=\s|$)/g;

    function sanitizeSacredNames(str, includeEl) {
      if (!str || typeof str !== 'string') return str;
      for (const [pat, rep] of SACRED_NAMES_PATTERNS) str = str.replace(pat, rep);
      if (includeEl) str = str.replace(SACRED_EL_RE, '$1א*');
      return str;
    }
    function sanitizeForExport(str) { return sanitizeSacredNames(str, true); }

    function cleanHebrewName(name) {
      // Remove parenthetical content: (אדריאן), (אלכסנדר), (ג'ימי), (נטלי)
      let s = name.replace(/\([^)]*\)/g, '');
      // Remove military ranks and honorifics
      s = s.replace(/\b(אל"ם|סמ"ר|סא"ל|רס"ן|סגן|סרן|רב"ט|טור'|רס"ר|רנ"ג|רב סמל|סמל|טוראי)\s*/g, '');
      // Remove הי"ד (memorial suffix)
      s = s.replace(/הי"ד/g, '');
      // Remove quotation marks and double-quotes within abbreviations
      s = s.replace(/["״׳']/g, '');
      // Keep only Hebrew letters (strip spaces, punctuation, Latin chars, digits)
      s = s.replace(/[^\u05D0-\u05EA]/g, '');
      // Normalize final-form letters to regular form for search
      s = normalizeSofiot(s);
      return s;
    }

    window.parseBatchInput = function() {
      const text = document.getElementById('batchTextarea').value.trim();
      if (!text) { batchTerms = []; return; }

      const lines = text.split('\n').map(l => l.trim()).filter(l => l);
      batchTerms = [];
      const seen = new Set();

      for (const line of lines) {
        // Space-separated words on same line = alternate spellings
        const parts = line.split(/\s+/);
        const alternates = [];
        for (const part of parts) {
          const c = cleanHebrewName(part);
          if (c.length >= 2 && !seen.has(c)) {
            alternates.push(c);
            seen.add(c);
          }
        }
        if (alternates.length === 0) continue;
        // Primary form = first alternate; others are alt spellings
        batchTerms.push({
          original: line,
          cleaned: alternates[0],
          alternates,    // all cleaned forms for this term slot
          hits: 0,
          bestSkip: null,
          bestPos: null,
          status: 'pending'
        });
      }

      if (batchTerms.length === 0) return;

      // Show preview
      const preview = document.getElementById('batchPreview');
      preview.style.display = '';
      const totalForms = batchTerms.reduce((s, t) => s + t.alternates.length, 0);
      document.getElementById('batchPreviewCount').textContent =
        `${batchTerms.length} terms parsed` + (totalForms > batchTerms.length ? ` (${totalForms} forms incl. alternates)` : '');

      // Time estimate (count all forms)
      const skipRange = (parseInt(document.getElementById('maxSkip').value) || 500) -
                         (parseInt(document.getElementById('minSkip').value) || -500) + 1;
      const estSec = Math.round(totalForms * (skipRange / 200) * 4);
      const estMin = Math.floor(estSec / 60);
      const estRemSec = estSec % 60;
      document.getElementById('batchTimeEstimate').textContent =
        `Est. ~${estMin}m ${estRemSec}s (${skipRange} skip values)`;

      // Preview list
      let previewHtml = batchTerms.map((t, i) => {
        if (t.alternates.length > 1) {
          const altStr = t.alternates.map((a, j) => j === 0 ? `<strong>${a}</strong>` : a).join(' / ');
          return `<div style="display:inline-block;padding:3px 8px;margin:2px;background:#e3ecf7;border-radius:3px;font-size:12px;">
            ${altStr} <span style="color:#999;font-size:10px;">(alt)</span>
          </div>`;
        }
        return `<div style="display:inline-block;padding:3px 8px;margin:2px;background:#e3ecf7;border-radius:3px;font-size:12px;">
          <strong>${t.cleaned}</strong> <span style="color:#999;">\u2190 ${t.original}</span>
        </div>`;
      }).join('');
      document.getElementById('batchPreviewList').innerHTML = previewHtml;
      document.getElementById('batchParseStatus').textContent = `${batchTerms.length} terms ready`;

      // Reset results
      document.getElementById('batchResults').style.display = 'none';
      document.getElementById('batchExportBtn').style.display = 'none';
    };

    function renderBatchTable() {
      const tbody = document.getElementById('batchTableBody');
      let html = '';
      batchTerms.forEach((t, i) => {
        const statusCls = t.status === 'done' ? 'batch-status-done' :
                          t.status === 'scanning' ? 'batch-status-active' : 'batch-status-pending';
        const statusText = t.status === 'done' ? 'Done' :
                           t.status === 'scanning' ? 'Scanning...' : 'Pending';
        html += `<tr data-batch-idx="${i}">
          <td>${i + 1}</td>
          <td>${t.original}</td>
          <td style="direction:rtl;font-weight:bold;">${t.cleaned}</td>
          <td>${t.cleaned.length}</td>
          <td>${t.status === 'done' ? t.hits.toLocaleString() : '—'}</td>
          <td>${t.bestSkip !== null ? t.bestSkip : '—'}</td>
          <td class="batch-status-cell ${statusCls}">${statusText}</td>
        </tr>`;
      });
      tbody.innerHTML = html;
    }

    function updateBatchRow(idx) {
      const row = document.querySelector(`tr[data-batch-idx="${idx}"]`);
      if (!row) { renderBatchTable(); return; }
      const t = batchTerms[idx];
      const statusCls = t.status === 'done' ? 'batch-status-done' :
                        t.status === 'scanning' ? 'batch-status-active' : 'batch-status-pending';
      const statusText = t.status === 'done' ? 'Done' :
                         t.status === 'scanning' ? 'Scanning...' : 'Pending';
      row.cells[4].textContent = t.status === 'done' ? t.hits.toLocaleString() : '—';
      row.cells[5].textContent = t.bestSkip !== null ? t.bestSkip : '—';
      row.cells[6].className = 'batch-status-cell ' + statusCls;
      row.cells[6].textContent = statusText;
    }

    window.exportBatchResults = function() {
      if (batchTerms.length === 0) return;
      // CSV export
      let csv = '# NOTICE: Sacred Names of God are redacted (*) to prevent desecration if printed.\n# Electronic viewing preferred. If printed, treat with appropriate reverence.\nIndex,Original Name,Search Term,Letters,Hits,Best Skip,Best Position\n';
      batchTerms.forEach((t, i) => {
        csv += `${i+1},"${sanitizeForExport(t.original)}","${sanitizeForExport(t.cleaned)}",${t.cleaned.length},${t.hits},${t.bestSkip || ''},${t.bestPos || ''}\n`;
      });
      const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = `batch-els-results-${new Date().toISOString().slice(0,10)}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    };

    let batchSortCol = -1, batchSortAsc = true;
    window.sortBatchTable = function(col) {
      if (batchSortCol === col) { batchSortAsc = !batchSortAsc; }
      else { batchSortCol = col; batchSortAsc = true; }

      const getVal = (t, c) => {
        switch(c) {
          case 0: return batchTerms.indexOf(t);
          case 1: return t.original;
          case 2: return t.cleaned;
          case 3: return t.cleaned.length;
          case 4: return t.hits;
          case 5: return t.bestSkip || 0;
          case 6: return t.status === 'done' ? 2 : t.status === 'scanning' ? 1 : 0;
          default: return 0;
        }
      };

      batchTerms.sort((a, b) => {
        let va = getVal(a, col), vb = getVal(b, col);
        if (typeof va === 'string') return batchSortAsc ? va.localeCompare(vb) : vb.localeCompare(va);
        return batchSortAsc ? va - vb : vb - va;
      });
      renderBatchTable();
    };

    // ============= SCAN MODE: AUTO-SAVE =============
    function autoSaveSession() {
      if (scanTerms.length === 0) return;
      const hitCounts = {};
      for (const t of scanTerms) hitCounts[t] = (scanAllResults[t] || []).length;
      const session = {
        terms: scanTerms,
        hitCounts,
        clusters: scanClusters,
        clusterPValues,
        permSpanDistribution: permSpanDistribution ? permSpanDistribution.slice(0, 2000) : null,
        discoveredResults: discoveredResults.length > 0 ? discoveredResults : null,
        selectedClusterIdx: currentSelectedClusterIdx,
        is3DActive,
        savedAt: new Date().toISOString(),
        source: 'indexeddb',
        skipRange: [
          parseInt(document.getElementById('minSkip')?.value) || -500,
          parseInt(document.getElementById('maxSkip')?.value) || 500
        ]
      };
      try {
        localStorage.setItem('elsAutoSession', JSON.stringify(session));
      } catch (e) {
        session.clusters = session.clusters.slice(0, 50);
        session.permSpanDistribution = null;
        session.discoveredResults = null;
        try { localStorage.setItem('elsAutoSession', JSON.stringify(session)); } catch (_) {}
      }
      const el = document.getElementById('autoSaveStatus');
      if (el) el.textContent = 'Auto-saved ' + new Date().toLocaleTimeString();
    }

    // ============= SCAN MODE: SAVE/LOAD SESSIONS =============
    window.saveScanSession = function() {
      if (scanTerms.length === 0) { alert('No scan results to save'); return; }
      const name = `Scan ${new Date().toLocaleTimeString()}`;
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');

      // Save metadata + clusters to localStorage (small).
      // Full hit data persists in IndexedDB (ELSScanResults) — no size limit.
      const hitCounts = {};
      for (const term of scanTerms) hitCounts[term] = (scanAllResults[term] || []).length;

      sessions.unshift({
        name,
        terms: scanTerms,
        hitCounts,
        clusters: scanClusters,
        savedAt: new Date().toISOString(),
        source: 'indexeddb'  // flag: full results are in IndexedDB
      });
      if (sessions.length > 10) sessions.length = 10;
      try {
        localStorage.setItem('elsScanSessions', JSON.stringify(sessions));
      } catch (e) {
        // Clusters might be large — save without them
        sessions[0].clusters = [];
        try {
          localStorage.setItem('elsScanSessions', JSON.stringify(sessions));
        } catch (e2) {
          alert('Could not save session metadata.'); return;
        }
      }
      loadSavedScanSessions();
    };

    window.loadScanSession = async function(idx) {
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      if (!sessions[idx]) return;
      const s = sessions[idx];
      scanTerms = s.terms;
      scanClusters = s.clusters || [];

      // Restore terms into textarea
      document.getElementById('batchTextarea').value = s.terms.join('\n');
      parseBatchInput();

      // Load results from IndexedDB if available, else from legacy localStorage data
      if (s.source === 'indexeddb') {
        const status = document.getElementById('scanStatus');
        if (status) status.textContent = 'Loading results from database...';
        try {
          scanAllResults = await readAllFromScanDB(s.terms);
        } catch (e) {
          // IndexedDB data may have been cleared by browser
          scanAllResults = {};
          for (const t of s.terms) scanAllResults[t] = [];
          alert('Saved hit data was cleared by the browser. Clusters still available — re-run scan for full results.');
        }
      } else {
        // Legacy: results stored in localStorage
        scanAllResults = s.allResults || {};
      }

      await loadCharDB();
      displayScanResults(scanTerms, scanAllResults, scanClusters);
      // Auto-select first cluster and run significance test on session load
      if (scanClusters.length > 0) {
        showClusterMatrix(0);
        if (scanTerms.length >= 2) setTimeout(() => runClusterPermTest(), 100);
      }
    };

    window.deleteScanSession = function(idx) {
      if (!confirm('Delete session?')) return;
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      sessions.splice(idx, 1);
      localStorage.setItem('elsScanSessions', JSON.stringify(sessions));
      loadSavedScanSessions();
    };

    function loadSavedScanSessions() {
      const sessions = JSON.parse(localStorage.getItem('elsScanSessions') || '[]');
      const container = document.getElementById('savedScanSessions');
      if (!container) return;
      if (sessions.length === 0) {
        container.innerHTML = '<p style="font-size: 12px; color: #666; margin-top: 10px;">No saved scan sessions</p>';
        return;
      }
      let html = '';
      const esc = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
      sessions.forEach((s, i) => {
        html += `<div class="saved-item">
          <div><span class="name">${esc(s.name)}</span><br><span class="meta">${esc(s.terms.join(', '))}</span></div>
          <div><button class="btn btn-small btn-secondary" onclick="loadScanSession(${i})">Load</button>
          <button class="btn btn-small btn-danger" onclick="deleteScanSession(${i})">×</button></div>
        </div>`;
      });
      container.innerHTML = html;
    }

    window.exportScanResults = function() {
      if (scanTerms.length === 0) { alert('No results to export'); return; }
      // Sanitize terms/results for export
      const expTerms = scanTerms.map(t => sanitizeForExport(t));
      const expResults = {};
      for (const [k, v] of Object.entries(scanAllResults)) {
        expResults[sanitizeForExport(k)] = v.map(r => ({ ...r, form: r.form ? sanitizeForExport(r.form) : undefined }));
      }
      const expClusters = scanClusters.map(c => ({ ...c, hits: c.hits.map(h => ({ ...h, term: sanitizeForExport(h.term) })) }));
      const data = { terms: expTerms, allResults: expResults, clusters: expClusters, timestamp: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = `els-scan-${scanTerms.join('-')}-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    };

    window.clearScanSession = function() {
      if (!confirm('Clear all terms and results?')) return;
      document.getElementById('batchTextarea').value = '';
      batchTerms = [];
      document.getElementById('batchPreview').style.display = 'none';
      document.getElementById('batchResults').style.display = 'none';
      document.getElementById('batchParseStatus').textContent = '';
      document.getElementById('scanResults').innerHTML = '';
      document.getElementById('scanMatrixView').style.display = 'none';
      // Restore placeholder
      const ph = document.getElementById('scanMatrixPlaceholder');
      if (ph) ph.style.display = '';
      scanTerms = [];
      scanAllResults = {};
      scanClusters = [];
      current3DHits = null;
      is3DActive = false;
      destroy3DScene();
      // Reset 3D toggle button state
      const btn3d = document.getElementById('btn3DToggle');
      if (btn3d) { btn3d.textContent = '3D View'; btn3d.classList.remove('active'); }
      document.getElementById('scanMatrix2D').style.display = '';
      document.getElementById('scanMatrix3D').style.display = 'none';
      document.getElementById('btn3DPause').style.display = 'none';
      document.getElementById('btn3DReset').style.display = 'none';
      clusterPValues = [];
      permSpanDistribution = null;
      discoveredResults = [];
      currentSelectedClusterIdx = 0;
      localStorage.removeItem('elsAutoSession');
      const autoEl = document.getElementById('autoSaveStatus');
      if (autoEl) autoEl.textContent = 'Not saved yet';
    };

    // Load saved scan sessions on init
    loadSavedScanSessions();

    // ============= SCAN MODE: PDF EXPORT =============
    window.downloadMatrixPNG = function() {
      const matrixView = document.getElementById('scanMatrixView');
      if (!matrixView || matrixView.style.display === 'none') { alert('No matrix displayed'); return; }

      const grid = document.getElementById('scanMatrixGrid');
      const cells = grid.querySelectorAll('.matrix-cell');
      if (cells.length === 0) return;

      const title = document.getElementById('scanMatrixTitle').textContent;
      const cols = parseInt(grid.style.gridTemplateColumns.match(/repeat\((\d+)/)?.[1] || '30');
      const rows = Math.ceil(cells.length / cols);
      const cellSize = 22;
      const padding = 40;
      const headerHeight = 60;

      // --- Build term info lines (all terms with verses) ---
      const termLines = [];
      if (current3DHits && current3DHits.length > 0) {
        for (const h of current3DHits) {
          const color = TERM_COLORS[h.termIdx % 8];
          const verses = getVersesForHit(h.pos, h.skip, h.term.length);
          const verseStr = verses.length > 0 ? verses.join(', ') : '';
          termLines.push({ text: `${sanitizeForExport(h.term)}  pos:${h.pos.toLocaleString()} skip:${h.skip}  ${verseStr}`, color });
        }
      }

      // --- Build verse text lines (all unique verses with full text) ---
      const verseLines = [];
      if (current3DHits && charDatabase) {
        const seenVerses = new Set();
        for (const h of current3DHits) {
          for (let i = 0; i < h.term.length; i++) {
            const p = h.pos + i * h.skip;
            const vk = getVerseKey(p);
            if (vk && !seenVerses.has(vk)) {
              seenVerses.add(vk);
              const verseLabel = getVerseForPosition(p);
              const verseText = getVerseTextByKey(vk);
              if (verseLabel && verseText) {
                verseLines.push(`${verseLabel}: ${sanitizeForExport(verseText)}`);
              }
            }
          }
        }
      }

      // --- Build discovered terms lines ---
      const discLines = [];
      if (discoveredResults && discoveredResults.length > 0) {
        const allDisc = discoveredResults.filter(d => d.inDict);
        for (const d of allDisc) {
          let line = `${d.word}${d.english ? '(' + d.english + ')' : ''}(${d.word.length})  skip:${d.bestOcc.skip}  dist:${d.minDistance}  z:${d.zScore.toFixed(1)}  occ:${d.totalOccurrences}`;
          if (d.dictSource) line += `  [${d.dictSource}]`;
          if (d.definition) line += `  — ${d.definition.substring(0, 50)}`;
          discLines.push(line);
        }
      }

      // --- Compute canvas size ---
      const lineH = 18;
      const sectionGap = 14;
      const termSectionH = termLines.length > 0 ? termLines.length * lineH + sectionGap + 16 : 0;
      const verseSectionH = verseLines.length > 0 ? verseLines.length * lineH + sectionGap + 16 : 0;
      const discSectionH = discLines.length > 0 ? discLines.length * lineH + sectionGap + 16 : 0;
      const footerH = termSectionH + verseSectionH + discSectionH + 20;

      const matrixW = cols * cellSize;
      const infoW = 700;
      const canvasW = Math.max(matrixW + padding * 2, infoW + padding * 2);
      const canvasH = headerHeight + rows * cellSize + padding * 2 + footerH;

      const canvas = document.createElement('canvas');
      canvas.width = canvasW;
      canvas.height = canvasH;
      const ctx = canvas.getContext('2d');

      // Background
      ctx.fillStyle = '#1a1a28';
      ctx.fillRect(0, 0, canvasW, canvasH);

      // Title
      ctx.fillStyle = '#8bb8e8';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(title, canvasW / 2, 30);

      // Subtitle with date
      ctx.font = '11px sans-serif';
      ctx.fillStyle = '#888';
      ctx.fillText(`bible-codes.github.io — ${new Date().toLocaleDateString()}`, canvasW / 2, 48);

      // Color map
      const colorMap = {
        'term-color-0': '#ffc107', 'term-color-1': '#00bcd4', 'term-color-2': '#ff5722',
        'term-color-3': '#4caf50', 'term-color-4': '#e91e63', 'term-color-5': '#3f51b5',
        'term-color-6': '#795548', 'term-color-7': '#607d8b', 'multi-term': '#9c27b0'
      };

      // Draw matrix cells
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const matrixX = Math.floor((canvasW - matrixW) / 2);

      cells.forEach((cell, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = matrixX + col * cellSize;
        const y = headerHeight + row * cellSize;

        let bg = '#2d2d44';
        let fg = '#e0e0e0';
        for (const [cls, color] of Object.entries(colorMap)) {
          if (cell.classList.contains(cls)) {
            bg = color;
            fg = cls === 'term-color-0' || cls === 'term-color-1' ? '#000' : '#fff';
            break;
          }
        }

        ctx.fillStyle = bg;
        ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
        ctx.fillStyle = fg;
        ctx.fillText(cell.textContent, x + cellSize / 2, y + cellSize / 2);
      });

      // --- Footer sections ---
      ctx.textAlign = 'right'; // RTL-friendly
      let yPos = headerHeight + rows * cellSize + padding;

      // Terms section
      if (termLines.length > 0) {
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#8bb8e8';
        ctx.textAlign = 'left';
        ctx.fillText('Search Terms:', padding, yPos);
        yPos += lineH;
        ctx.font = '12px Courier New';
        for (const tl of termLines) {
          ctx.fillStyle = tl.color;
          ctx.fillText('■', padding, yPos);
          ctx.fillStyle = '#e0e0e0';
          ctx.textAlign = 'right';
          ctx.fillText(tl.text, canvasW - padding, yPos);
          ctx.textAlign = 'left';
          yPos += lineH;
        }
        yPos += sectionGap;
      }

      // Verses section
      if (verseLines.length > 0) {
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#a5d6a7';
        ctx.textAlign = 'left';
        ctx.fillText('Verses:', padding, yPos);
        yPos += lineH;
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#ccc';
        for (const vl of verseLines) {
          ctx.textAlign = 'right';
          ctx.fillText(vl, canvasW - padding, yPos);
          ctx.textAlign = 'left';
          yPos += lineH;
        }
        yPos += sectionGap;
      }

      // Discovered terms section
      if (discLines.length > 0) {
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#ffcc80';
        ctx.textAlign = 'left';
        ctx.fillText(`Discovered Terms (${discLines.length}):`, padding, yPos);
        yPos += lineH;
        ctx.font = '11px Courier New';
        ctx.fillStyle = '#ddd';
        for (const dl of discLines) {
          ctx.textAlign = 'right';
          ctx.fillText(dl, canvasW - padding, yPos);
          ctx.textAlign = 'left';
          yPos += lineH;
        }
      }

      // Download
      const link = document.createElement('a');
      link.download = `els-matrix-${title.replace(/[^a-zA-Z0-9א-ת]/g, '-')}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    };

    // --- Reusable: get matrix PNG as data URL ---
    function getMatrixPNGDataURL() {
      const grid = document.getElementById('scanMatrixGrid');
      const cells = grid ? grid.querySelectorAll('.matrix-cell') : [];
      if (cells.length === 0) return null;

      const title = document.getElementById('scanMatrixTitle')?.textContent || 'ELS Matrix';
      const cols = parseInt(grid.style.gridTemplateColumns.match(/repeat\((\d+)/)?.[1] || '30');
      const rows = Math.ceil(cells.length / cols);
      const cellSize = 22;
      const padding = 30;
      const headerHeight = 40;
      const matrixW = cols * cellSize;
      const canvasW = Math.max(matrixW + padding * 2, 400);
      const canvasH = headerHeight + rows * cellSize + padding;

      const canvas = document.createElement('canvas');
      canvas.width = canvasW;
      canvas.height = canvasH;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#1a1a28';
      ctx.fillRect(0, 0, canvasW, canvasH);

      ctx.fillStyle = '#8bb8e8';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(title, canvasW / 2, 25);

      const colorMap = {
        'term-color-0': '#ffc107', 'term-color-1': '#00bcd4', 'term-color-2': '#ff5722',
        'term-color-3': '#4caf50', 'term-color-4': '#e91e63', 'term-color-5': '#3f51b5',
        'term-color-6': '#795548', 'term-color-7': '#607d8b', 'multi-term': '#9c27b0'
      };

      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const matrixX = Math.floor((canvasW - matrixW) / 2);

      cells.forEach((cell, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = matrixX + col * cellSize;
        const y = headerHeight + row * cellSize;
        let bg = '#2d2d44', fg = '#e0e0e0';
        for (const [cls, color] of Object.entries(colorMap)) {
          if (cell.classList.contains(cls)) {
            bg = color;
            fg = cls === 'term-color-0' || cls === 'term-color-1' ? '#000' : '#fff';
            break;
          }
        }
        ctx.fillStyle = bg;
        ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
        ctx.fillStyle = fg;
        ctx.fillText(cell.textContent, x + cellSize / 2, y + cellSize / 2);
      });

      return canvas.toDataURL('image/png');
    }

    // --- Build standalone HTML report ---
    function buildReportHTML() {
      const title = document.getElementById('scanMatrixTitle')?.textContent || 'ELS Matrix';
      const minSkip = document.getElementById('minSkip')?.value || '-500';
      const maxSkip = document.getElementById('maxSkip')?.value || '500';
      const now = new Date().toLocaleString('he-IL');
      const matrixPNG = getMatrixPNGDataURL();

      // Gather search terms info
      let termsHTML = '';
      if (current3DHits && current3DHits.length > 0) {
        termsHTML = '<table style="width:100%;border-collapse:collapse;margin:12px 0;"><thead><tr>' +
          '<th style="border:1px solid #ccc;padding:8px;background:#1e5aa8;color:#fff;text-align:right;">Term</th>' +
          '<th style="border:1px solid #ccc;padding:8px;background:#1e5aa8;color:#fff;text-align:right;">Position</th>' +
          '<th style="border:1px solid #ccc;padding:8px;background:#1e5aa8;color:#fff;text-align:right;">Skip</th>' +
          '<th style="border:1px solid #ccc;padding:8px;background:#1e5aa8;color:#fff;text-align:right;">Verses</th>' +
          '</tr></thead><tbody>';
        for (const h of current3DHits) {
          const color = TERM_COLORS[h.termIdx % 8];
          const verses = getVersesForHit(h.pos, h.skip, h.term.length);
          termsHTML += `<tr>
            <td style="border:1px solid #ccc;padding:8px;font-weight:bold;color:${color};font-size:16px;">${sanitizeForExport(h.term)}</td>
            <td style="border:1px solid #ccc;padding:8px;">${h.pos.toLocaleString()}</td>
            <td style="border:1px solid #ccc;padding:8px;">${h.skip}</td>
            <td style="border:1px solid #ccc;padding:8px;">${verses.join(', ')}</td>
          </tr>`;
        }
        termsHTML += '</tbody></table>';
      }

      // Cluster statistics
      let clusterHTML = '';
      if (scanClusters.length > 0 && current3DHits && current3DHits.length > 1) {
        // Find matching cluster
        const hitPositions = new Set(current3DHits.map(h => `${h.pos}:${h.skip}`));
        let matchCluster = null;
        let matchIdx = -1;
        for (let i = 0; i < scanClusters.length; i++) {
          const c = scanClusters[i];
          if (c.hits.every(h => hitPositions.has(`${h.pos}:${h.skip}`))) {
            matchCluster = c;
            matchIdx = i;
            break;
          }
        }
        if (matchCluster) {
          let pStr = '';
          if (clusterPValues.length > matchIdx && permSpanDistribution) {
            const p = clusterPValues[matchIdx];
            pStr = p === 0 ? '< ' + (1 / permSpanDistribution.length).toFixed(6) : p < 0.001 ? p.toExponential(2) : p.toFixed(4);
            const sigLabel = p < 0.01 ? 'Highly Significant' : p < 0.05 ? 'Significant' : p < 0.1 ? 'Marginal' : 'Not Significant';
            clusterHTML = `<p><strong>Span:</strong> ${matchCluster.span.toLocaleString()} characters &nbsp;|&nbsp; <strong>P-value:</strong> ${pStr} &nbsp;|&nbsp; <strong>Significance:</strong> ${sigLabel}</p>`;
          } else {
            clusterHTML = `<p><strong>Span:</strong> ${matchCluster.span.toLocaleString()} characters</p>`;
          }
        }
      }

      // Verse texts
      let versesHTML = '';
      if (current3DHits && charDatabase) {
        const seenVerses = new Set();
        const verseList = [];
        for (const h of current3DHits) {
          for (let i = 0; i < h.term.length; i++) {
            const p = h.pos + i * h.skip;
            const vk = getVerseKey(p);
            if (vk && !seenVerses.has(vk)) {
              seenVerses.add(vk);
              const verseLabel = getVerseForPosition(p);
              const verseText = getVerseTextByKey(vk);
              if (verseLabel && verseText) {
                const sum = getVerseSummary(vk);
                verseList.push({ label: verseLabel, text: verseText, key: vk, summary: sum });
              }
            }
          }
        }
        if (verseList.length > 0) {
          versesHTML = '<div style="margin:12px 0;">';
          for (const v of verseList) {
            const sumLine = v.summary ? `<div style="font-size:13px;color:#555;font-style:italic;margin-top:2px;">${v.summary.s}${v.summary.feel ? ' — ' + v.summary.feel : ''}${v.summary.who ? ' [' + v.summary.who.join(', ') + ']' : ''}</div>` : '';
            versesHTML += `<div style="padding:6px 10px;margin:4px 0;background:#f5f5f5;border-radius:4px;border-right:3px solid #1e5aa8;">
              <strong style="color:#1e5aa8;">${v.label}</strong>: <span style="font-family:serif;font-size:16px;">${sanitizeForExport(v.text)}</span>${sumLine}
            </div>`;
          }
          versesHTML += '</div>';
        }
      }

      // Discovered terms
      let discHTML = '';
      if (discoveredResults && discoveredResults.length > 0) {
        const allDisc = discoveredResults.filter(d => d.inDict);
        if (allDisc.length > 0) {
          discHTML = '<table style="width:100%;border-collapse:collapse;margin:12px 0;font-size:13px;"><thead><tr>' +
            '<th style="border:1px solid #ccc;padding:6px;background:#2e7d32;color:#fff;text-align:right;">Term</th>' +
            '<th style="border:1px solid #ccc;padding:6px;background:#2e7d32;color:#fff;text-align:right;">Definition</th>' +
            '<th style="border:1px solid #ccc;padding:6px;background:#2e7d32;color:#fff;text-align:right;">Root</th>' +
            '<th style="border:1px solid #ccc;padding:6px;background:#2e7d32;color:#fff;text-align:right;">Distance</th>' +
            '<th style="border:1px solid #ccc;padding:6px;background:#2e7d32;color:#fff;text-align:right;">Skip</th>' +
            '<th style="border:1px solid #ccc;padding:6px;background:#2e7d32;color:#fff;text-align:right;">z-score</th>' +
            '<th style="border:1px solid #ccc;padding:6px;background:#2e7d32;color:#fff;text-align:right;">Source</th>' +
            '</tr></thead><tbody>';
          for (const d of allDisc) {
            const def = d.definition ? d.definition.substring(0, 80) : (d.english || '');
            discHTML += `<tr>
              <td style="border:1px solid #ccc;padding:6px;font-weight:bold;font-size:15px;">${sanitizeForExport(d.word)}</td>
              <td style="border:1px solid #ccc;padding:6px;">${def}</td>
              <td style="border:1px solid #ccc;padding:6px;">${d.root || ''}</td>
              <td style="border:1px solid #ccc;padding:6px;">${d.minDistance}</td>
              <td style="border:1px solid #ccc;padding:6px;">${d.bestOcc ? d.bestOcc.skip : ''}</td>
              <td style="border:1px solid #ccc;padding:6px;">${d.zScore.toFixed(1)}</td>
              <td style="border:1px solid #ccc;padding:6px;">${d.dictSource || ''}</td>
            </tr>`;
          }
          discHTML += '</tbody></table>';
        }
      }

      return `<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ELS Report — ${sanitizeForExport(title)}</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 960px; margin: 0 auto; padding: 20px; color: #333; direction: rtl; }
  h1 { color: #1e5aa8; border-bottom: 2px solid #1e5aa8; padding-bottom: 8px; }
  h2 { color: #333; margin-top: 24px; border-bottom: 1px solid #ccc; padding-bottom: 6px; }
  .meta { color: #666; font-size: 13px; margin-bottom: 20px; }
  img { max-width: 100%; border-radius: 8px; margin: 12px 0; }
  table { direction: rtl; }
  @media print {
    body { margin: 0; padding: 10px; }
    .no-print { display: none; }
    img { max-height: 400px; object-fit: contain; }
  }
</style>
</head>
<body>
<h1>${sanitizeForExport(title)}</h1>
<div class="meta">Generated: ${now} &nbsp;|&nbsp; Skip range: ${minSkip} to ${maxSkip} &nbsp;|&nbsp; bible-codes.github.io</div>

<h2>Matrix</h2>
${matrixPNG ? `<img src="${matrixPNG}" alt="ELS Matrix">` : '<p>Matrix image not available</p>'}

<h2>Search Terms</h2>
${termsHTML || '<p>No terms</p>'}

${clusterHTML ? '<h2>Cluster Statistics</h2>' + clusterHTML : ''}

<h2>Verse Texts</h2>
${versesHTML || '<p>No verse data available</p>'}

${discHTML ? '<h2>Discovered Terms</h2>' + discHTML : ''}

<hr style="margin-top:30px;border:none;border-top:1px solid #ccc;">
<div style="text-align:center;font-size:12px;color:#999;margin-top:10px;">
  Generated by <a href="https://bible-codes.github.io" style="color:#1e5aa8;">bible-codes.github.io</a> — ELS Search Tool
</div>
</body>
</html>`;
    }

    // --- Download report as HTML file ---
    window.downloadReportHTML = function() {
      if (!current3DHits || current3DHits.length === 0) { alert('No matrix displayed'); return; }
      const html = buildReportHTML();
      const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
      const link = document.createElement('a');
      const title = document.getElementById('scanMatrixTitle')?.textContent || 'ELS';
      link.download = `els-report-${title.replace(/[^a-zA-Z0-9א-ת]/g, '-')}-${new Date().toISOString().slice(0,10)}.html`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    };

    // --- Download report as PDF (via browser print dialog) ---
    window.downloadReportPDF = function() {
      if (!current3DHits || current3DHits.length === 0) { alert('No matrix displayed'); return; }
      const html = buildReportHTML();
      const win = window.open('', '_blank');
      if (!win) { alert('Pop-up blocked. Please allow pop-ups for this site.'); return; }
      win.document.write(html);
      win.document.close();
      win.focus();
      setTimeout(() => win.print(), 500);
    };

    // --- Export matrix data as JSON ---
    window.exportMatrixJSON = function() {
      if (!current3DHits || current3DHits.length === 0) { alert('No matrix displayed'); return; }
      const title = document.getElementById('scanMatrixTitle')?.textContent || 'ELS Matrix';

      // Terms with verse info
      const terms = current3DHits.map(h => {
        const verses = getVersesForHit(h.pos, h.skip, h.term.length);
        const verseTexts = [];
        if (charDatabase) {
          const seen = new Set();
          for (let i = 0; i < h.term.length; i++) {
            const vk = getVerseKey(h.pos + i * h.skip);
            if (vk && !seen.has(vk)) {
              seen.add(vk);
              const txt = getVerseTextByKey(vk);
              if (txt) {
                const entry = { ref: getVerseForPosition(h.pos + i * h.skip), text: txt };
                const sum = getVerseSummary(vk);
                if (sum) { entry.summary = sum.s; entry.sentiment = sum.feel; entry.subjects = sum.who; entry.themes = sum.t; }
                verseTexts.push(entry);
              }
            }
          }
        }
        return { term: sanitizeForExport(h.term), position: h.pos, skip: h.skip, termIndex: h.termIdx, verses, verseTexts: verseTexts.map(vt => ({ ...vt, text: sanitizeForExport(vt.text) })) };
      });

      // Discovered terms
      const discovered = (discoveredResults || []).filter(d => d.inDict).map(d => ({
        word: sanitizeForExport(d.word), english: d.english || '', skip: d.bestOcc.skip, position: d.bestOcc.pos, distance: d.minDistance,
        zScore: d.zScore, pValue: d.pValue, source: d.dictSource, definition: d.definition, root: d.root,
        isName: d.isName, isDate: d.isDate,
      }));

      const data = { title, exportedAt: new Date().toISOString(), searchTerms: terms, discoveredTerms: discovered };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const link = document.createElement('a');
      link.download = `els-matrix-${title.replace(/[^a-zA-Z0-9א-ת]/g, '-')}.json`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    };

    // ============= DICTIONARY MODE =============
    let dictData = null;
    let dictLoaded = false;

    async function loadDict() {
      if (dictLoaded) return;
      try {
        const resp = await fetch('data/dictionaries/unified/hebrew-unified.json.gz');
        const blob = await resp.blob();
        const ds = new DecompressionStream('gzip');
        const text = await new Response(blob.stream().pipeThrough(ds)).text();
        dictData = JSON.parse(text);
        dictLoaded = true;
        document.getElementById('dictLoading')?.remove();
        document.getElementById('dictContent')?.style && (document.getElementById('dictContent').style.display = 'block');
      } catch (err) {
        console.warn('Dictionary load deferred:', err.message);
      }
    }

    // Load dict when switching to dict tab
    document.querySelectorAll('.mode-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        if (tab.dataset.mode === 'dict' && !dictLoaded) {
          loadDict();
        }
      });
    });

    window.searchDict = function() {
      if (!dictData) return;
      const query = document.getElementById('dictSearch').value.trim();
      const source = document.getElementById('dictSource').value;
      if (!query) { browseDict('random'); return; }

      const results = [];
      for (const [word, entry] of Object.entries(dictData)) {
        if (source !== 'all' && entry.source !== source) continue;
        if (word.includes(query)) {
          results.push({ word, ...entry });
          if (results.length >= 100) break;
        }
      }

      displayDictResults(results, `Search: "${query}"`);
    };

    window.browseDict = function(mode) {
      if (!dictData) return;
      const source = document.getElementById('dictSource').value;
      const words = Object.entries(dictData)
        .filter(([w, e]) => source === 'all' || e.source === source);

      let results;
      if (mode === 'random') {
        const shuffled = words.sort(() => Math.random() - 0.5);
        results = shuffled.slice(0, 50).map(([word, entry]) => ({ word, ...entry }));
      } else {
        // Sort by some metric - for now just alphabetical
        results = words.slice(0, 50).map(([word, entry]) => ({ word, ...entry }));
      }

      displayDictResults(results, mode === 'random' ? 'Random Words' : 'Browse');
    };

    function displayDictResults(results, title) {
      if (results.length === 0) {
        document.getElementById('dictResults').innerHTML = '<div class="results"><p>No results found</p></div>';
        return;
      }

      let html = `<div class="results"><h3>${title} (${results.length})</h3>`;
      html += '<p style="font-size:12px;color:var(--gray);margin-bottom:10px;">Click word to search in ELS index, or + to add as search term</p>';
      html += '<div class="results-scrollable">';
      results.forEach(r => {
        const def = r.definition || r.gloss || r.meaning || '';
        const srcBadge = r.source ? `<span style="background:#ddd;padding:2px 6px;border-radius:3px;font-size:11px;">${r.source}</span>` : '';
        const inIndex = elsService?.hasWord(r.word);
        const indexBadge = inIndex ? '<span style="background:#d4edda;color:#2e7d32;padding:2px 6px;border-radius:3px;font-size:11px;">in index</span>' : '';
        html += `<div style="padding:12px;border-bottom:1px solid var(--border);cursor:pointer;transition:background 0.15s;"
                     onmouseover="this.style.background='var(--blue-light)'"
                     onmouseout="this.style.background='transparent'">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <span style="font-size:20px;font-weight:bold;color:var(--blue);" onclick="searchWordInELS('${r.word}')">${sanitizeSacredNames(r.word)}</span>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="btn btn-small" onclick="event.stopPropagation();addWordToSearch('${r.word}')" title="Add to search terms">+</button>
              ${indexBadge}
              ${srcBadge}
            </div>
          </div>
          ${def ? `<div style="color:var(--gray);margin-top:4px;">${def.substring(0, 200)}${def.length > 200 ? '...' : ''}</div>` : ''}
          ${r.root ? `<div style="font-size:12px;color:#888;margin-top:4px;">Root: ${sanitizeSacredNames(r.root)}</div>` : ''}
        </div>`;
      });
      html += '</div></div>';
      document.getElementById('dictResults').innerHTML = html;
    }

    window.searchWordInELS = function(word) {
      // Switch to index mode and lazy-load ELS index
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('.mode-tab[data-mode="index"]').classList.add('active');
      document.getElementById('index-mode').classList.add('active');
      initIndexTab();

      // Set the word as first term and search
      const container = document.getElementById('termEntries');
      container.innerHTML = `<div class="term-entry">
        <input type="text" class="term-input" value="${word}" dir="rtl">
        <button class="remove-btn" onclick="removeTerm(this)">&times;</button>
      </div>`;

      // Run search
      if (elsService) {
        const occs = elsService.findWord(word);
        currentResults = {
          terms: [word],
          termData: { [word]: { occurrences: occs, count: occs.length } },
          proximityPairs: [],
          timestamp: new Date().toISOString()
        };
        displayIndexResults(currentResults);
      }
    };

    window.addWordToSearch = function(word) {
      // Switch to index mode and lazy-load ELS index
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('.mode-tab[data-mode="index"]').classList.add('active');
      document.getElementById('index-mode').classList.add('active');
      initIndexTab();

      // Add word as new term
      const container = document.getElementById('termEntries');
      const n = container.querySelectorAll('.term-entry').length + 1;
      const div = document.createElement('div');
      div.className = 'term-entry';
      div.innerHTML = `<input type="text" class="term-input" value="${word}" dir="rtl"><button class="remove-btn" onclick="removeTerm(this)">&times;</button>`;
      container.appendChild(div);
    };

    // ============= WRR 1994 EXPERIMENT — ACADEMIC REPLICATION =============
    // Reference: Witztum, Rips & Rosenberg, "Equidistant Letter Sequences in
    // the Book of Genesis", Statistical Science, Vol. 9, No. 3, 1994, 429-438.
    //
    // Algorithm:
    // 1. Dynamic skip range D(w) per term based on expected ELS occurrence count
    // 2. Find ALL ELS occurrences of each name/date form with |skip| in [2, D(w)]
    // 3. 2D Euclidean distance on cylindrical array (width = |skip|)
    // 4. Both array orientations tested (width = |d_name| and |d_date|)
    // 5. Only |skip| >= 2 (open text excluded per WRR definition)
    // 6. Sofiot normalized to standard forms for matching

    const WRR_GENESIS_LEN = 78064;

    // WRR List 2: 32 rabbis from Encyclopedia of Great Men in Israel.
    // FULL canonical 174 appellations from WRR2.txt (McKay ANU archive, MC transliteration).
    // Each appellation is a single consonantal Hebrew word (no spaces) — searched as ELS.
    // Rabbis 4 and 8 have no recorded death dates — excluded from analysis.
    // Word pairs filtered to 5-8 characters per WRR paper (p.436, Section A.3).
    const WRR_RABBIS = [
      { id:1, en:"Abraham ben David (RABaD)", names:["רביאברהמ","הראבי","הרבאבד","הראבד","האשכול","בעלהאשכול","ראבי","הרבאבביתדינ","ראבד"], dates:["כ חשונ","כ בחשונ","בכ חשונ"] },
      { id:2, en:"Abraham Yitzhaki", names:["רביאברהמ","יצחקי","זרעאברהמ","בעלזרעאברהמ","אברהמיצחקי"], dates:["יג סיונ","יג בסיונ","ביג סיונ"] },
      { id:3, en:"Abraham HaMalakh", names:["רביאברהמ","המלאכ","חסדלאברהמ","בעלחסדלאברהמ"], dates:["יב תשרי","יב בתשרי","ביב תשרי"] },
      { id:4, en:"Abraham Saba", names:["רביאברהמ","אברהמסבע","צרורהמר","בעלצרורהמר"], dates:[] },
      { id:5, en:"Aaron HaGadol of Karlin", names:["רביאהרנ","אהרנהגדולמקרלינ"], dates:["יט ניסנ","יט בניסנ","ביט ניסנ"] },
      { id:6, en:"Eliezer Ashkenazi", names:["מעשיהשמ","מעשייהוה","בעלמעשיהשמ","בעלמעשייהוה","אליעזראשכנזי","רביאליעזר"], dates:["כב כסלו","כב בכסלו","בכב כסלו"] },
      { id:7, en:"David Oppenheim", names:["רבידוד","אופנהימ","הרדא","מהרדאופנהימ","דודאופנהימ"], dates:["ז תשרי","ז בתשרי","בז תשרי"] },
      { id:8, en:"David HaNagid", names:["רבידוד","דודהנגיד"], dates:[] },
      { id:9, en:"David Nieto", names:["רבידוד","דודניטו","הכוזריהשני","בעלהכוזריהשני","ניטו"], dates:["כח טבת","כח בטבת","בכח טבת"] },
      { id:10, en:"Hayyim Abulafia", names:["רביחיימ","חיימאבואלעפיה","אבואלעפיה"], dates:["ו ניסנ","ו בניסנ","בו ניסנ"] },
      { id:11, en:"Hayyim Benveniste", names:["רביחיימ","בנבנשת","כנסתהגדולה","בעלכנסתהגדולה","חיימבנבנשת"], dates:["יט אלול","יט באלול","ביט אלול"] },
      { id:12, en:"Hayyim Capusi", names:["רביחיימ","כפוסי","בעלנס","בעלהנס","חיימכפוסי"], dates:["יב שבט","יב בשבט","ביב שבט"] },
      { id:13, en:"Hayyim Shabetai", names:["רביחיימ","חיימשבתי","מהרחש","המהרחש"], dates:["יג ניסנ","יג בניסנ","ביג ניסנ"] },
      { id:14, en:"Yair Hayyim Bacharach", names:["חותיאיר","בעלחותיאיר","יאירחיימבכרכ","בכרכ","רבייאירחיימ"], dates:["א טבת","א בטבת","בא טבת"] },
      { id:15, en:"Yehuda HeHasid", names:["רבייהודה","יהודהחסיד","יהודההחסיד"], dates:["ה חשונ","ה בחשונ","בה חשונ"] },
      { id:16, en:"Yehuda Ayash", names:["רבייהודה","מהריעיאש","יהודהעיאש","עיאש"], dates:["א תשרי","א בתשרי","בא תשרי"] },
      { id:17, en:"Yehosef HaNagid", names:["רבייהוספ"], dates:["ט טבת","ט בטבת","בט טבת"] },
      { id:18, en:"Yehoshua (Maginei Shlomo)", names:["רבייהושע","מגנישלמה"], dates:["כז אב","כז באב","בכז אב"] },
      { id:19, en:"Yosef di Trani (MaHaRiT)", names:["רבייוספ","מטרני","יוספטרני","טראני","מטראני","מהרימט","המהרימט","מהריט","המהריט","יוספמטרני","יוספטראני","יוספמטראני","טרני"], dates:["יד תמוז","יד בתמוז","ביד תמוז"] },
      { id:20, en:"Yosef Te'omim", names:["רבייוספ","תאומימ","פרימגדימ","בעלפרימגדימ","יוספתאומימ"], dates:["ד איר","ד באיר","בד איר"] },
      { id:21, en:"Ya'akov BeRav", names:["רבייעקב","יעקבבירב","מהריבירב","הריבר","בירב"], dates:["ל ניסנ","ל בניסנ","בל ניסנ"] },
      { id:22, en:"Yisrael Ya'akov Hagiz", names:["חאגיז","בעלהלקט","הלקט","ישראליעקב","רביישראליעקב"], dates:["כו שבט","כו בשבט","בכו שבט"] },
      { id:23, en:"Ya'akov Moelin (MaHaRIL)", names:["רבייעקב","מולינ","יעקבסגל","יעקבהלוי","מהריסגל","מהריהלוי","מהריל","המהריל","יעקבמולינ"], dates:["כב אלול","כב באלול","בכב אלול"] },
      { id:24, en:"Ya'akov Emden (Ya'avetz)", names:["היעבצ","הריעבצ","עמדינ","הריעמדנ","הריעמדינ","יעקבישראלעמדנ","יעקבישראלעמדינ","עמדנ","רבייעקבישראל"], dates:["ל ניסנ","ל בניסנ","בל ניסנ"] },
      { id:25, en:"Yitzhak HaLevi Horowitz", names:["רבייצחק","הורוויצ","יצחקהלוי","רביאיצקלהמבורגר","יצחקהלויאישהורוויצ"], dates:["ו איר","ו באיר","בו איר"] },
      { id:26, en:"Menachem Mendel Krochmal", names:["רבימנחמ","קרוכמל","רבימענדל","צמחצדק","בעלצמחצדק","מנחממענדל"], dates:["ב שבט","ב בשבט","בב שבט"] },
      { id:27, en:"Moshe Zacuto", names:["רבימשה","זכותא","זכותו","משהזכות","משהזכותא","משהזכותו","מהרמזכות","מהרמז","המהרמז","המזלנ","קולהרמז","מזלנ","בעלקולהרמז","זכות"], dates:["טז תשרי","טז בתשרי","בטז תשרי","יו תשרי","יו בתשרי","ביו תשרי"] },
      { id:28, en:"Moshe Margalit", names:["רבימשה","מרגלית","פנימשה","בעלפנימשה","משהמרגלית"], dates:["יב טבת","יב בטבת","ביב טבת"] },
      { id:29, en:"Azariah Figo", names:["רביעזריה","עזריהפיגו"], dates:["א אדרא","א באדרא","בא אדרא"] },
      { id:30, en:"Immanuel Hai Ricchi", names:["אחהער","ישרלבב","משנתחסידימ","בעלמשנתחסידימ","בעלישרלבב","עמנואלחירפאלריקי","ריקי","רביעמנואלחירפאל"], dates:["א אדר","א באדר","בא אדר"] },
      { id:31, en:"Shalom Sharabi (RaShaSh)", names:["רבישלומ","מזרחי","שרעבי","שרשלומ","מהרשש","המהרשש","שמש","השמש","שלוממזרחי"], dates:["י שבט","י בשבט","בי שבט"] },
      { id:32, en:"Shlomo HaMa'almi", names:["רבישלמה","מרכבתהמשנה","בעלמרכבתהמשנה","שלמהמחלמא","שלמהמחעלמא"], dates:["כא תמוז","כא בתמוז","בכא תמוז"] }
    ];

    // WRR List 1: 34 rabbis (major figures). Converted from WRR1.txt (McKay ANU archive).
    // Rabbi 23 (Rif) has no recorded death date — excluded from analysis.
    const WRR_RABBIS_LIST1 = [
      { id:1, en:"Abraham ben David (RABaD)", names:["רביאברהמ","הראבד","בעלההשגות","ראבד"], dates:["כו כסלו","כו בכסלו","בכו כסלו"] },
      { id:2, en:"Abraham the Pious (ben HaRambam)", names:["רביאברהמ","אברהמהחסיד","אברהמבנהרמבמ"], dates:["יח כסלו","יח בכסלו","ביח כסלו"] },
      { id:3, en:"Abraham ibn Ezra", names:["רביאברהמ","אבנעזרא","בנעזרא","הראבע","ראבע","אברהמבנעזרא","אברהמאבנעזרא"], dates:["א אדרא","א באדרא","בא אדרא"] },
      { id:4, en:"Eliyahu Bahur", names:["רביאליהו","הבחור","בעלהבחור","אליהוהלוי"], dates:["ו שבט","ו בשבט","בו שבט"] },
      { id:5, en:"Eliyahu (the GR\"A)", names:["רביאליהו","הגאונ","הגרא","הגאונמוילנא"], dates:["טו ניסנ","טו בניסנ","בטו ניסנ","יה ניסנ","יה בניסנ","ביה ניסנ","יט תשרי","יט בתשרי","ביט תשרי"] },
      { id:6, en:"Gershon Ashkenazi", names:["רביגרשונ","הגרשני","בעלעבודתהגרשני","גרשונאשכנזי"], dates:["י אדרב","י באדרב","בי אדרב"] },
      { id:7, en:"David Ganz", names:["רבידוד","דודגנז","דודגאנז","צמחדוד","בעלצמחדוד"], dates:["ה אלול","ה באלול","בה אלול"] },
      { id:8, en:"David HaLevi (the TaZ)", names:["רבידוד","דודהלוי","בעלהטז","הטז"], dates:["כו שבט","כו בשבט","בכו שבט"] },
      { id:9, en:"Hayyim ibn Attar", names:["רביחיימ","בנעטר","אבנעטר","אורהחיימ","בעלאורהחיימ","חיימבנעטר","חיימאבנעטר"], dates:["טו תמוז","טו בתמוז","בטו תמוז","יה תמוז","יה בתמוז","ביה תמוז"] },
      { id:10, en:"Yehuda ben HaRosh", names:["רבייהודה","יהודהבנהראש"], dates:["יז תמוז","יז בתמוז","ביז תמוז"] },
      { id:11, en:"Yehuda HeHasid (of Regensburg)", names:["רבייהודה","בעלספרחסידימ","יהודההחסיד"], dates:["יג אדר","יג באדר","ביג אדר"] },
      { id:12, en:"Yehuda Loew (MaHaRaL of Prague)", names:["רבייהודה","רביליוא","המהרל","מהרלמפרג","מהרלמפראג","מהרל"], dates:["יח אלול","יח באלול","ביח אלול"] },
      { id:13, en:"Yonatan Eybeschutz", names:["רבייונתנ","איבשיצ","בעלהתמימ","יונתנפרגר","יונתנאיבשיצ","יונתנפראגר","יהונתנאיבשיצ","רבייהונתנ"], dates:["כא אלול","כא באלול","בכא אלול"] },
      { id:14, en:"Yehoshua (Penei Yehoshua)", names:["רבייהושע","רביהעשיל"], dates:["כ תשרי","כ בתשרי","בכ תשרי"] },
      { id:15, en:"Yehoshua Falk (the SM\"A)", names:["רבייהושע","בעלהסמע","הסמע","יהושעפלקכצ","יהושעולקכצ"], dates:["יט ניסנ","יט בניסנ","ביט ניסנ"] },
      { id:16, en:"Yoel Sirkis (the Ba\"CH)", names:["רבייואל","סירקש","בעלהבח","הבח","יואלסירקש"], dates:["כ אדר","כ באדר","בכ אדר"] },
      { id:17, en:"Yom Tov Lipmann Heller", names:["העלר","רבייומטוב","בעלתוספותיומטוב","תוספותיומטוב","יומטובליפמנהעלר"], dates:["ו אלול","ו באלול","בו אלול"] },
      { id:18, en:"Yonah Gerondi", names:["רבייונה","רבנויונה","יונהגרונדי"], dates:["ח חשונ","ח בחשונ","בח חשונ"] },
      { id:19, en:"Yosef Karo", names:["רבייוספ","יוספקרו","יוספקארו","מהריקרו","מהריקארו","ביתיוספ","המחבר","קרו","קארו","בעלביתיוספ"], dates:["יג ניסנ","יג בניסנ","ביג ניסנ"] },
      { id:20, en:"Yehezkel Landau (Noda BiYehuda)", names:["בעלהצלח","נודעביהודה","יחזקאללנדא","לנדא","רבייחזקאל","בעלנורעביהודה","הצלח"], dates:["יח חשונ","יח בחשונ","ביח חשונ","יז איר","יז באיר","ביז איר"] },
      { id:21, en:"Ya'akov Yehoshua Falk (Penei Yehoshua)", names:["פנייהושע","בעלפנייהושע","יעקביהושעפלק","פלק","רבייעקביהושע","פאלק","יעקביהושעפאלק"], dates:["כח כסלו","כח בכסלו","בכח כסלו","יד שבט","יד בשבט","ביד שבט"] },
      { id:22, en:"Ya'akov Tam (Rabbeinu Tam)", names:["רבייעקב","רבנותמ"], dates:["ד תמוז","ד בתמוז","בד תמוז"] },
      { id:23, en:"Yitzhak Alfasi (the Rif)", names:["רבייצחק","אלפסי","רבאלפס","בעלההלכות","ריפ","הריפ","יצחקאלפסי"], dates:[] },
      { id:24, en:"Yisrael Ba'al Shem Tov", names:["רביישראל","בעלשמטוב","הבעשט","בעשט"], dates:["יח אלול","יח באלול","ביח אלול"] },
      { id:25, en:"Meir of Rothenburg (MaHaRaM)", names:["רבימאיר","המהרמ","מהרמ","מהרממרוטמבורג","מהרמברברוכ"], dates:["יט איר","יט באיר","ביט איר"] },
      { id:26, en:"Mordechai Yaffe (the Levush)", names:["רבימרדכי","מרדכייפה","הלבוש","בעלהלבוש","בעלהלבושימ","יפה"], dates:["ג אדרב","ג באדרב","בג אדרב"] },
      { id:27, en:"Moshe Isserles (the Rema)", names:["רבימשה","איסרלש","הרמא","משהאיסרלש"], dates:["יח איר","יח באיר","ביח איר"] },
      { id:28, en:"Moshe Hayyim Luzzatto (RaMCHaL)", names:["לוצטו","לוצאטו","הרמחל","רמחל","משהחיימלוצטו","רבימשהחיימ","משהחיימלוצאטו"], dates:["כו איר","כו באיר","בכו איר"] },
      { id:29, en:"Moshe ben Maimon (Rambam)", names:["רבימשה","הרמבמ","רמבמ","משהבנמימונ","משהבנמימונהספרדי"], dates:["כ טבת","כ בטבת","בכ טבת","יד ניסנ","יד בניסנ","ביד ניסנ"] },
      { id:30, en:"Tzvi Ashkenazi (Hakham Tzvi)", names:["רביצבי","חכמצבי","צביאשכנזי"], dates:["א איר","א באיר","בא איר"] },
      { id:31, en:"Shabtai HaKohen (the ShaKH)", names:["רבישבתי","שבתיכהנ","שבתיהכהנ","בעלהשכ","השכ"], dates:["א אדרא","א באדרא","בא אדרא"] },
      { id:32, en:"Shlomo Yitzhaki (Rashi)", names:["רבישלמה","רשי","שלמהיצחקי"], dates:["כט תמוז","כט בתמוז","בכט תמוז"] },
      { id:33, en:"Shlomo Luria (MaHaRShaL)", names:["רבישלמה","לוריא","מהרשל","המהרשל","שלמהלוריאאשכנזי"], dates:["יב כסלו","יב בכסלו","ביב כסלו"] },
      { id:34, en:"Shmuel Eliezer Eidels (MaHaRSHA)", names:["אידלש","מהרשא","המהרשא","שמואלאליעזראידלש","רבישמואלאליעזר"], dates:["ה כסלו","ה בכסלו","בה כסלו"] }
    ];

    // WRR2 Nations (Genesis 10 "Table of Nations") — 68 nations, Sample B3
    // Reference: Witztum, Rips & Rosenberg, "Equidistant Letter Sequences in the
    // Book of Genesis — II" (unpublished sequel). 68 nation names from Genesis 10,
    // each paired with 5 category expressions (nation, plural, country, language, script).
    // Names → ELS search; Expressions → SL (consecutive letters) search.
    const WRR2_NATIONS = [
      // === Sons of Japheth (Genesis 10:2-4) — 14 nations ===
      { id:1, en:"Gomer", name:"גמר" },
      { id:2, en:"Magog", name:"מגוג" },
      { id:3, en:"Madai", name:"מדי" },
      { id:4, en:"Javan", name:"יון" },
      { id:5, en:"Tubal", name:"תבל" },
      { id:6, en:"Meshech", name:"משך" },
      { id:7, en:"Tiras", name:"תירס" },
      { id:8, en:"Ashkenaz", name:"אשכנז" },
      { id:9, en:"Riphath", name:"ריפת" },
      { id:10, en:"Togarmah", name:"תגרמה" },
      { id:11, en:"Elishah", name:"אלישה" },
      { id:12, en:"Tarshish", name:"תרשיש" },
      { id:13, en:"Kittim", name:"כתים" },
      { id:14, en:"Dodanim", name:"דדנים" },
      // === Sons of Ham (Genesis 10:6-18) — 30 nations ===
      { id:15, en:"Cush", name:"כוש" },
      { id:16, en:"Mizraim", name:"מצרים" },
      { id:17, en:"Put", name:"פוט" },
      { id:18, en:"Canaan", name:"כנען" },
      { id:19, en:"Seba", name:"סבא" },
      { id:20, en:"Havilah", name:"חוילה" },
      { id:21, en:"Sabtah", name:"סבתה" },
      { id:22, en:"Raamah", name:"רעמה" },
      { id:23, en:"Sabteca", name:"סבתכא" },
      { id:24, en:"Sheba", name:"שבא" },
      { id:25, en:"Dedan", name:"דדן" },
      { id:26, en:"Nimrod", name:"נמרד" },
      { id:27, en:"Ludim", name:"לודים" },
      { id:28, en:"Anamim", name:"ענמים" },
      { id:29, en:"Lehabim", name:"להבים" },
      { id:30, en:"Naphtuhim", name:"נפתחים" },
      { id:31, en:"Pathrusim", name:"פתרסים" },
      { id:32, en:"Casluhim", name:"כסלחים" },
      { id:33, en:"Caphtorim", name:"כפתרים" },
      { id:34, en:"Sidon", name:"צידן" },
      { id:35, en:"Heth", name:"חת" },
      { id:36, en:"Jebusite", name:"יבוסי" },
      { id:37, en:"Amorite", name:"אמרי" },
      { id:38, en:"Girgashite", name:"גרגשי" },
      { id:39, en:"Hivite", name:"חוי" },
      { id:40, en:"Arkite", name:"ערקי" },
      { id:41, en:"Sinite", name:"סיני" },
      { id:42, en:"Arvadite", name:"ארודי" },
      { id:43, en:"Zemarite", name:"צמרי" },
      { id:44, en:"Hamathite", name:"חמתי" },
      // === Sons of Shem (Genesis 10:22-29) — 24 nations (שבא and חוילה in Ham) ===
      { id:45, en:"Elam", name:"עילם" },
      { id:46, en:"Asshur", name:"אשור" },
      { id:47, en:"Arphaxad", name:"ארפכשד" },
      { id:48, en:"Lud", name:"לוד" },
      { id:49, en:"Aram", name:"ארם" },
      { id:50, en:"Uz", name:"עוץ" },
      { id:51, en:"Hul", name:"חול" },
      { id:52, en:"Gether", name:"גתר" },
      { id:53, en:"Mash", name:"מש" },
      { id:54, en:"Shelah", name:"שלח" },
      { id:55, en:"Eber", name:"עבר" },
      { id:56, en:"Peleg", name:"פלג" },
      { id:57, en:"Joktan", name:"יקטן" },
      { id:58, en:"Almodad", name:"אלמודד" },
      { id:59, en:"Sheleph", name:"שלף" },
      { id:60, en:"Hazarmaveth", name:"חצרמות" },
      { id:61, en:"Jerah", name:"ירח" },
      { id:62, en:"Hadoram", name:"הדורם" },
      { id:63, en:"Uzal", name:"אוזל" },
      { id:64, en:"Diklah", name:"דקלה" },
      { id:65, en:"Obal", name:"עובל" },
      { id:66, en:"Abimael", name:"אבימאל" },
      { id:67, en:"Ophir", name:"אופיר" },
      { id:68, en:"Jobab", name:"יובב" }
    ].map(n => {
      // Generate 5 formulaic category expressions per nation:
      //   עם+name (nation of), name+ים (plural), ארץ+name (land of),
      //   שפת+name (language of), כתב+name (script of)
      // Sofiot in prefixes (עם,ארץ) are normalized by worker before search.
      return {
        ...n,
        names: [n.name],
        expressions: [
          '\u05E2\u05DD' + n.name,        // עם + name
          n.name + '\u05D9\u05DD',         // name + ים
          '\u05D0\u05E8\u05E5' + n.name,   // ארץ + name
          '\u05E9\u05E4\u05EA' + n.name,   // שפת + name
          '\u05DB\u05EA\u05D1' + n.name    // כתב + name
        ]
      };
    });

    // Active rabbi/nation list (switchable via UI)
    let wrrActiveRabbis = WRR_RABBIS;
    let wrrActiveListName = 'list2';
    let wrrActiveTextName = 'genesis';
    let wrrActiveExperimentType = 'rabbis'; // 'rabbis' or 'nations'

    let wrrAbort = false;
    let wrrTextNorm = null;      // Active text with sofiot normalized (Genesis or W&P)
    let wrrLetterFreqs = null;   // letter frequency map for active text
    let wrrResults = [];         // stored results for export/view
    let wrrELSCache = new Map(); // termNorm:maxSkip → hits (avoid re-searching shared terms)
    // Cache both texts so switching is instant
    let wrrGenesisNorm = null;
    let wrrWarAndPeaceNorm = null;

    // ---- Load active text and compute letter frequencies ----
    async function wrrLoadText() {
      if (wrrActiveTextName === 'genesis') {
        if (!wrrGenesisNorm) {
          let raw;
          if (torahText && torahText.length >= WRR_GENESIS_LEN) {
            raw = torahText.slice(0, WRR_GENESIS_LEN);
          } else {
            const resp = await fetch('data/torahNoSpaces.txt');
            raw = (await resp.text()).trim().slice(0, WRR_GENESIS_LEN);
          }
          wrrGenesisNorm = normalizeSofiot(raw);
        }
        wrrTextNorm = wrrGenesisNorm;
      } else {
        if (!wrrWarAndPeaceNorm) {
          const resp = await fetch('data/warAndPeace78064.txt');
          const raw = (await resp.text()).trim();
          wrrWarAndPeaceNorm = normalizeSofiot(raw);
        }
        wrrTextNorm = wrrWarAndPeaceNorm;
      }
      // Compute letter frequencies for D(w) calculation
      wrrLetterFreqs = {};
      for (const ch of wrrTextNorm) {
        wrrLetterFreqs[ch] = (wrrLetterFreqs[ch] || 0) + 1;
      }
    }
    // Alias for backward compatibility
    const wrrLoadGenesis = wrrLoadText;

    // ---- Dynamic skip range D(w) ----
    // D(w) = smallest D such that cumulative expected ELS count >= 10
    // Expected per skip d: E(w,d) = (L-(k-1)d) * P(w)  for d = 2..D
    function wrrMaxSkip(termNorm, cap) {
      const k = termNorm.length;
      const L = WRR_GENESIS_LEN;
      // Compute log-probability of match at any position
      let logP = 0;
      for (const ch of termNorm) {
        const f = wrrLetterFreqs[ch];
        if (!f) return 2; // letter not in Genesis text
        logP += Math.log(f / L);
      }
      const pMatch = Math.exp(logP);
      let cumExpected = 0;
      for (let d = 2; d <= cap; d++) {
        const validStarts = L - (k - 1) * d;
        if (validStarts <= 0) return Math.max(d - 1, 2);
        cumExpected += validStarts * pMatch;
        if (cumExpected >= 10) return d;
      }
      return cap; // rare word: search full range
    }

    // ---- Optimized ELS search with first-character filter ----
    // Finds all ELS of termNorm in text with skip in [2, maxSkip] (forward only)
    function wrrFindELSForward(text, termNorm, maxSkip) {
      const k = termNorm.length;
      const L = text.length;
      const results = [];
      const ch0 = termNorm[0];
      const ch0Pos = [];
      for (let i = 0; i < L; i++) {
        if (text[i] === ch0) ch0Pos.push(i);
      }
      for (let d = 2; d <= maxSkip; d++) {
        const maxStart = L - (k - 1) * d;
        if (maxStart <= 0) break;
        for (const s of ch0Pos) {
          if (s >= maxStart) break;
          let match = true;
          for (let i = 1; i < k; i++) {
            if (text[s + i * d] !== termNorm[i]) { match = false; break; }
          }
          if (match) results.push({ pos: s, skip: d, len: k });
        }
      }
      return results;
    }

    // ---- Search both forward and backward ELS (|skip| >= 2) ----
    // Backward ELS = reversed term with positive skip. Cached by term+maxSkip.
    function wrrFindELS(text, termNorm, maxSkip) {
      const cacheKey = termNorm + ':' + maxSkip;
      const cached = wrrELSCache.get(cacheKey);
      if (cached) return cached;

      const forward = wrrFindELSForward(text, termNorm, maxSkip);
      const rev = [...termNorm].reverse().join('');
      let results;
      if (rev === termNorm) {
        results = forward;
      } else {
        results = forward.concat(wrrFindELSForward(text, rev, maxSkip));
      }
      wrrELSCache.set(cacheKey, results);
      return results;
    }

    // ---- SL search (main thread): consecutive letters, skip=1 ----
    // Used as fallback when worker is unavailable for nations mode.
    function findSLMainThread(text, termNorm) {
      const results = [];
      let idx = text.indexOf(termNorm);
      while (idx !== -1) {
        results.push({ pos: idx, skip: 1, len: termNorm.length });
        idx = text.indexOf(termNorm, idx + 1);
      }
      const rev = [...termNorm].reverse().join('');
      if (rev !== termNorm) {
        idx = text.indexOf(rev);
        while (idx !== -1) {
          results.push({ pos: idx, skip: 1, len: termNorm.length });
          idx = text.indexOf(rev, idx + 1);
        }
      }
      return results;
    }

    // ---- 2D Euclidean distance on cylindrical array ----
    // Position p on array of width w maps to row=floor(p/w), col=p%w
    function wrr2DDist(p1, p2, w) {
      const r1 = Math.floor(p1 / w), c1 = p1 % w;
      const r2 = Math.floor(p2 / w), c2 = p2 % w;
      return Math.sqrt((r1 - r2) * (r1 - r2) + (c1 - c2) * (c1 - c2));
    }

    // Min 2D distance between two ELS words, testing both array widths
    function wrrPairDist(h1, h2) {
      let minDist = Infinity;
      // Get letter positions for each ELS occurrence
      const pos1 = [];
      for (let i = 0; i < h1.len; i++) pos1.push(h1.pos + i * h1.skip);
      const pos2 = [];
      for (let i = 0; i < h2.len; i++) pos2.push(h2.pos + i * h2.skip);
      // Test both array widths: |skip1| and |skip2|
      const widths = new Set();
      if (h1.skip >= 2) widths.add(h1.skip);
      if (h2.skip >= 2) widths.add(h2.skip);
      for (const w of widths) {
        for (const a of pos1) {
          for (const b of pos2) {
            const d = wrr2DDist(a, b, w);
            if (d < minDist) minDist = d;
          }
        }
      }
      return minDist;
    }

    // Find best proximity across all name×date ELS hit combinations
    function wrrBestProximity(nameHits, dateHits) {
      let best = { dist: Infinity, nameHit: null, dateHit: null };
      for (const nh of nameHits) {
        for (const dh of dateHits) {
          const d = wrrPairDist(nh, dh);
          if (d < best.dist) best = { dist: d, nameHit: nh, dateHit: dh };
        }
      }
      return best.dist < Infinity ? best : null;
    }

    // ---- Populate rabbi/nation table ----
    function populateWRRTable() {
      const tbody = document.getElementById('wrrTableBody');
      if (!tbody) return;
      const isNations = wrrActiveExperimentType === 'nations';

      // Update column headers
      const colSubject = document.getElementById('wrrColSubject');
      const colNames = document.getElementById('wrrColNames');
      const colSecondary = document.getElementById('wrrColSecondary');
      if (colSubject) colSubject.textContent = isNations ? 'Nation' : 'Rabbi';
      if (colNames) colNames.textContent = isNations ? 'Name (Heb)' : 'Appellations';
      if (colSecondary) colSecondary.textContent = isNations ? 'Expressions' : 'Date';

      let html = '';
      wrrActiveRabbis.forEach(r => {
        const secondary = isNations ? (r.expressions || []) : (r.dates || []);
        const hasData = secondary.length > 0;
        const pairCount = hasData ? r.names.length * secondary.length : 0;
        const rowStyle = hasData ? '' : 'opacity:0.5;';
        let secondaryCell;
        if (isNations) {
          secondaryCell = `${secondary.length} expr`;
        } else {
          secondaryCell = hasData ? secondary[0] : '\u2014';
        }
        html += `<tr id="wrrRow${r.id}" style="border-bottom:1px solid #eee;${rowStyle}">
          <td style="padding:6px 4px;text-align:center;color:var(--gray);">${r.id}</td>
          <td style="padding:6px 4px;font-size:12px;">${r.en}</td>
          <td style="padding:6px 4px;direction:rtl;font-family:'SBL Hebrew',serif;font-size:14px;">${sanitizeSacredNames(r.names[0])}${r.names.length > 1 ? ` <span style="color:#999;font-size:11px;">(+${r.names.length - 1})</span>` : ''}</td>
          <td style="padding:6px 4px;direction:rtl;font-family:'SBL Hebrew',serif;font-size:${isNations ? '12' : '14'}px;">${sanitizeSacredNames(secondaryCell)}</td>
          <td style="padding:6px 4px;text-align:center;">${pairCount || '\u2014'}</td>
          <td style="padding:6px 4px;text-align:center;font-size:11px;color:var(--gray);" id="wrrDw${r.id}">\u2014</td>
          <td style="padding:6px 4px;text-align:center;" id="wrrResult${r.id}"><span style="color:#ccc;">\u2014</span></td>
        </tr>`;
      });
      tbody.innerHTML = html;
    }

    // ---- Switch dataset (rabbi list / nations) ----
    window.wrrSwitchList = function(listName) {
      wrrActiveListName = listName;
      if (listName === 'nations') {
        wrrActiveRabbis = WRR2_NATIONS;
        wrrActiveExperimentType = 'nations';
        document.getElementById('wrrStatRabbis').textContent = '68';
        document.getElementById('wrrStatRabbisLabel').textContent = 'Nations (B3)';
        document.getElementById('wrrTableLabel').textContent = 'Table of Nations (Genesis 10)';
        document.getElementById('wrrStatPValue').innerHTML = 'p = 4\u00d710<sup>-9</sup>';
        document.getElementById('wrrStatPLabel').textContent = 'Published P-value (B3)';
        document.getElementById('wrrDescription').innerHTML =
          'WRR2 Nations experiment (Sample B3). 68 nation names from the Table of Nations (Genesis 10), ' +
          'each paired with 5 category expressions (\u05E2\u05DD/\u05D0\u05E8\u05E5/\u05E9\u05E4\u05EA/\u05DB\u05EA\u05D1 + name, name + \u05D9\u05DD). ' +
          'Nation names searched as <strong>ELS</strong>, expressions as <strong>SL</strong> (consecutive letters). ' +
          'Published result: <strong>p = 4.0 \u00d7 10<sup>\u22129</sup></strong>.';
      } else if (listName === 'list1') {
        wrrActiveRabbis = WRR_RABBIS_LIST1;
        wrrActiveExperimentType = 'rabbis';
        document.getElementById('wrrStatRabbis').textContent = '34';
        document.getElementById('wrrStatRabbisLabel').textContent = 'Rabbis (List 1)';
        document.getElementById('wrrTableLabel').textContent = 'Rabbi List (WRR List 1)';
        document.getElementById('wrrStatPValue').innerHTML = 'p &lt; 1/62,500';
        document.getElementById('wrrStatPLabel').textContent = 'Published P-value (List 1)';
        document.getElementById('wrrDescription').innerHTML =
          'Replication of the famous experiment by Witztum, Rips &amp; Rosenberg published in ' +
          '<em>Statistical Science</em> (1994). 34 rabbis from the <em>Encyclopedia of Great Men in Israel</em>, ' +
          'each paired with Hebrew death dates. The proximity of name-date ELS pairs in Genesis was found to be ' +
          'statistically significant at <strong>p = 0.000016</strong> (1 in 62,500).';
      } else {
        wrrActiveRabbis = WRR_RABBIS;
        wrrActiveExperimentType = 'rabbis';
        document.getElementById('wrrStatRabbis').textContent = '32';
        document.getElementById('wrrStatRabbisLabel').textContent = 'Rabbis (List 2)';
        document.getElementById('wrrTableLabel').textContent = 'Rabbi List (WRR List 2)';
        document.getElementById('wrrStatPValue').innerHTML = 'p &lt; 1/62,500';
        document.getElementById('wrrStatPLabel').textContent = 'Published P-value (List 2)';
        document.getElementById('wrrDescription').innerHTML =
          'Replication of the famous experiment by Witztum, Rips &amp; Rosenberg published in ' +
          '<em>Statistical Science</em> (1994). 32 rabbis from the <em>Encyclopedia of Great Men in Israel</em>, ' +
          'each paired with Hebrew death dates. The proximity of name-date ELS pairs in Genesis was found to be ' +
          'statistically significant at <strong>p = 0.000016</strong> (1 in 62,500).';
      }
      wrrResults = [];
      wrrELSCache.clear();
      populateWRRTable();
      document.getElementById('wrrSummary').style.display = 'none';
    };

    // ---- Switch text (Genesis / War and Peace) ----
    window.wrrSwitchText = function(textName) {
      wrrActiveTextName = textName;
      wrrTextNorm = null;  // Force reload
      wrrLetterFreqs = null;
      wrrELSCache.clear();
      wrrResults = [];
      const label = document.getElementById('wrrStatTextLabel');
      const note = document.getElementById('wrrTextNote');
      if (textName === 'tolstoy') {
        label.textContent = 'Letters in War & Peace';
        note.textContent = 'Control text: WRR published non-significant results for Tolstoy.';
      } else {
        label.textContent = 'Letters in Genesis';
        note.textContent = '';
      }
      populateWRRTable();
      document.getElementById('wrrSummary').style.display = 'none';
    };

    // ---- UI helpers for WRR results ----
    let wrrActiveWorker = null;
    let wrrT0 = 0;

    function wrrUpdateRabbiRow(rabbiId, maxDw, result) {
      const resultCell = document.getElementById(`wrrResult${rabbiId}`);
      const dwCell = document.getElementById(`wrrDw${rabbiId}`);
      if (dwCell) dwCell.textContent = maxDw;
      if (!result) {
        resultCell.innerHTML = '<span style="color:#ccc;" title="No ELS found in skip range">\u2014</span>';
        return;
      }
      const d = result.dist;
      const color = d < 5 ? '#1b5e20' : d < 20 ? '#2e7d32' : d < 50 ? '#558b2f' :
                    d < 100 ? '#f57f17' : d < 500 ? '#e65100' : '#c62828';
      const secLabel = wrrActiveExperimentType === 'nations' ? 'Expr' : 'Date';
      const tip = `Name: ${sanitizeSacredNames(result.name)} (skip ${result.nameSkip})\n${secLabel}: ${sanitizeSacredNames(result.date)} (skip ${result.dateSkip})\n\u0394 = ${d.toFixed(2)} (2D Euclidean)`;
      resultCell.innerHTML = `<span style="color:${color};font-weight:bold;cursor:pointer;" title="${tip}" onclick="viewWRRPair(${rabbiId})">${d.toFixed(1)}</span>`;
    }

    function wrrShowSummary(skipCap) {
      const isNations = wrrActiveExperimentType === 'nations';
      const items = isNations
        ? wrrActiveRabbis.filter(r => r.expressions && r.expressions.length > 0)
        : wrrActiveRabbis.filter(r => r.dates && r.dates.length > 0);
      const itemLabel = isNations ? 'nations' : 'rabbis';
      const summary = document.getElementById('wrrSummary');
      const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);
      document.getElementById('wrrRunBtn').disabled = false;
      document.getElementById('wrrCancelBtn').style.display = 'none';
      document.getElementById('wrrProgressBar').style.display = 'none';
      const noMatch = items.length - wrrResults.length;
      if (wrrResults.length === 0) {
        summary.style.display = '';
        summary.innerHTML = `<div style="color:#c62828;font-weight:bold;">No pairs found for any ${isNations ? 'nation' : 'rabbi'} (${elapsed}s). Try increasing skip cap.</div>`;
        return;
      }
      wrrResults.sort((a, b) => a.dist - b.dist);
      const median = wrrResults[Math.floor(wrrResults.length / 2)].dist;
      const avg = wrrResults.reduce((s, r) => s + r.dist, 0) / wrrResults.length;
      const geoMean = Math.exp(wrrResults.reduce((s, r) => s + Math.log(r.dist), 0) / wrrResults.length);
      const minDist = wrrResults[0].dist;
      const maxDist = wrrResults[wrrResults.length - 1].dist;
      const close20 = wrrResults.filter(r => r.dist < 20).length;
      const close100 = wrrResults.filter(r => r.dist < 100).length;
      const mode = wrrActiveWorker ? 'Web Worker' : 'main thread';
      summary.style.display = '';
      summary.innerHTML = `
        <div style="font-weight:bold;color:#2e7d32;font-size:16px;margin-bottom:8px;">Experiment Complete (${elapsed}s, ${mode})</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:8px;font-size:13px;">
          <div><strong>${wrrResults.length}</strong> / ${items.length} ${itemLabel} matched${noMatch > 0 ? `, <span style="color:#c62828">${noMatch} unmatched</span>` : ''}</div>
          <div>Geometric mean \u0394: <strong>${geoMean.toFixed(2)}</strong></div>
          <div>Arithmetic mean \u0394: <strong>${avg.toFixed(1)}</strong></div>
          <div>Median \u0394: <strong>${median.toFixed(1)}</strong></div>
          <div>Range: <strong>${minDist.toFixed(1)}</strong> \u2013 <strong>${maxDist.toFixed(1)}</strong></div>
          <div>\u0394 < 20: <strong>${close20}</strong> | \u0394 < 100: <strong>${close100}</strong></div>
          <div>Skip cap: <strong>${skipCap}</strong></div>
        </div>
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
          <button class="btn btn-secondary" onclick="wrrExportCSV()" style="font-size:12px;padding:6px 12px;">Export CSV</button>
          <button class="btn" onclick="wrrRunPermTest()" id="wrrPermBtn" style="font-size:12px;padding:6px 12px;background:linear-gradient(135deg,#7b1fa2,#9c27b0);color:#fff;border:none;border-radius:6px;cursor:pointer;">
            \u{1F3B2} Permutation Test
          </button>
          <label style="font-size:11px;color:#555;">
            N=<input type="number" id="wrrPermN" value="1000" min="100" max="100000" step="100" style="width:70px;font-size:11px;padding:2px 4px;">
          </label>
        </div>
        <div id="wrrPermResults" style="display:none;margin-top:10px;padding:10px;background:#f3e5f5;border-radius:6px;border:1px solid #ce93d8;"></div>
        <div style="margin-top:8px;font-size:12px;color:#555;">
          \u0394 = min 2D Euclidean distance on cylindrical array (width = |skip|), testing both array widths per pair.
          Geometric mean is the WRR aggregate proximity measure. Click any \u0394 value to view the pair in the ELS matrix.
        </div>`;
      wrrActiveWorker = null;
    }

    // ---- Main experiment: Web Worker with main-thread fallback ----
    window.runWRRExperiment = async function() {
      wrrAbort = false;
      wrrResults = [];
      wrrELSCache.clear();

      const runBtn = document.getElementById('wrrRunBtn');
      const cancelBtn = document.getElementById('wrrCancelBtn');
      const progressBar = document.getElementById('wrrProgressBar');
      const progressFill = document.getElementById('wrrProgressFill');
      const progressText = document.getElementById('wrrProgressText');
      const summary = document.getElementById('wrrSummary');

      runBtn.disabled = true;
      cancelBtn.style.display = '';
      progressBar.style.display = '';
      summary.style.display = 'none';

      progressText.textContent = `Loading ${wrrActiveTextName === 'genesis' ? 'Genesis' : 'War and Peace'} (78,064 letters)...`;
      await wrrLoadGenesis();

      const skipCap = parseInt(document.getElementById('wrrSkipCap')?.value) || 1000;
      wrrT0 = performance.now();
      populateWRRTable();

      // Try Web Worker first (Option A: pass text via postMessage)
      try {
        const worker = new Worker('engines/wrr.worker.js');
        wrrActiveWorker = worker;
        progressText.textContent = 'Running via Web Worker (UI stays responsive)...';

        worker.onmessage = function(e) {
          const msg = e.data;
          if (msg.type === 'rabbi-done') {
            // Update progress
            const pct = Math.round((msg.completed / msg.total) * 100);
            progressFill.style.width = pct + '%';
            const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);
            const itemWord = wrrActiveExperimentType === 'nations' ? 'nations' : 'rabbis';
            progressText.textContent = `${msg.completed}/${msg.total} ${itemWord} (${elapsed}s)`;
            // Update table row
            wrrUpdateRabbiRow(msg.rabbiId, msg.maxDw, msg.result);
            // Store result
            if (msg.result) {
              wrrResults.push({
                rabbiId: msg.rabbiId, en: msg.en, dist: msg.result.dist,
                name: msg.result.name, date: msg.result.date,
                nameSkip: msg.result.nameSkip, dateSkip: msg.result.dateSkip,
                namePos: msg.result.namePos, datePos: msg.result.datePos, maxDw: msg.maxDw
              });
            }
          } else if (msg.type === 'complete') {
            wrrShowSummary(skipCap);
          } else if (msg.type === 'error') {
            console.warn('WRR Worker error, falling back to main thread:', msg.message);
            worker.terminate();
            wrrActiveWorker = null;
            wrrResults = [];
            populateWRRTable();
            wrrRunMainThread(skipCap);
          }
        };

        worker.onerror = function(err) {
          console.warn('WRR Worker failed, falling back to main thread:', err.message);
          worker.terminate();
          wrrActiveWorker = null;
          wrrResults = [];
          populateWRRTable();
          wrrRunMainThread(skipCap);
        };

        // Send data to Worker — for nations, map expressions→dates and flag SL mode
        const isNations = wrrActiveExperimentType === 'nations';
        const rabbisData = isNations
          ? wrrActiveRabbis.map(n => ({ id: n.id, en: n.en, names: n.names, dates: n.expressions }))
          : wrrActiveRabbis;
        worker.postMessage({
          action: 'run',
          genesisNorm: wrrTextNorm,
          rabbis: rabbisData,
          skipCap: skipCap,
          letterFreqs: wrrLetterFreqs,
          expressionMode: isNations ? 'sl' : undefined
        });

      } catch (e) {
        // Worker not supported or failed to create
        console.warn('Web Worker unavailable, running on main thread:', e.message);
        wrrActiveWorker = null;
        wrrRunMainThread(skipCap);
      }
    };

    // ---- Fallback: run on main thread (same algorithms, with UI yields) ----
    async function wrrRunMainThread(skipCap) {
      const progressFill = document.getElementById('wrrProgressFill');
      const progressText = document.getElementById('wrrProgressText');
      const isNations = wrrActiveExperimentType === 'nations';
      // Normalize data: for nations, map expressions to dates field
      const items = isNations
        ? wrrActiveRabbis.map(n => ({ id: n.id, en: n.en, names: n.names, dates: n.expressions }))
        : wrrActiveRabbis;
      const itemsWithDates = items.filter(r => r.dates && r.dates.length > 0);
      const itemLabel = isNations ? 'nations' : 'rabbis';

      progressText.textContent = 'Running on main thread...';

      for (const rabbi of itemsWithDates) {
        if (wrrAbort) break;
        const resultCell = document.getElementById(`wrrResult${rabbi.id}`);
        resultCell.innerHTML = '<span style="color:var(--orange);">&#9203;</span>';

        let bestResult = null;
        let bestDist = Infinity;
        let maxDw = 0;

        for (const nameRaw of rabbi.names) {
          if (wrrAbort) break;
          const nameNorm = normalizeSofiot(nameRaw.replace(/\s+/g, ''));
          if (nameNorm.length < 2) continue;
          const dName = wrrMaxSkip(nameNorm, skipCap);
          if (dName > maxDw) maxDw = dName;
          const nameHits = wrrFindELS(wrrTextNorm, nameNorm, dName);
          if (nameHits.length === 0) continue;
          await new Promise(r => setTimeout(r, 0));
          for (const dateRaw of rabbi.dates) {
            if (wrrAbort) break;
            const dateNorm = normalizeSofiot(dateRaw.replace(/\s+/g, ''));
            if (dateNorm.length < 2) continue;
            let dateHits;
            if (isNations) {
              dateHits = findSLMainThread(wrrTextNorm, dateNorm);
            } else {
              const dDate = wrrMaxSkip(dateNorm, skipCap);
              if (dDate > maxDw) maxDw = dDate;
              dateHits = wrrFindELS(wrrTextNorm, dateNorm, dDate);
            }
            if (dateHits.length === 0) continue;
            const pair = wrrBestProximity(nameHits, dateHits);
            if (pair && pair.dist < bestDist) {
              bestDist = pair.dist;
              bestResult = { nameHit: pair.nameHit, dateHit: pair.dateHit, nameStr: nameRaw, dateStr: dateRaw };
            }
          }
        }

        const result = bestResult ? {
          dist: bestDist, name: bestResult.nameStr, date: bestResult.dateStr,
          nameSkip: bestResult.nameHit.skip, dateSkip: bestResult.dateHit.skip,
          namePos: bestResult.nameHit.pos, datePos: bestResult.dateHit.pos
        } : null;
        wrrUpdateRabbiRow(rabbi.id, maxDw, result);
        if (result) {
          wrrResults.push({ rabbiId: rabbi.id, en: rabbi.en, ...result, maxDw });
        }
        const totalItems = itemsWithDates.length;
        const done = wrrResults.length;
        progressFill.style.width = Math.round((done / totalItems) * 100) + '%';
        const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);
        progressText.textContent = `${done}/${totalItems} ${itemLabel} (${elapsed}s, main thread)`;
        await new Promise(r => setTimeout(r, 0));
      }

      wrrShowSummary(skipCap);
    }

    window.cancelWRR = function() {
      wrrAbort = true;
      if (wrrActiveWorker) {
        wrrActiveWorker.terminate();
        wrrActiveWorker = null;
      }
      if (wrrFullWorker) {
        wrrFullWorker.terminate();
        wrrFullWorker = null;
      }
      if (wrrPermWorker) {
        wrrPermWorker.terminate();
        wrrPermWorker = null;
      }
      document.getElementById('wrrCancelBtn').style.display = 'none';
      document.getElementById('wrrRunBtn').disabled = false;
      const fullBtn = document.getElementById('wrrFullBtn');
      if (fullBtn) fullBtn.disabled = false;
      document.getElementById('wrrProgressBar').style.display = 'none';
      document.getElementById('wrrProgress').textContent = 'Cancelled';
    };

    // View a specific rabbi's best name-date pair in the scan matrix
    window.viewWRRPair = function(rabbiId) {
      const res = wrrResults.find(r => r.rabbiId === rabbiId);
      const rabbi = wrrActiveRabbis.find(r => r.id === rabbiId);
      if (!rabbi) return;
      const nameToSearch = res ? res.name.replace(/\s+/g, '') : rabbi.names[0].replace(/\s+/g, '');
      const secondary = rabbi.dates || rabbi.expressions || [];
      const dateToSearch = res ? res.date.replace(/\s+/g, '') : (secondary[0] || '').replace(/\s+/g, '');
      if (!dateToSearch) return;
      document.getElementById('batchTextarea').value = nameToSearch + '\n' + dateToSearch;
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('[data-mode="scan"]').classList.add('active');
      document.getElementById('scan-mode').classList.add('active');
      // Auto-trigger the scan after UI updates
      setTimeout(() => { if (typeof startScan === 'function') startScan(); }, 150);
    };

    // Export results as CSV
    window.wrrExportCSV = function() {
      if (!wrrResults.length) return;
      const isNations = wrrActiveExperimentType === 'nations';
      const subj = isNations ? 'Nation' : 'Rabbi';
      const sec = isNations ? 'Expression' : 'Date';
      const hdr = `# NOTICE: Sacred Names of God are redacted (*) to prevent desecration if printed.\n# Electronic viewing preferred. If printed, treat with appropriate reverence.\n${subj} ID,Name (English),Best Name Form,Best ${sec} Form,Name Skip,${sec} Skip,Name Pos,${sec} Pos,Delta (2D Euclidean),Max D(w)\n`;
      const rows = wrrResults.map(r =>
        `${r.rabbiId},"${r.en}","${sanitizeForExport(r.name)}","${sanitizeForExport(r.date)}",${r.nameSkip},${r.dateSkip},${r.namePos},${r.datePos},${r.dist.toFixed(4)},${r.maxDw}`
      ).join('\n');
      const blob = new Blob(['\ufeff' + hdr + rows], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = isNations ? 'wrr2-nations-quick.csv' : 'wrr-1994-replication.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    // ---- Permutation test: shuffle rabbi↔date assignments, compute P-value ----
    let wrrPermWorker = null;

    window.wrrRunPermTest = function() {
      if (!wrrResults.length) {
        alert('Run the experiment first to get baseline results.');
        return;
      }
      const numPerm = parseInt(document.getElementById('wrrPermN')?.value) || 1000;
      const permBtn = document.getElementById('wrrPermBtn');
      const permDiv = document.getElementById('wrrPermResults');
      const skipCap = parseInt(document.getElementById('wrrSkipCap')?.value) || 1000;

      // Compute actual geometric mean from current results
      const actualGeoMean = Math.exp(
        wrrResults.reduce((s, r) => s + Math.log(r.dist), 0) / wrrResults.length
      );

      permBtn.disabled = true;
      permBtn.textContent = 'Running...';
      permDiv.style.display = '';
      permDiv.innerHTML = `<div style="font-size:13px;color:#6a1b9a;">
        <strong>Permutation Test</strong> — Pre-computing ELS hits for all terms...
        <div style="margin-top:6px;background:#e1bee7;border-radius:4px;overflow:hidden;height:8px;">
          <div id="wrrPermFill" style="width:0%;height:100%;background:linear-gradient(90deg,#7b1fa2,#ce93d8);transition:width 0.3s;"></div>
        </div>
        <div id="wrrPermStatus" style="margin-top:4px;font-size:12px;">0 / ${numPerm} permutations</div>
      </div>`;

      try {
        const worker = new Worker('engines/wrr.worker.js');
        wrrPermWorker = worker;

        worker.onmessage = function(e) {
          const msg = e.data;
          if (msg.type === 'perm-progress') {
            const fill = document.getElementById('wrrPermFill');
            const status = document.getElementById('wrrPermStatus');
            if (msg.phase === 'precomputing') {
              if (status) status.textContent = 'Pre-computing ELS hits for all terms...';
            } else {
              const pct = Math.round((msg.completed / msg.total) * 100);
              if (fill) fill.style.width = pct + '%';
              if (status) status.textContent = `${msg.completed} / ${msg.total} permutations — P \u2248 ${msg.currentPValue.toFixed(4)} (${msg.betterCount} better)`;
            }
          } else if (msg.type === 'perm-complete') {
            wrrShowPermResults(msg);
            permBtn.disabled = false;
            permBtn.textContent = '\u{1F3B2} Permutation Test';
            wrrPermWorker = null;
          } else if (msg.type === 'error') {
            permDiv.innerHTML = `<div style="color:#c62828;font-weight:bold;">Error: ${msg.message}</div>`;
            permBtn.disabled = false;
            permBtn.textContent = '\u{1F3B2} Permutation Test';
            wrrPermWorker = null;
          }
        };

        worker.onerror = function(err) {
          permDiv.innerHTML = `<div style="color:#c62828;">Worker error: ${err.message}</div>`;
          permBtn.disabled = false;
          permBtn.textContent = '\u{1F3B2} Permutation Test';
          wrrPermWorker = null;
        };

        // Ensure Genesis is loaded, then start
        wrrLoadGenesis().then(() => {
          const isNationsP = wrrActiveExperimentType === 'nations';
          const rabbisDataP = isNationsP
            ? wrrActiveRabbis.map(n => ({ id: n.id, en: n.en, names: n.names, dates: n.expressions }))
            : wrrActiveRabbis;
          worker.postMessage({
            action: 'permutation-test',
            genesisNorm: wrrTextNorm,
            rabbis: rabbisDataP,
            skipCap,
            letterFreqs: wrrLetterFreqs,
            numPermutations: numPerm,
            actualGeoMean,
            expressionMode: isNationsP ? 'sl' : undefined
          });
        });

      } catch (e) {
        permDiv.innerHTML = `<div style="color:#c62828;">Could not start permutation test: ${e.message}</div>`;
        permBtn.disabled = false;
        permBtn.textContent = '\u{1F3B2} Permutation Test';
      }
    };

    function wrrShowPermResults(msg) {
      const permDiv = document.getElementById('wrrPermResults');
      const pVal = msg.pValue;
      const pColor = pVal < 0.01 ? '#1b5e20' : pVal < 0.05 ? '#2e7d32' : pVal < 0.1 ? '#f57f17' : '#c62828';
      const sigLabel = pVal < 0.001 ? 'Highly significant' :
                       pVal < 0.01  ? 'Very significant' :
                       pVal < 0.05  ? 'Significant' :
                       pVal < 0.1   ? 'Marginally significant' : 'Not significant';
      const ratio = pVal > 0 ? Math.round(1 / pVal) : msg.numPermutations;

      // Build mini histogram from distribution
      let histHTML = '';
      if (msg.distribution && msg.distribution.length > 10) {
        const dist = msg.distribution;
        const minV = dist[0], maxV = dist[dist.length - 1];
        const bins = 30;
        const binW = (maxV - minV) / bins || 1;
        const counts = new Array(bins).fill(0);
        for (const v of dist) {
          const bi = Math.min(bins - 1, Math.floor((v - minV) / binW));
          counts[bi]++;
        }
        const maxCount = Math.max(...counts);
        const actualBin = Math.min(bins - 1, Math.floor((msg.actualGeoMean - minV) / binW));

        histHTML = '<div style="margin-top:8px;"><div style="font-size:11px;color:#555;margin-bottom:4px;">Distribution of permuted geometric means:</div>';
        histHTML += '<div style="display:flex;align-items:flex-end;height:60px;gap:1px;">';
        for (let b = 0; b < bins; b++) {
          const h = maxCount > 0 ? Math.round((counts[b] / maxCount) * 56) : 0;
          const isActual = b === actualBin;
          const bg = isActual ? '#c62828' : '#ce93d8';
          const title = `${(minV + b * binW).toFixed(1)}\u2013${(minV + (b + 1) * binW).toFixed(1)}: ${counts[b]}`;
          histHTML += `<div style="width:${Math.max(4, Math.floor(200 / bins))}px;height:${Math.max(1, h)}px;background:${bg};border-radius:1px 1px 0 0;" title="${title}"></div>`;
        }
        histHTML += '</div>';
        histHTML += `<div style="font-size:10px;color:#999;display:flex;justify-content:space-between;"><span>${minV.toFixed(1)}</span><span>Red = actual (${msg.actualGeoMean.toFixed(2)})</span><span>${maxV.toFixed(1)}</span></div>`;
        histHTML += '</div>';
      }

      permDiv.innerHTML = `
        <div style="font-weight:bold;color:#6a1b9a;font-size:14px;margin-bottom:6px;">Permutation Test Results</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:6px;font-size:13px;">
          <div>P-value: <strong style="color:${pColor};font-size:15px;">${pVal.toFixed(6)}</strong></div>
          <div>Significance: <strong style="color:${pColor};">${sigLabel}</strong></div>
          <div>Rank: <strong>${msg.betterCount}</strong> / ${msg.numPermutations} (1/${ratio})</div>
          <div>Actual geo. mean: <strong>${msg.actualGeoMean.toFixed(2)}</strong></div>
          <div>Permuted median: <strong>${msg.median.toFixed(2)}</strong></div>
          <div>Permuted mean: <strong>${msg.mean.toFixed(2)}</strong></div>
        </div>
        ${histHTML}
        <div style="margin-top:6px;font-size:11px;color:#777;">
          ${msg.numPermutations} random permutations of rabbi\u2194date assignments.
          P = fraction of permutations with geometric mean \u0394 \u2264 actual.
        </div>`;
    }

    // ---- Full WRR experiment with c(w,w') perturbation statistic ----
    let wrrFullWorker = null;

    window.wrrRunFullExperiment = async function() {
      const runBtn = document.getElementById('wrrRunBtn');
      const fullBtn = document.getElementById('wrrFullBtn');
      const cancelBtn = document.getElementById('wrrCancelBtn');
      const progressBar = document.getElementById('wrrProgressBar');
      const progressFill = document.getElementById('wrrProgressFill');
      const progressText = document.getElementById('wrrProgressText');
      const summary = document.getElementById('wrrSummary');

      runBtn.disabled = true;
      fullBtn.disabled = true;
      cancelBtn.style.display = '';
      progressBar.style.display = '';
      summary.style.display = 'none';

      progressText.textContent = `Loading ${wrrActiveTextName === 'genesis' ? 'Genesis' : 'War and Peace'} (78,064 letters)...`;
      await wrrLoadGenesis();

      const skipCap = parseInt(document.getElementById('wrrSkipCap')?.value) || 1000;
      wrrT0 = performance.now();
      populateWRRTable();

      try {
        const worker = new Worker('engines/wrr.worker.js');
        wrrFullWorker = worker;

        worker.onmessage = function(e) {
          const msg = e.data;

          if (msg.type === 'wrr-phase') {
            progressText.textContent = msg.message;

          } else if (msg.type === 'wrr-rabbi-done') {
            const pct = Math.round((msg.completed / msg.total) * 100);
            progressFill.style.width = pct + '%';
            const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);
            const itemLabel = wrrActiveExperimentType === 'nations' ? 'nations' : 'rabbis';
            progressText.textContent = `c(w,w') \u2014 ${msg.completed}/${msg.total} ${itemLabel} (${elapsed}s)`;
            // Update table row with c value
            wrrUpdateRabbiRowFull(msg.result);

          } else if (msg.type === 'wrr-complete') {
            wrrShowFullSummary(msg, skipCap);

          } else if (msg.type === 'wrr-perm-precompute-progress') {
            const pct = Math.round((msg.completed / msg.total) * 100);
            progressFill.style.width = pct + '%';
            progressText.textContent = msg.message;

          } else if (msg.type === 'wrr-perm-progress') {
            const pct = Math.round((msg.completed / msg.total) * 100);
            progressFill.style.width = pct + '%';
            progressText.textContent = `Permutation ${msg.completed}/${msg.total} — P \u2248 ${msg.currentPValue.toFixed(6)}`;

          } else if (msg.type === 'wrr-perm-complete') {
            wrrShowFullPermResults(msg);
            progressBar.style.display = 'none';

          } else if (msg.type === 'error') {
            progressText.textContent = 'Error: ' + msg.message;
            console.error('WRR Full error:', msg.message);
          }
        };

        worker.onerror = function(err) {
          progressText.textContent = 'Worker error: ' + err.message;
          console.error('WRR Full worker error:', err);
          runBtn.disabled = false;
          fullBtn.disabled = false;
          cancelBtn.style.display = 'none';
        };

        const numPerm = parseInt(document.getElementById('wrrPermN2')?.value) || 0;
        const isNations = wrrActiveExperimentType === 'nations';

        if (isNations) {
          worker.postMessage({
            action: 'run-wrr2-nations',
            genesisNorm: wrrTextNorm,
            nations: wrrActiveRabbis,
            skipCap,
            letterFreqs: wrrLetterFreqs,
            runPermTest: numPerm > 0,
            numPermutations: numPerm
          });
        } else {
          worker.postMessage({
            action: 'run-wrr-full',
            genesisNorm: wrrTextNorm,
            rabbis: wrrActiveRabbis,
            skipCap,
            letterFreqs: wrrLetterFreqs,
            runPermTest: numPerm > 0,
            numPermutations: numPerm
          });
        }

      } catch (e) {
        progressText.textContent = 'Could not start worker: ' + e.message;
        runBtn.disabled = false;
        fullBtn.disabled = false;
        cancelBtn.style.display = 'none';
      }
    };

    // Update table row with c(w,w') result
    function wrrUpdateRabbiRowFull(result) {
      if (!result) return;
      const row = document.getElementById(`wrrRow${result.rabbiId}`);
      if (!row) return;
      const cells = row.querySelectorAll('td');
      // The delta column is the last one (index 6)
      const deltaCell = cells[6];
      if (deltaCell) {
        const c = result.c;
        if (c === null) {
          deltaCell.innerHTML = '<span style="color:#ccc;" title="m < 10: insufficient valid perturbations">N/A</span>';
        } else {
          const color = c < 0.05 ? '#1b5e20' : c < 0.2 ? '#2e7d32' : c < 0.5 ? '#f57f17' : '#888';
          const secLabel = wrrActiveExperimentType === 'nations' ? 'Expr' : 'Date';
          deltaCell.innerHTML = result.name
            ? `<span style="color:${color};font-weight:bold;cursor:pointer;" title="c(w,w') = ${c.toFixed(4)} | Name: ${sanitizeSacredNames(result.name)} (${result.nameHitCount} ELS) | ${secLabel}: ${sanitizeSacredNames(result.date)} (${result.dateHitCount} ${wrrActiveExperimentType === 'nations' ? 'SL' : 'ELS'})">${c.toFixed(3)}</span>`
            : '<span style="color:#ccc;">\u2014</span>';
        }
      }
    }

    // Show full WRR summary with P₁, P₂
    function wrrShowFullSummary(msg, skipCap) {
      const summary = document.getElementById('wrrSummary');
      const runBtn = document.getElementById('wrrRunBtn');
      const fullBtn = document.getElementById('wrrFullBtn');
      const cancelBtn = document.getElementById('wrrCancelBtn');
      const progressBar = document.getElementById('wrrProgressBar');
      const isNations = wrrActiveExperimentType === 'nations';

      const elapsed = ((performance.now() - wrrT0) / 1000).toFixed(1);

      // Color-code overall P
      const p = msg.overallP;
      const pColor = p < 0.001 ? '#1b5e20' : p < 0.01 ? '#2e7d32' : p < 0.05 ? '#f57f17' : '#c62828';
      const sigLabel = p < 0.001 ? 'Highly significant' :
                       p < 0.01  ? 'Very significant' :
                       p < 0.05  ? 'Significant' :
                       p < 0.1   ? 'Marginally significant' : 'Not significant';

      const kLow = msg.cValues.filter(c => c < 0.2).length;
      const k10 = msg.cValues.filter(c => c < 0.1).length;
      const textLabel = wrrActiveTextName === 'genesis' ? 'Genesis' : 'War & Peace';
      const listLabel = isNations ? 'Nations B3'
        : wrrActiveListName === 'list1' ? 'List 1' : 'List 2';
      const itemLabel = isNations ? 'nations' : 'rabbis';

      // Published reference values
      const isGenL2 = wrrActiveTextName === 'genesis' && wrrActiveListName === 'list2' && !isNations;
      const isGenNations = wrrActiveTextName === 'genesis' && isNations;
      let pubRef = '';
      if (isGenL2) {
        pubRef = '<div style="margin-top:10px;padding:8px 12px;background:#fff3e0;border-radius:6px;border:1px solid #ffe0b2;font-size:12px;">' +
          '<strong style="color:#e65100;">WRR Published (Table 3, List 2, Genesis):</strong> ' +
          'P\u2081 rank = 453, P\u2082 rank = 5, P\u2083 rank = 570, P\u2084 rank = 4 out of 1,000,000. ' +
          '\u03C1 = 4\u00b74/(10\u2076\u22121) \u2248 16/10\u2076' +
          '</div>';
      } else if (isGenNations) {
        pubRef = '<div style="margin-top:10px;padding:8px 12px;background:#fff3e0;border-radius:6px;border:1px solid #ffe0b2;font-size:12px;">' +
          '<strong style="color:#e65100;">WRR2 Published (Sample B3, Nations, Genesis):</strong> ' +
          'P = 4.0 \u00d7 10<sup>\u22129</sup> (999,999,999 permutations). ' +
          'Names searched as ELS, category expressions as SL (consecutive letters).' +
          '</div>';
      }

      const methodNote = isNations
        ? 'Names searched as ELS (|skip| \u2265 2), expressions as SL (consecutive letters, skip=1). ' +
          'Perturbations applied to ELS positions only.'
        : 'c(w,w\') = rank of actual \u03b5 proximity among 125 spatial perturbations. ' +
          'Small c \u2192 unusually close name-date ELS proximity. 10 row lengths h<sub>i</sub>=round(|d|/i) tested per pair.';

      summary.style.display = '';
      summary.style.background = 'linear-gradient(135deg,#e8f5e9,#c8e6c9)';
      summary.style.border = '1px solid #a5d6a7';

      // P₃/P₄ only shown for rabbis experiment (non-"Rabbi" subset)
      const hasP34 = !isNations && msg.p3 !== undefined;
      const p34html = hasP34 ? `
          <div>P\u2083 (Bin 0.2, no \u05E8\u05D1\u05D9): <strong>${msg.p3.toExponential(4)}</strong></div>
          <div>P\u2084 (Gamma, no \u05E8\u05D1\u05D9): <strong>${msg.p4.toExponential(4)}</strong></div>
          <div>${msg.matchedCount_noRabbi || 0} matched without \u05E8\u05D1\u05D9 prefix</div>` : '';
      const pFormula = hasP34 ? '4\u00b7min(P\u2081\u2013P\u2084)' : '2\u00b7min(P\u2081,P\u2082)';
      const pairsNote = msg.totalPairsConsidered
        ? `<div>Word pairs (5\u20138 chars): <strong>${msg.totalPairsConsidered}</strong></div>` : '';

      summary.innerHTML = `
        <div style="font-weight:bold;color:#1b5e20;font-size:16px;margin-bottom:8px;">Full WRR \u2014 c(w,w') Statistic (${textLabel}, ${listLabel}, ${elapsed}s)</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:8px;font-size:13px;">
          <div><strong>${msg.matchedCount}</strong> / ${msg.totalRabbis} ${itemLabel} matched (c &lt; 1.0)</div>
          <div>c &lt; 0.2: <strong>${kLow}</strong> / ${msg.cValues.length} &nbsp; c &lt; 0.1: <strong>${k10}</strong></div>
          <div>P\u2081 (Bin 0.2): <strong>${msg.p1.toExponential(4)}</strong></div>
          <div>P\u2082 (Gamma): <strong>${msg.p2.toExponential(4)}</strong></div>
          ${p34html}
          <div style="font-size:15px;">P = ${pFormula}: <strong style="color:${pColor};font-size:17px;">${p.toExponential(4)}</strong></div>
          <div>Significance: <strong style="color:${pColor};">${sigLabel}</strong></div>
          <div>Skip cap: <strong>${skipCap}</strong></div>
          ${pairsNote}
        </div>
        ${pubRef}
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
          <button class="btn btn-secondary" onclick="wrrExportCSVFull()" style="font-size:12px;padding:6px 12px;">Export CSV</button>
          <label style="font-size:11px;color:#555;">
            Permutation test N=<input type="number" id="wrrPermN2" value="1000" min="100" max="100000" step="100" style="width:70px;font-size:11px;padding:2px 4px;">
            <button class="btn" onclick="wrrRunFullWithPerm()" style="font-size:11px;padding:4px 10px;background:linear-gradient(135deg,#1b5e20,#388e3c);color:#fff;border:none;border-radius:4px;cursor:pointer;">
              Run Permutation Test
            </button>
          </label>
        </div>
        <div id="wrrFullPermResults" style="display:none;margin-top:10px;padding:10px;background:#e8f5e9;border-radius:6px;border:1px solid #a5d6a7;"></div>
        <div style="margin-top:8px;font-size:12px;color:#555;">
          ${methodNote}
        </div>`;

      runBtn.disabled = false;
      fullBtn.disabled = false;
      cancelBtn.style.display = 'none';
      if (!msg.runPermTest) progressBar.style.display = 'none';

      // Store results for re-use
      window._wrrFullResults = msg;
    }

    // Run permutation test from Full WRR summary button
    window.wrrRunFullWithPerm = function() {
      const numPerm = parseInt(document.getElementById('wrrPermN2')?.value) || 1000;
      if (numPerm < 10) { alert('Need at least 10 permutations.'); return; }

      const fullBtn = document.getElementById('wrrFullBtn');
      const progressBar = document.getElementById('wrrProgressBar');
      const progressFill = document.getElementById('wrrProgressFill');
      const progressText = document.getElementById('wrrProgressText');

      fullBtn.disabled = true;
      progressBar.style.display = '';
      progressFill.style.width = '0%';

      const skipCap = parseInt(document.getElementById('wrrSkipCap')?.value) || 1000;
      wrrT0 = performance.now();

      wrrLoadGenesis().then(() => {
        try {
          const worker = new Worker('engines/wrr.worker.js');
          wrrFullWorker = worker;

          worker.onmessage = function(e) {
            const msg = e.data;
            if (msg.type === 'wrr-phase') {
              progressText.textContent = msg.message;
            } else if (msg.type === 'wrr-rabbi-done') {
              const pct = Math.round((msg.completed / msg.total) * 100);
              progressFill.style.width = (pct * 0.3) + '%';  // 0-30% for c computation
              const il = wrrActiveExperimentType === 'nations' ? 'nations' : 'rabbis';
              progressText.textContent = `c(w,w') \u2014 ${msg.completed}/${msg.total} ${il}`;
            } else if (msg.type === 'wrr-complete') {
              // c computation done, permutation test starting
              window._wrrFullResults = msg;
            } else if (msg.type === 'wrr-perm-precompute-progress') {
              const pct = Math.round((msg.completed / msg.total) * 100);
              progressFill.style.width = (30 + pct * 0.3) + '%'; // 30-60%
              progressText.textContent = msg.message;
            } else if (msg.type === 'wrr-perm-progress') {
              const pct = Math.round((msg.completed / msg.total) * 100);
              progressFill.style.width = (60 + pct * 0.4) + '%'; // 60-100%
              progressText.textContent = `Permutation ${msg.completed}/${msg.total} \u2014 P \u2248 ${msg.currentPValue.toFixed(6)}`;
            } else if (msg.type === 'wrr-perm-complete') {
              wrrShowFullPermResults(msg);
              progressBar.style.display = 'none';
              fullBtn.disabled = false;
            } else if (msg.type === 'error') {
              progressText.textContent = 'Error: ' + msg.message;
              fullBtn.disabled = false;
            }
          };

          worker.onerror = function(err) {
            progressText.textContent = 'Worker error: ' + err.message;
            fullBtn.disabled = false;
          };

          const isNations2 = wrrActiveExperimentType === 'nations';
          if (isNations2) {
            worker.postMessage({
              action: 'run-wrr2-nations',
              genesisNorm: wrrTextNorm,
              nations: wrrActiveRabbis,
              skipCap,
              letterFreqs: wrrLetterFreqs,
              runPermTest: true,
              numPermutations: numPerm
            });
          } else {
            worker.postMessage({
              action: 'run-wrr-full',
              genesisNorm: wrrTextNorm,
              rabbis: wrrActiveRabbis,
              skipCap,
              letterFreqs: wrrLetterFreqs,
              runPermTest: true,
              numPermutations: numPerm
            });
          }
        } catch (e) {
          progressText.textContent = 'Worker error: ' + e.message;
          fullBtn.disabled = false;
        }
      });
    };

    // Show permutation test results for Full WRR
    function wrrShowFullPermResults(msg) {
      const permDiv = document.getElementById('wrrFullPermResults');
      if (!permDiv) return;
      const pVal = msg.pValue;
      const pColor = pVal < 0.001 ? '#1b5e20' : pVal < 0.01 ? '#2e7d32' : pVal < 0.05 ? '#f57f17' : '#c62828';
      const sigLabel = pVal < 0.001 ? 'Highly significant' :
                       pVal < 0.01  ? 'Very significant' :
                       pVal < 0.05  ? 'Significant' :
                       pVal < 0.1   ? 'Marginally significant' : 'Not significant';
      const ratio = pVal > 0 ? Math.round(1 / pVal) : msg.numPermutations;

      permDiv.style.display = '';
      permDiv.innerHTML = `
        <div style="font-weight:bold;color:#1b5e20;font-size:14px;margin-bottom:6px;">Permutation Test (c statistic)</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:6px;font-size:13px;">
          <div>P-value: <strong style="color:${pColor};font-size:15px;">${pVal.toFixed(6)}</strong></div>
          <div>Significance: <strong style="color:${pColor};">${sigLabel}</strong></div>
          <div>Rank: <strong>${msg.betterCount}</strong> / ${msg.numPermutations} (1/${ratio})</div>
          <div>Actual P(c): <strong>${msg.actualOverallP.toExponential(4)}</strong></div>
        </div>
        <div style="margin-top:6px;font-size:11px;color:#777;">
          ${msg.numPermutations} random permutations of ${wrrActiveExperimentType === 'nations' ? 'nation\u2194expression' : 'rabbi\u2194date'} assignments.
          Each permutation: compute c(w,w') for all pairings, then P\u2081\u2013P\u2084.
          P-value = fraction with overall P \u2264 actual.
        </div>`;
    }

    // CSV export for Full WRR results
    window.wrrExportCSVFull = function() {
      const results = window._wrrFullResults;
      if (!results) { alert('No full WRR results to export.'); return; }
      const isNations = wrrActiveExperimentType === 'nations';
      const subjectLabel = isNations ? 'Nation' : 'Rabbi';
      const secLabel = isNations ? 'Expression' : 'Date';
      const secHitLabel = isNations ? 'SL Hits' : 'Date Hits';
      const rows = [[subjectLabel, 'Name', secLabel, 'c(w,w\')', 'Name ELS Hits', secHitLabel]];
      for (const r of results.rabbiResults) {
        rows.push([r.en || r.rabbiId, sanitizeForExport(r.name || ''), sanitizeForExport(r.date || ''), r.c !== null ? r.c.toFixed(6) : 'N/A', r.nameHitCount, r.dateHitCount]);
      }
      rows.push([]);
      rows.push(['P1 (binomial 0.2)', results.p1.toExponential(6)]);
      rows.push(['P2 (Gamma)', results.p2.toExponential(6)]);
      rows.push(['Overall P = 2*min(P1,P2)', results.overallP.toExponential(6)]);
      rows.push(['Text', wrrActiveTextName]);
      rows.push(['Dataset', wrrActiveListName]);
      rows.push(['Mode', isNations ? 'WRR2 Nations (ELS x SL)' : 'WRR1 Rabbis (ELS x ELS)']);
      const csv = rows.map(r => r.join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = isNations ? 'wrr2-nations-c-statistic.csv' : 'wrr-full-c-statistic.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    // Initialize WRR table
    populateWRRTable();

    // ============= HEBREW DATE ELS MAP =============

    let dmData = null;         // loaded date index
    let dmSelected = null;     // { type:'date'|'month'|'year', key:string }

    // 14 months: 12 standard + Adar I (leap-year) + Adar II (leap-year)
    // Variant spellings (alts) searched separately in data but aggregated in display
    const DM_MONTHS = [
      { heb:'תשרי',  eng:'Tishrei',  days:30 },
      { heb:'חשון',  eng:'Cheshvan', days:29, alts:['חשוון'] },
      { heb:'כסלו',  eng:'Kislev',   days:30 },
      { heb:'טבת',   eng:'Tevet',    days:29 },
      { heb:'שבט',   eng:'Shevat',   days:30 },
      { heb:'אדר',   eng:'Adar',     days:29 },       // Non-leap year
      { heb:'אדרא',  eng:'Adar I',   days:30, alts:['אדרראשון'] },  // Leap year first Adar
      { heb:'אדרב',  eng:'Adar II',  days:29, alts:['אדרשני'] },    // Leap year second Adar
      { heb:'ניסן',  eng:'Nisan',    days:30 },
      { heb:'אייר',  eng:'Iyar',     days:29 },
      { heb:'סיון',  eng:'Sivan',    days:30 },
      { heb:'תמוז',  eng:'Tammuz',   days:29 },
      { heb:'אב',    eng:'Av',       days:30 },
      { heb:'אלול',  eng:'Elul',     days:29 },
    ];

    // Returns the standard Hebrew numeral form of a day number
    function dmDayHeb(n) {
      const u = {1:'א',2:'ב',3:'ג',4:'ד',5:'ה',6:'ו',7:'ז',8:'ח',9:'ט'};
      if (n <= 9) return u[n];
      if (n === 10) return 'י';
      if (n === 15) return 'טו';
      if (n === 16) return 'טז';
      if (n === 20) return 'כ';
      if (n === 30) return 'ל';
      if (n < 20) return 'י' + u[n-10];
      if (n < 30) return 'כ' + u[n-20];
      return 'ל';
    }

    // Returns ALL Hebrew numeral forms for a day (days 15/16 have dual forms)
    // Standard: 15=טו, 16=טז (avoids divine name)
    // Mathematical: 15=יה, 16=יו (pure gematria — valid for ELS since letters follow values)
    function dmDayHebForms(n) {
      if (n === 15) return ['טו', 'יה'];
      if (n === 16) return ['טז', 'יו'];
      return [dmDayHeb(n)];
    }

    function dmYearHeb(n) {
      let r = '';
      while (n >= 400) { r += 'ת'; n -= 400; }
      if (n >= 300) { r += 'ש'; n -= 300; }
      else if (n >= 200) { r += 'ר'; n -= 200; }
      else if (n >= 100) { r += 'ק'; n -= 100; }
      if (n === 15) return r + 'טו';
      if (n === 16) return r + 'טז';
      const tm = {10:'י',20:'כ',30:'ל',40:'מ',50:'נ',60:'ס',70:'ע',80:'פ',90:'צ'};
      const t = Math.floor(n/10)*10;
      if (t > 0) { r += tm[t]; n -= t; }
      const um = {1:'א',2:'ב',3:'ג',4:'ד',5:'ה',6:'ו',7:'ז',8:'ח',9:'ט'};
      if (n > 0) r += um[n];
      return r;
    }

    // Color scale: count → CSS color
    function dmColor(count, maxCount) {
      if (count === 0) return '#1a1a2e';
      const t = Math.log(count + 1) / Math.log(maxCount + 1);
      // Gradient: dark blue → purple → red → orange
      if (t < 0.33) {
        const s = t / 0.33;
        return `rgb(${Math.round(15+68*s)},${Math.round(26+26*s)},${Math.round(46+50*s)})`;
      } else if (t < 0.66) {
        const s = (t - 0.33) / 0.33;
        return `rgb(${Math.round(83+150*s)},${Math.round(52-7*s)},${Math.round(96+35*s)})`;
      } else {
        const s = (t - 0.66) / 0.34;
        return `rgb(${Math.round(233+22*s)},${Math.round(69+38*s)},${Math.round(96+11*s)})`;
      }
    }

    async function loadDateMapData() {
      if (dmData) return true;
      try {
        const resp = await fetch('data/els-dates-index.json.gz');
        if (!resp.ok) return false;
        const blob = await resp.blob();
        const ds = new DecompressionStream('gzip');
        const text = await new Response(blob.stream().pipeThrough(ds)).text();
        dmData = JSON.parse(text);
        return true;
      } catch (e) {
        console.log('Date map index not available:', e.message);
        return false;
      }
    }

    async function initDateMap() {
      const loaded = await loadDateMapData();
      if (!loaded) {
        document.getElementById('dmNoData').style.display = 'block';
        document.getElementById('dmHeatmapSection').style.display = 'none';
        document.getElementById('dmMonthSection').style.display = 'none';
        document.getElementById('dmYearSection').style.display = 'none';
        document.getElementById('dmStats').style.display = 'none';
        return;
      }
      document.getElementById('dmNoData').style.display = 'none';
      document.getElementById('dmHeatmapSection').style.display = 'block';
      document.getElementById('dmMonthSection').style.display = 'block';
      document.getElementById('dmYearSection').style.display = 'block';
      document.getElementById('dmStats').style.display = 'grid';

      // Stats
      const meta = dmData.meta;
      document.getElementById('dmStatTerms').textContent = meta.termCount;
      document.getElementById('dmStatHits').textContent = (meta.totalHits || 0).toLocaleString();
      document.getElementById('dmStatSkip').textContent = `±${meta.skipRange[1]}`;

      renderDateHeatmap();
      renderMonthBar();
      renderYearGrid();
    }

    // Aggregate hit count across all term keys for a given day+month
    // (accounts for dual day forms 15/16 and variant month spellings)
    function dmAggregateCount(dates, day, month) {
      const dayForms = dmDayHebForms(day);
      const monthForms = [month.heb, ...(month.alts || [])];
      let total = 0;
      const keys = [];
      for (const df of dayForms) {
        for (const mf of monthForms) {
          const key = normalizeSofiot(df + mf);
          const entry = dates[key];
          if (entry && entry.n) { total += entry.n; keys.push(key); }
        }
      }
      return { total, keys };
    }

    function renderDateHeatmap() {
      const tbl = document.getElementById('dmHeatmapTable');
      const dates = dmData.dates;

      // Find max aggregated count for color scaling
      let maxCount = 1;
      for (const m of DM_MONTHS) {
        for (let d = 1; d <= m.days; d++) {
          const { total } = dmAggregateCount(dates, d, m);
          if (total > maxCount) maxCount = total;
        }
      }

      // Header row: day numbers
      let html = '<thead><tr><th></th>';
      for (let d = 1; d <= 30; d++) html += `<th>${dmDayHeb(d)}</th>`;
      html += '</tr></thead><tbody>';

      // One row per month (14 months including Adar I/II)
      for (const m of DM_MONTHS) {
        html += `<tr><td class="dm-month-label">${m.heb}</td>`;
        for (let d = 1; d <= 30; d++) {
          if (d > m.days) {
            html += '<td></td>';
            continue;
          }
          const { total, keys } = dmAggregateCount(dates, d, m);
          const bg = dmColor(total, maxCount);
          const primaryKey = normalizeSofiot(dmDayHeb(d) + m.heb);
          const formsNote = (d === 15 || d === 16)
            ? ` [${dmDayHebForms(d).join('+')} forms]` : '';
          const tip = `${dmDayHeb(d)} ${m.heb} (${d} ${m.eng}): ${total} ELS hits${formsNote}`;
          html += `<td class="dm-cell" style="background:${bg};" title="${tip}" `
               + `data-term="${primaryKey}" data-type="date" `
               + `data-all-keys="${keys.join(',')}" `
               + `onclick="dmSelectCell(this)">${total > 0 ? '' : ''}</td>`;
        }
        html += '</tr>';
      }
      html += '</tbody>';
      tbl.innerHTML = html;
    }

    function renderMonthBar() {
      const bar = document.getElementById('dmMonthBar');
      const months = dmData.months;

      // Aggregate counts including variant spellings
      let maxCount = 1;
      for (const m of DM_MONTHS) {
        let total = 0;
        for (const mf of [m.heb, ...(m.alts || [])]) {
          const entry = months[normalizeSofiot(mf)];
          if (entry) total += entry.n;
        }
        if (total > maxCount) maxCount = total;
      }

      let html = '';
      for (const m of DM_MONTHS) {
        const termKey = normalizeSofiot(m.heb);
        let total = 0;
        for (const mf of [m.heb, ...(m.alts || [])]) {
          const entry = months[normalizeSofiot(mf)];
          if (entry) total += entry.n;
        }
        const bg = dmColor(total, maxCount);
        const altsNote = m.alts ? ` [+${m.alts.join(',')}]` : '';
        html += `<div class="dm-month-pill" style="background:${bg};color:#fff;" `
             + `title="${m.heb} (${m.eng}): ${total} ELS hits${altsNote}" `
             + `data-term="${termKey}" data-type="month" `
             + `onclick="dmSelectCell(this)">`
             + `${m.heb} <small>${total}</small></div>`;
      }
      bar.innerHTML = html;
    }

    function renderYearGrid() {
      const grid = document.getElementById('dmYearGrid');
      const years = dmData.years;
      let maxCount = 1;
      for (const v of Object.values(years)) {
        if (v.n > maxCount) maxCount = v.n;
      }

      let html = '';
      for (let y = 700; y < 800; y++) {
        const termKey = normalizeSofiot(dmYearHeb(y));
        const entry = years[termKey];
        const count = entry ? entry.n : 0;
        const bg = dmColor(count, maxCount);
        const fullYear = y + 5000;
        const gregYear = fullYear - 3760;
        html += `<div class="dm-year-cell" style="background:${bg};color:#fff;" `
             + `title="${dmYearHeb(y)} (${fullYear} / ~${gregYear} CE): ${count} ELS hits" `
             + `data-term="${termKey}" data-type="year" `
             + `onclick="dmSelectCell(this)">`
             + `${dmYearHeb(y)}</div>`;
      }
      grid.innerHTML = html;
    }

    window.dmSelectCell = function(el) {
      // Clear previous selection
      document.querySelectorAll('.dm-cell.selected, .dm-month-pill.selected, .dm-year-cell.selected')
        .forEach(e => e.classList.remove('selected'));
      el.classList.add('selected');

      const termKey = el.dataset.term;
      const type = el.dataset.type;
      const allKeysStr = el.dataset.allKeys || '';
      dmSelected = { type, key: termKey };

      const category = type + 's';
      const detail = document.getElementById('dmDetail');

      // Aggregate entries from all variant keys (dual day forms, alt month spellings)
      const keys = allKeysStr ? allKeysStr.split(',') : [termKey];
      let totalN = 0;
      let minSkip = Infinity;
      let allTop = [];
      let label = '';

      for (const k of keys) {
        const entry = dmData[category][k];
        if (!entry) continue;
        totalN += entry.n;
        if (!label && entry.label) label = entry.label;
        if (entry.minSkip && entry.minSkip < minSkip) minSkip = entry.minSkip;
        if (entry.top) allTop.push(...entry.top.map(h => ({ ...h, form: k })));
      }

      if (totalN === 0) {
        detail.style.display = 'none';
        return;
      }
      detail.style.display = 'block';

      // Sort combined top hits by |skip|
      allTop.sort((a, b) => Math.abs(a.s) - Math.abs(b.s));

      const formsNote = keys.length > 1 ? ` [forms: ${keys.join(', ')}]` : '';
      document.getElementById('dmDetailTitle').textContent =
        `${termKey} — ${label}${formsNote}`;
      document.getElementById('dmDetailCount').textContent =
        `${totalN.toLocaleString()} ELS hits`;
      document.getElementById('dmDetailMinSkip').textContent =
        minSkip < Infinity ? `Min |skip| = ${minSkip}` : '';

      // Render top hits (up to 20 from combined forms)
      const hitsDiv = document.getElementById('dmDetailHits');
      const topHits = allTop.slice(0, 20);
      if (topHits.length > 0) {
        let rows = '';
        for (const h of topHits) {
          let verseRef = '';
          if (typeof charDatabase !== 'undefined' && charDatabase && h.p < charDatabase.length) {
            const ch = charDatabase[h.p];
            if (ch) {
              const bName = BOOK_NAMES[ch.book] || `Book ${ch.book}`;
              verseRef = ` — ${bName} ${ch.chapter}:${ch.verse}`;
            }
          }
          const formTag = keys.length > 1 ? ` [${h.form}]` : '';
          rows += `<div class="dm-hit-row">skip=${h.s > 0 ? '+' : ''}${h.s}  pos=${h.p.toLocaleString()}${verseRef}${formTag}</div>`;
        }
        hitsDiv.innerHTML = rows;
      } else {
        hitsDiv.innerHTML = '<div class="dm-hit-row">No detailed hits stored</div>';
      }
    };

    window.dmTransferToScan = function() {
      if (!dmSelected) return;
      // Switch to scan tab
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
      document.querySelector('[data-mode="scan"]').classList.add('active');
      document.getElementById('scan-mode').classList.add('active');

      // Put term in textarea
      const ta = document.getElementById('batchTextarea');
      if (ta) {
        ta.value = dmSelected.key;
        ta.focus();
      }
    };

    window.dmExportCSV = function() {
      if (!dmData) return;
      let csv = '# NOTICE: Sacred Names of God are redacted (*) to prevent desecration if printed.\n# Electronic viewing preferred. If printed, treat with appropriate reverence.\nTerm,Type,Label,Hits,MinSkip,TopPositions\n';
      for (const cat of ['dates', 'months', 'years']) {
        for (const [term, entry] of Object.entries(dmData[cat])) {
          const topStr = (entry.top || []).map(h => `${h.p}:${h.s}`).join(';');
          csv += `"${sanitizeForExport(term)}","${cat}","${sanitizeForExport(entry.label || '')}",${entry.n},${entry.minSkip || ''},${topStr}\n`;
        }
      }
      const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'hebrew-date-els-map.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    // Compute in browser fallback (uses main-thread findELS)
    window.dmComputeInBrowser = async function() {
      const prog = document.getElementById('dmComputeProgress');
      prog.style.display = 'block';
      prog.textContent = 'Loading Torah text...';

      // Ensure Torah text is loaded
      if (!torahText) {
        const resp = await fetch('data/torahNoSpaces.txt');
        torahText = await resp.text();
      }
      if (!torahTextNorm) torahTextNorm = normalizeSofiot(torahText);

      // Generate all date terms (14 months, dual day 15/16 forms, variant month spellings)
      const allTerms = [];
      for (const m of DM_MONTHS) {
        // Standalone month name + variants
        const mNorm = normalizeSofiot(m.heb);
        allTerms.push({ key: mNorm, type: 'month', label: m.eng });
        for (const alt of (m.alts || [])) {
          allTerms.push({ key: normalizeSofiot(alt), type: 'month', label: m.eng + ' (alt)' });
        }
        // Day+month combinations
        for (let d = 1; d <= m.days; d++) {
          const dayForms = dmDayHebForms(d);
          const monthForms = [m.heb, ...(m.alts || [])];
          for (let di = 0; di < dayForms.length; di++) {
            for (let mi = 0; mi < monthForms.length; mi++) {
              const combined = normalizeSofiot(dayForms[di] + monthForms[mi]);
              const altNote = (di > 0 || mi > 0) ? ' (alt)' : '';
              allTerms.push({ key: combined, type: 'date', label: `${d} ${m.eng}${altNote}`, day: d, month: m.eng });
            }
          }
        }
      }
      for (let y = 700; y < 800; y++) {
        const yh = dmYearHeb(y);
        const yNorm = normalizeSofiot(yh);
        allTerms.push({ key: yNorm, type: 'year', label: String(y + 5000), year: y + 5000 });
      }

      const maxSkip = 100; // Smaller range for browser compute
      const topN = 10;
      const results = { dates: {}, months: {}, years: {} };
      let totalHits = 0;

      for (let i = 0; i < allTerms.length; i++) {
        const t = allTerms[i];
        if (i % 10 === 0) {
          prog.textContent = `Searching ${i+1}/${allTerms.length}: ${t.label}...`;
          await new Promise(r => setTimeout(r, 0)); // yield to UI
        }

        const term = t.key;
        const k = term.length;
        const hits = [];

        // Pre-compute first char positions
        const ch0 = term[0];
        const ch0Pos = [];
        for (let j = 0; j < torahTextNorm.length; j++) {
          if (torahTextNorm[j] === ch0) ch0Pos.push(j);
        }

        for (let skip = -maxSkip; skip <= maxSkip; skip++) {
          if (skip === 0) continue;
          const found = findELS(torahTextNorm, term, skip, ch0Pos);
          for (const pos of found) hits.push({ p: pos, s: skip });
        }

        hits.sort((a, b) => Math.abs(a.s) - Math.abs(b.s));
        const entry = { n: hits.length, label: t.label };
        if (hits.length > 0) {
          entry.minSkip = Math.abs(hits[0].s);
          entry.top = hits.slice(0, topN);
        }
        if (t.day) entry.day = t.day;
        if (t.month) entry.month = t.month;

        const cat = t.type + 's';
        results[cat][t.key] = entry;
        totalHits += hits.length;
      }

      // Build dmData structure
      dmData = {
        meta: {
          version: '1.0-browser',
          skipRange: [1, maxSkip],
          textLen: torahTextNorm.length,
          generated: new Date().toISOString().slice(0, 10),
          topN,
          termCount: allTerms.length,
          totalHits
        },
        dates: results.dates,
        months: results.months,
        years: results.years
      };

      prog.textContent = `Done! ${totalHits.toLocaleString()} hits across ${allTerms.length} terms.`;
      initDateMap();
    };

    // Lazy-init: load data when Date Map tab is first activated
    let dmInitDone = false;
    document.querySelector('[data-mode="datemap"]').addEventListener('click', async () => {
      if (dmInitDone) return;
      dmInitDone = true;
      // Also ensure charDB is loaded for verse references in detail view
      if (typeof loadCharDB === 'function') loadCharDB().catch(() => {});
      await initDateMap();
    });

    // ============= 3D MATRIX VIEW =============
    let THREE = null, OrbitControls = null;
    let scene3D = null, camera3D = null, renderer3D = null, controls3D = null;
    let animFrame3D = null;
    let is3DActive = false;
    let current3DHits = null;
    let meshUserData = []; // for raycasting
    let textureCache = new Map();
    let raycaster3D = null, mouse3D = null;

    // Video capture state
    let vidRecorder = null;
    let vidStream = null;
    let vidChunks = [];
    let vidBlob = null;
    let vidStartTime = 0;
    let vidTimerInterval = null;
    let vidFrameCount = 0;
    let vidIsRecording = false;
    let vidFrameBlobs = [];  // for frame-by-frame mode
    let vidGifFrames = [];   // for GIF capture mode
    let vidGifInterval = null;
    let vidCurrentFormat = { label: 'MP4', ext: 'mp4' };
    let vidFormatsDetected = false;
    // Video formats: WebM (native browser recording) + GIF (universal)

    // Detect supported video formats and populate the format dropdown
    function vidDetectFormats() {
      if (vidFormatsDetected) return;
      vidFormatsDetected = true;
      const sel = document.getElementById('vidFormatSelect');
      if (!sel || typeof MediaRecorder === 'undefined') return;
      sel.innerHTML = '';

      const formats = [
        { value: 'webm', label: 'WebM (video)', mimes: ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'] },
        { value: 'gif', label: 'GIF (animated)', mimes: [] }  // GIF uses canvas frames, always supported
      ];

      for (const f of formats) {
        const supported = f.mimes.length === 0 || f.mimes.some(m => MediaRecorder.isTypeSupported(m));
        if (supported) {
          const opt = document.createElement('option');
          opt.value = f.value;
          opt.textContent = f.label;
          sel.appendChild(opt);
        }
      }

      // Default to GIF (universally playable)
      if (sel.querySelector('option[value="gif"]')) {
        sel.value = 'gif';
      }
    }

    // Lazy-load Three.js from CDN
    async function load3DDeps() {
      if (THREE) return;
      const threeModule = await import('./lib/three.module.js');
      THREE = threeModule;
      const controlsModule = await import('./lib/OrbitControls.js');
      OrbitControls = controlsModule.OrbitControls;
    }

    // Auto-compute optimal W,H from hit skip values
    function findOptimalDimensions(hits) {
      const skips = [...new Set(hits.map(h => Math.abs(h.skip)))].filter(s => s >= 2);
      if (skips.length === 0) return { W: 30, H: 15 };

      // Generate candidate W values
      const candidateWs = new Set();
      for (const s of skips) {
        if (s >= 10 && s <= 200) candidateWs.add(s);
        if (s - 1 >= 10) candidateWs.add(s - 1);
        if (s + 1 <= 200) candidateWs.add(s + 1);
        // factors of s
        for (let f = 2; f * f <= s; f++) {
          if (s % f === 0) {
            if (f >= 10 && f <= 200) candidateWs.add(f);
            if (s / f >= 10 && s / f <= 200) candidateWs.add(s / f);
          }
        }
      }
      if (candidateWs.size === 0) candidateWs.add(Math.max(Math.max(...skips), 30));

      let bestScore = -1, bestW = 30, bestH = 15;

      for (const W of candidateWs) {
        // Generate candidate H values
        const candidateHs = new Set([10, 15, 20]);
        for (const s of skips) {
          if (s % W === 0) {
            const h = s / W;
            if (h >= 3 && h <= 50) candidateHs.add(h);
          }
        }
        for (const H of candidateHs) {
          let score = 0;
          for (const s of skips) {
            if (s === W) score += 10;           // Y-axis aligned
            else if (s === W * H) score += 10;  // Z-axis aligned
            else if (W > 0 && s % W === 0) score += 7; // divisible by W
            else if (s === W + 1 || s === W - 1) score += 6; // XY diagonal
            else if (Math.abs(s - W) <= 3) score += 3;       // near axis
          }
          if (score > bestScore) { bestScore = score; bestW = W; bestH = H; }
        }
      }

      return { W: bestW, H: bestH };
    }

    // Create Hebrew letter texture on canvas
    function makeLetterTexture(letter, colorHex) {
      const key = letter + '|' + colorHex;
      if (textureCache.has(key)) return textureCache.get(key);

      const size = 64;
      const cv = document.createElement('canvas');
      cv.width = size; cv.height = size;
      const ctx = cv.getContext('2d');

      // Background with slight transparency
      ctx.fillStyle = colorHex;
      ctx.globalAlpha = 0.85;
      ctx.fillRect(0, 0, size, size);
      ctx.globalAlpha = 1;

      // Letter
      ctx.fillStyle = (colorHex === '#ffc107' || colorHex === '#00bcd4') ? '#000' : '#fff';
      ctx.font = 'bold 40px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(letter, size / 2, size / 2);

      const tex = new THREE.CanvasTexture(cv);
      tex.minFilter = THREE.LinearFilter;
      textureCache.set(key, tex);
      return tex;
    }

    // Init Three.js scene
    function init3DScene(container) {
      const w = container.clientWidth, h = container.clientHeight;

      scene3D = new THREE.Scene();
      scene3D.background = new THREE.Color('#1a1a2e');

      camera3D = new THREE.PerspectiveCamera(50, w / h, 0.1, 2000);
      camera3D.position.set(0, 0, 50);

      renderer3D = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer3D.setSize(w, h);
      renderer3D.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer3D.domElement);

      // Lights
      scene3D.add(new THREE.AmbientLight(0xffffff, 0.7));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.set(10, 20, 15);
      scene3D.add(dirLight);

      // Controls
      controls3D = new OrbitControls(camera3D, renderer3D.domElement);
      controls3D.enableDamping = true;
      controls3D.dampingFactor = 0.08;
      controls3D.autoRotate = true;
      controls3D.autoRotateSpeed = 1.0;

      // Raycaster
      raycaster3D = new THREE.Raycaster();
      mouse3D = new THREE.Vector2();

      // Mousemove for tooltips
      renderer3D.domElement.addEventListener('mousemove', onMouseMove3D);

      // Animation loop
      function animate() {
        animFrame3D = requestAnimationFrame(animate);
        controls3D.update();
        renderer3D.render(scene3D, camera3D);
      }
      animate();
    }

    // Render 3D matrix
    function render3DMatrix(hits, W, H) {
      if (!scene3D || !THREE) return;

      // Clear existing meshes (geometry shared — dispose once separately)
      const toRemove = [];
      const geoSet = new Set();
      scene3D.traverse(obj => { if (obj.isMesh) toRemove.push(obj); });
      toRemove.forEach(obj => { geoSet.add(obj.geometry); obj.material.dispose(); scene3D.remove(obj); });
      geoSet.forEach(g => g.dispose());
      meshUserData = [];

      // Build posMap: position -> { termIdxs, letter }
      const posMap = new Map();
      for (const h of hits) {
        for (let i = 0; i < h.term.length; i++) {
          const p = h.pos + i * h.skip;
          if (p < 0 || p >= torahText.length) continue;
          if (!posMap.has(p)) posMap.set(p, { termIdxs: new Set(), letter: torahText[p] });
          posMap.get(p).termIdxs.add(h.termIdx);
        }
      }

      const cellSize = 1.2;
      const layerGap = 1.5;
      const group = new THREE.Group();
      const planeGeo = new THREE.PlaneGeometry(cellSize * 0.9, cellSize * 0.9);

      // Collect positions for context neighbors
      const contextPositions = new Set();
      for (const pos of posMap.keys()) {
        for (const dp of [-1, 1, -W, W]) {
          const np = pos + dp;
          if (np >= 0 && np < torahText.length && !posMap.has(np)) contextPositions.add(np);
        }
      }

      // Render highlighted term chars
      for (const [pos, data] of posMap) {
        const col = pos % W;
        const row = Math.floor(pos / W) % H;
        const layer = Math.floor(pos / (W * H));

        const color = data.termIdxs.size > 1 ? '#9c27b0' :
          TERM_COLORS[[...data.termIdxs][0] % 8];
        const tex = makeLetterTexture(data.letter, color);
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(planeGeo, mat);

        // Position: X = col (RTL so negate), Y = -row, Z = layer * gap
        mesh.position.set(-col * cellSize, -row * cellSize, layer * cellSize * layerGap);
        group.add(mesh);

        // Store data for raycasting
        const termNames = [...data.termIdxs].map(t => sanitizeSacredNames(scanTerms[t] || `Term ${t}`)).join(', ');
        const verse = getVerseForPosition(pos);
        const vk3d = getVerseKey(pos);
        const sum3d = vk3d ? getVerseSummary(vk3d) : null;
        mesh.userData = { pos, letter: data.letter, termNames, verse, col, row, layer, summary: sum3d };
        meshUserData.push(mesh);
      }

      // Render dim context neighbors
      for (const pos of contextPositions) {
        const col = pos % W;
        const row = Math.floor(pos / W) % H;
        const layer = Math.floor(pos / (W * H));
        const letter = torahText[pos];

        const tex = makeLetterTexture(letter, '#2d2d44');
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(planeGeo, mat);
        mesh.position.set(-col * cellSize, -row * cellSize, layer * cellSize * layerGap);
        group.add(mesh);
      }

      // Layer guide planes (semi-transparent)
      const allLayers = new Set();
      for (const pos of posMap.keys()) allLayers.add(Math.floor(pos / (W * H)));
      for (const layer of allLayers) {
        const guideGeo = new THREE.PlaneGeometry(W * cellSize, H * cellSize);
        const guideMat = new THREE.MeshBasicMaterial({
          color: 0x3a3a5d, transparent: true, opacity: 0.05, side: THREE.DoubleSide
        });
        const guide = new THREE.Mesh(guideGeo, guideMat);
        guide.position.set(-W * cellSize / 2, -H * cellSize / 2, layer * cellSize * layerGap);
        group.add(guide);
      }

      scene3D.add(group);

      // Center group
      const box = new THREE.Box3().setFromObject(group);
      const center = box.getCenter(new THREE.Vector3());
      group.position.sub(center);

      fitCameraToGroup(box);

      // Update info bar
      const layers = allLayers.size;
      const infoEl = document.getElementById('matrix3DInfo');
      infoEl.style.display = 'flex';
      infoEl.innerHTML = `
        <span>W: <span class="info-val">${W}</span></span>
        <span>H: <span class="info-val">${H}</span></span>
        <span>Layers: <span class="info-val">${layers}</span></span>
        <span>Cells: <span class="info-val">${posMap.size + contextPositions.size}</span></span>
        <span style="margin-right:auto;"></span>
        <span>Drag to orbit · Scroll to zoom · Right-drag to pan</span>
      `;
    }

    function fitCameraToGroup(box) {
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera3D.fov * (Math.PI / 180);
      let dist = maxDim / (2 * Math.tan(fov / 2));
      dist *= 1.4; // padding
      camera3D.position.set(dist * 0.5, dist * 0.3, dist);
      camera3D.lookAt(0, 0, 0);
      controls3D.target.set(0, 0, 0);
      controls3D.update();
    }

    // Tooltip raycasting
    function onMouseMove3D(event) {
      if (!raycaster3D || !camera3D || meshUserData.length === 0) return;
      const rect = renderer3D.domElement.getBoundingClientRect();
      mouse3D.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse3D.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster3D.setFromCamera(mouse3D, camera3D);
      const intersects = raycaster3D.intersectObjects(meshUserData);

      const tooltip = document.getElementById('matrix3DTooltip');
      if (intersects.length > 0) {
        const d = intersects[0].object.userData;
        if (d && d.termNames) {
          const sumLine3d = d.summary ? `<br><em style="color:#90caf9;">${d.summary.s}${d.summary.feel ? ' — ' + d.summary.feel : ''}</em>` : '';
          tooltip.innerHTML = `<strong>${d.letter}</strong> — ${d.termNames}` +
            (d.verse ? `<br>${d.verse}` : '') + sumLine3d +
            `<br>pos: ${d.pos.toLocaleString()} | col: ${d.col} row: ${d.row} layer: ${d.layer}`;
          tooltip.style.display = 'block';
          tooltip.style.left = (event.clientX - rect.left + 12) + 'px';
          tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
        }
      } else {
        tooltip.style.display = 'none';
      }
    }

    // Toggle between 2D and 3D views
    window.toggle3DView = async function() {
      const btn = document.getElementById('btn3DToggle');
      const d2 = document.getElementById('scanMatrix2D');
      const d3 = document.getElementById('scanMatrix3D');
      const pauseBtn = document.getElementById('btn3DPause');
      const resetBtn = document.getElementById('btn3DReset');

      const vidPanel = document.getElementById('videoControlPanel');
      if (is3DActive) {
        // Stop any active recording
        if (vidRecorder && vidRecorder.state === 'recording') vidStopRecord();
        // Switch back to 2D
        is3DActive = false;
        btn.textContent = '3D View';
        btn.classList.remove('active');
        d2.style.display = '';
        d3.style.display = 'none';
        pauseBtn.style.display = 'none';
        resetBtn.style.display = 'none';
        if (vidPanel) vidPanel.style.display = 'none';
        destroy3DScene();
        return;
      }

      // Switch to 3D
      btn.textContent = 'Loading 3D...';
      btn.disabled = true;
      try {
        await load3DDeps();
      } catch (e) {
        alert('Failed to load Three.js: ' + e.message);
        btn.textContent = '3D View';
        btn.disabled = false;
        return;
      }

      is3DActive = true;
      btn.textContent = '2D View';
      btn.classList.add('active');
      btn.disabled = false;
      d2.style.display = 'none';
      d3.style.display = '';
      pauseBtn.style.display = '';
      resetBtn.style.display = '';
      if (vidPanel) { vidPanel.style.display = ''; vidDetectFormats(); }

      const container = document.getElementById('matrix3DCanvas');
      // Remove old canvas if any
      const oldCanvas = container.querySelector('canvas');
      if (oldCanvas) oldCanvas.remove();

      init3DScene(container);

      if (current3DHits && current3DHits.length > 0) {
        const { W, H } = findOptimalDimensions(current3DHits);
        render3DMatrix(current3DHits, W, H);
      }
    };

    window.toggle3DAutoRotate = function() {
      if (!controls3D) return;
      controls3D.autoRotate = !controls3D.autoRotate;
      document.getElementById('btn3DPause').textContent =
        controls3D.autoRotate ? 'Pause Rotation' : 'Resume Rotation';
    };

    window.reset3DCamera = function() {
      if (!scene3D || !camera3D) return;
      const box = new THREE.Box3().setFromObject(scene3D);
      fitCameraToGroup(box);
    };

    function destroy3DScene() {
      if (animFrame3D) { cancelAnimationFrame(animFrame3D); animFrame3D = null; }
      if (renderer3D) {
        renderer3D.domElement.removeEventListener('mousemove', onMouseMove3D);
        renderer3D.dispose();
        const container = document.getElementById('matrix3DCanvas');
        const canvas = container?.querySelector('canvas');
        if (canvas) canvas.remove();
        renderer3D = null;
      }
      if (controls3D) { controls3D.dispose(); controls3D = null; }
      // Dispose all textures in scene
      if (scene3D) {
        scene3D.traverse(obj => {
          if (obj.isMesh) {
            obj.geometry.dispose();
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        });
        scene3D = null;
      }
      camera3D = null;
      meshUserData = [];
      textureCache.forEach(t => t.dispose());
      textureCache.clear();
      document.getElementById('matrix3DInfo').style.display = 'none';
      document.getElementById('matrix3DTooltip').style.display = 'none';
      vidCleanup();
    }

    // Resize handler
    function onResize3D() {
      if (!renderer3D || !camera3D) return;
      const container = document.getElementById('matrix3DCanvas');
      const w = container.clientWidth, h = container.clientHeight;
      camera3D.aspect = w / h;
      camera3D.updateProjectionMatrix();
      renderer3D.setSize(w, h);
    }
    window.addEventListener('resize', onResize3D);

    // ResizeObserver for 3D canvas container (handles column layout changes)
    {
      const canvas3D = document.getElementById('matrix3DCanvas');
      if (canvas3D && typeof ResizeObserver !== 'undefined') {
        new ResizeObserver(() => onResize3D()).observe(canvas3D);
      }
    }

    // ============= 3D VIDEO CAPTURE =============

    function vidUpdateStatus(text) {
      document.getElementById('vidStatus').innerHTML = text;
    }

    function vidUpdateTime() {
      if (!vidIsRecording) return;
      const elapsed = (performance.now() - vidStartTime) / 1000;
      const mm = Math.floor(elapsed / 60);
      const ss = Math.floor(elapsed % 60).toString().padStart(2, '0');
      document.getElementById('vidTimeDisplay').textContent = `${mm}:${ss}`;
    }

    // Warn user if they change format during recording
    document.getElementById('vidFormatSelect')?.addEventListener('change', function() {
      if (vidIsRecording) {
        alert('Format change will apply to the NEXT recording.\nCurrent recording continues in the original format.\n\nTo record in the new format: Stop → then Record again.');
      }
      const noteEl = document.getElementById('vidFormatNote');
      if (noteEl) noteEl.textContent = 'Select before recording';
    });

    window.vidToggleRecord = function() {
      if (vidIsRecording) {
        vidStopRecord();
      } else {
        vidStartRecord();
      }
    };

    function vidStartRecord() {
      if (!renderer3D) { alert('3D view not active'); return; }

      const canvas = renderer3D.domElement;
      const fps = parseInt(document.getElementById('vidFPSSelect')?.value) || 30;
      const format = document.getElementById('vidFormatSelect')?.value || 'webm';

      // Verify canvas is valid and has dimensions
      if (!canvas || canvas.width === 0 || canvas.height === 0) {
        alert('Canvas not ready. Try rotating the 3D view first.');
        return;
      }

      // GIF mode: frame-by-frame canvas capture (no MediaRecorder needed)
      if (format === 'gif') {
        vidStartGifRecord(canvas, fps);
        return;
      }

      // Video mode (MP4/WebM): use MediaRecorder
      if (typeof canvas.captureStream !== 'function') {
        alert('captureStream() not supported. Use Chrome or Firefox.');
        return;
      }
      if (typeof MediaRecorder === 'undefined') {
        alert('MediaRecorder not supported. Use Chrome or Firefox.');
        return;
      }

      // Capture stream from the WebGL canvas
      try {
        vidStream = canvas.captureStream(fps);
      } catch (e) {
        alert('Failed to capture canvas stream: ' + e.message);
        return;
      }
      if (!vidStream || vidStream.getVideoTracks().length === 0) {
        alert('No video tracks in canvas stream. Try Chrome or Firefox.');
        return;
      }

      vidChunks = [];
      vidBlob = null;
      vidFrameCount = 0;

      // WebM is the only native MediaRecorder format
      let mimeType = '';
      const webmTypes = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'];
      for (const mt of webmTypes) {
        if (MediaRecorder.isTypeSupported(mt)) { mimeType = mt; break; }
      }
      const formatLabel = 'WebM';
      const fileExt = 'webm';

      if (!mimeType) {
        alert('No supported video codec. Try Chrome or Firefox.');
        return;
      }

      // Store format info for download
      vidCurrentFormat = { label: formatLabel, ext: fileExt };

      try {
        vidRecorder = new MediaRecorder(vidStream, {
          mimeType,
          videoBitsPerSecond: 5000000 // 5 Mbps for quality
        });
      } catch (e) {
        alert('Failed to create recorder: ' + e.message);
        return;
      }

      vidRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) {
          vidChunks.push(e.data);
          vidFrameCount++;
        }
      };

      vidRecorder.onstop = () => {
        vidBlob = new Blob(vidChunks, { type: mimeType });
        vidIsRecording = false;
        clearInterval(vidTimerInterval);

        const elapsed = (performance.now() - vidStartTime) / 1000;
        const mm = Math.floor(elapsed / 60);
        const ss = Math.floor(elapsed % 60).toString().padStart(2, '0');
        vidUpdateStatus(`${vidCurrentFormat.label} recorded: ${mm}:${ss} (${(vidBlob.size / 1024 / 1024).toFixed(1)} MB)`);

        const recBtn = document.getElementById('vidRecBtn');
        recBtn.textContent = 'Record';
        recBtn.classList.remove('recording');
        const dlBtn = document.getElementById('vidDownloadBtn');
        dlBtn.textContent = `Download ${vidCurrentFormat.label}`;
        dlBtn.style.display = '';
        // WebM is universally playable (Chrome, Firefox, VLC, etc.)
        document.getElementById('vidTimeline').disabled = false;
        document.getElementById('vidTimeline').max = 100;
        document.getElementById('vidTimeline').value = 100;

        // Create preview URL for timeline scrubbing
        const url = URL.createObjectURL(vidBlob);
        vidSetupPreview(url, elapsed);
      };

      // Request data every 100ms for smooth timeline updates
      vidRecorder.start(100);
      vidIsRecording = true;
      vidStartTime = performance.now();

      const recBtn = document.getElementById('vidRecBtn');
      recBtn.textContent = 'Stop';
      recBtn.classList.add('recording');
      document.getElementById('vidDownloadBtn').style.display = 'none';
      // (MP4 convert button removed — WebM plays everywhere)
      document.getElementById('vidTimeline').disabled = true;
      vidUpdateStatus(`<span class="rec-dot">&#9679;</span> Recording ${formatLabel}...`);

      vidTimerInterval = setInterval(vidUpdateTime, 250);
    }

    // ---- GIF Recording (universal playback) ----

    function vidStartGifRecord(canvas, fps) {
      vidGifFrames = [];
      vidBlob = null;
      vidIsRecording = true;
      vidStartTime = performance.now();
      vidFrameCount = 0;

      const delay = Math.round(1000 / fps);
      const srcW = canvas.width;
      const srcH = canvas.height;

      // Scale down for reasonable GIF file size (max 480px wide)
      const GIF_MAX_W = 480;
      const scale = srcW > GIF_MAX_W ? GIF_MAX_W / srcW : 1;
      const gifW = Math.round(srcW * scale);
      const gifH = Math.round(srcH * scale);

      // Reusable offscreen canvas for scaling
      const scaleCanvas = document.createElement('canvas');
      scaleCanvas.width = gifW;
      scaleCanvas.height = gifH;
      const scaleCtx = scaleCanvas.getContext('2d');

      // Source canvas to draw WebGL pixels onto (for drawImage scaling)
      const srcCanvas = document.createElement('canvas');
      srcCanvas.width = srcW;
      srcCanvas.height = srcH;
      const srcCtx = srcCanvas.getContext('2d');

      // Store dimensions for encoding
      vidGifFrames.gifW = gifW;
      vidGifFrames.gifH = gifH;

      // Capture frames at specified FPS from WebGL canvas
      vidGifInterval = setInterval(() => {
        if (!vidIsRecording) return;
        // Force render to ensure canvas has content
        if (controls3D) controls3D.update();
        if (renderer3D && scene3D && camera3D) renderer3D.render(scene3D, camera3D);

        // Read pixels from WebGL
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        if (!gl) return;
        const pixels = new Uint8Array(srcW * srcH * 4);
        gl.readPixels(0, 0, srcW, srcH, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        // WebGL pixels are bottom-up — put into ImageData flipped, then scale
        const imgData = new ImageData(srcW, srcH);
        for (let row = 0; row < srcH; row++) {
          const srcOff = row * srcW * 4;
          const dstOff = (srcH - 1 - row) * srcW * 4;
          imgData.data.set(pixels.subarray(srcOff, srcOff + srcW * 4), dstOff);
        }
        srcCtx.putImageData(imgData, 0, 0);

        // Scale down using canvas drawImage (high-quality bilinear)
        scaleCtx.drawImage(srcCanvas, 0, 0, gifW, gifH);
        const scaled = scaleCtx.getImageData(0, 0, gifW, gifH);

        vidGifFrames.push({ data: scaled.data, delay });
        vidFrameCount++;
      }, delay);

      const recBtn = document.getElementById('vidRecBtn');
      recBtn.textContent = 'Stop';
      recBtn.classList.add('recording');
      document.getElementById('vidDownloadBtn').style.display = 'none';
      // (MP4 convert button removed — WebM plays everywhere)
      document.getElementById('vidTimeline').disabled = true;
      vidUpdateStatus('<span class="rec-dot">&#9679;</span> Recording GIF...');
      vidTimerInterval = setInterval(vidUpdateTime, 250);
    }

    function vidStopGifRecord() {
      clearInterval(vidGifInterval);
      vidGifInterval = null;
      vidIsRecording = false;
      clearInterval(vidTimerInterval);

      if (vidGifFrames.length === 0) {
        vidUpdateStatus('No frames captured');
        return;
      }

      // Use stored scaled dimensions
      const w = vidGifFrames.gifW || renderer3D.domElement.width;
      const h = vidGifFrames.gifH || renderer3D.domElement.height;

      vidUpdateStatus(`Encoding GIF (${vidGifFrames.length} frames, ${w}×${h})...`);

      // Encode GIF asynchronously to avoid blocking UI
      setTimeout(() => {
        try {
          const gifData = encodeGIF(vidGifFrames, w, h);
          vidBlob = new Blob([gifData], { type: 'image/gif' });

          const elapsed = (performance.now() - vidStartTime) / 1000;
          const mm = Math.floor(elapsed / 60);
          const ss = Math.floor(elapsed % 60).toString().padStart(2, '0');
          vidUpdateStatus(`GIF: ${vidGifFrames.length} frames, ${mm}:${ss} (${(vidBlob.size / 1024 / 1024).toFixed(1)} MB)`);

          const recBtn = document.getElementById('vidRecBtn');
          recBtn.textContent = 'Record';
          recBtn.classList.remove('recording');
          const dlBtn = document.getElementById('vidDownloadBtn');
          dlBtn.textContent = 'Download GIF';
          dlBtn.style.display = '';
        } catch (e) {
          vidUpdateStatus('GIF encoding failed: ' + e.message);
          const recBtn = document.getElementById('vidRecBtn');
          recBtn.textContent = 'Record';
          recBtn.classList.remove('recording');
        }
        vidGifFrames = [];
      }, 50);
    }

    // Minimal GIF89a encoder (LZW compression, 256-color quantization)
    function encodeGIF(frames, width, height) {
      const buf = [];
      function writeByte(b) { buf.push(b & 0xFF); }
      function writeShort(s) { buf.push(s & 0xFF); buf.push((s >> 8) & 0xFF); }
      function writeStr(s) { for (let i = 0; i < s.length; i++) buf.push(s.charCodeAt(i)); }
      function writeBytes(arr) { for (let i = 0; i < arr.length; i++) buf.push(arr[i]); }

      // Quantize RGBA pixels to 256-color palette using median-cut simplification
      function quantize(rgba, w, h) {
        // Build a 6-bit (64-color) uniform palette for speed
        const palette = [];
        for (let r = 0; r < 4; r++)
          for (let g = 0; g < 4; g++)
            for (let b = 0; b < 4; b++)
              palette.push([(r * 85), (g * 85), (b * 85)]);
        // Pad to 256
        while (palette.length < 256) palette.push([0, 0, 0]);

        const indexed = new Uint8Array(w * h);
        for (let i = 0; i < w * h; i++) {
          const ri = rgba[i * 4], gi = rgba[i * 4 + 1], bi = rgba[i * 4 + 2];
          // Map to 6-bit uniform: r/85 * 16 + g/85 * 4 + b/85
          const idx = Math.round(ri / 85) * 16 + Math.round(gi / 85) * 4 + Math.round(bi / 85);
          indexed[i] = Math.min(idx, 63);
        }
        return { palette, indexed };
      }

      // LZW encoder for GIF — uses numeric (prefix_code, suffix_char) keys
      // Code size bump uses > (not >=) because encoder's table is 1 entry
      // ahead of decoder's (encoder adds entry on first code after clear,
      // decoder doesn't), so encoder must delay bump by 1 to stay in sync.
      function lzwEncode(indexed, minCodeSize) {
        const CLEAR = 1 << minCodeSize;
        const EOI = CLEAR + 1;
        const MAX_CODE = 4096;

        const output = [];
        let bitBuf = 0, bitPos = 0;
        let codeSize = minCodeSize + 1;
        let nextCode = EOI + 1;

        function emit(code) {
          bitBuf |= (code << bitPos);
          bitPos += codeSize;
          while (bitPos >= 8) {
            output.push(bitBuf & 0xFF);
            bitBuf >>= 8;
            bitPos -= 8;
          }
        }

        let table = new Map();
        function initTable() {
          table = new Map();
          nextCode = EOI + 1;
          codeSize = minCodeSize + 1;
        }

        initTable();
        emit(CLEAR);

        let curCode = indexed[0];
        for (let i = 1; i < indexed.length; i++) {
          const nextChar = indexed[i];
          const key = curCode * 256 + nextChar;
          if (table.has(key)) {
            curCode = table.get(key);
          } else {
            emit(curCode);
            if (nextCode < MAX_CODE) {
              table.set(key, nextCode);
              nextCode++;
              if (nextCode > (1 << codeSize) && codeSize < 12) codeSize++;
            } else {
              emit(CLEAR);
              initTable();
            }
            curCode = nextChar;
          }
        }
        emit(curCode);
        emit(EOI);

        if (bitPos > 0) output.push(bitBuf & 0xFF);
        return output;
      }

      // --- Build GIF ---

      // Header
      writeStr('GIF89a');
      writeShort(width);
      writeShort(height);

      // Use first frame for global color table
      const q0 = quantize(frames[0].data, width, height);
      const palette = q0.palette;

      // GCT flag: yes, color resolution: 8, sorted: no, size: 256 (7 → 2^(7+1)=256)
      writeByte(0xF7); // 1_111_0_111
      writeByte(0);    // bg color index
      writeByte(0);    // pixel aspect ratio

      // Write Global Color Table (256 × 3 bytes)
      for (let i = 0; i < 256; i++) {
        writeByte(palette[i][0]);
        writeByte(palette[i][1]);
        writeByte(palette[i][2]);
      }

      // Netscape extension for looping
      writeByte(0x21); // extension
      writeByte(0xFF); // app extension
      writeByte(11);   // block size
      writeStr('NETSCAPE2.0');
      writeByte(3);    // sub-block size
      writeByte(1);    // loop sub-block id
      writeShort(0);   // loop count (0 = infinite)
      writeByte(0);    // terminator

      // Write each frame
      for (let f = 0; f < frames.length; f++) {
        const frame = frames[f];
        const q = f === 0 ? q0 : quantize(frame.data, width, height);
        const delay = Math.round(frame.delay / 10); // GIF delay is in centiseconds

        // Graphic Control Extension
        writeByte(0x21); // extension
        writeByte(0xF9); // GCE
        writeByte(4);    // block size
        writeByte(0x04); // disposal method 1 (do not dispose), no transparency
        writeShort(delay);
        writeByte(0);    // transparent color index
        writeByte(0);    // terminator

        // Image Descriptor
        writeByte(0x2C);
        writeShort(0);      // left
        writeShort(0);      // top
        writeShort(width);
        writeShort(height);
        writeByte(0);       // no local color table

        // LZW minimum code size
        const minCodeSize = 8;
        writeByte(minCodeSize);

        // LZW compressed data
        const lzwData = lzwEncode(q.indexed, minCodeSize);

        // Write as sub-blocks (max 255 bytes each)
        let pos = 0;
        while (pos < lzwData.length) {
          const chunkSize = Math.min(255, lzwData.length - pos);
          writeByte(chunkSize);
          writeBytes(lzwData.slice(pos, pos + chunkSize));
          pos += chunkSize;
        }
        writeByte(0); // block terminator
      }

      // Trailer
      writeByte(0x3B);

      return new Uint8Array(buf);
    }

    function vidStopRecord() {
      // GIF mode
      if (vidGifInterval !== null || (vidGifFrames && vidGifFrames.length > 0)) {
        vidStopGifRecord();
        return;
      }
      // Video mode (WebM)
      if (vidRecorder && vidRecorder.state === 'recording') {
        vidRecorder.stop();
      }
      if (vidStream) {
        vidStream.getTracks().forEach(t => t.stop());
        vidStream = null;
      }
    }

    // Frame-by-frame: pause rotation, capture one render frame
    window.vidCaptureFrame = function() {
      if (!renderer3D || !scene3D) return;
      // Pause rotation during frame capture
      if (controls3D) controls3D.autoRotate = false;
      document.getElementById('btn3DPause').textContent = 'Resume Rotation';

      // Force one render
      controls3D.update();
      renderer3D.render(scene3D, camera3D);

      // Capture frame as PNG
      const dataUrl = renderer3D.domElement.toDataURL('image/png');
      vidFrameBlobs.push(dataUrl);
      vidUpdateStatus(`${vidFrameBlobs.length} frame(s) captured`);
    };

    // Step rotation by degrees (for precise framing)
    window.vidStepRotation = function(dir) {
      if (!controls3D || !camera3D) return;
      controls3D.autoRotate = false;
      document.getElementById('btn3DPause').textContent = 'Resume Rotation';

      const angle = dir * 5 * (Math.PI / 180); // 5 degree steps
      const pos = camera3D.position.clone();
      const target = controls3D.target.clone();
      const offset = pos.sub(target);

      // Rotate around Y axis
      const cos = Math.cos(angle), sin = Math.sin(angle);
      const x = offset.x * cos - offset.z * sin;
      const z = offset.x * sin + offset.z * cos;
      camera3D.position.set(target.x + x, camera3D.position.y, target.z + z);
      camera3D.lookAt(target);
      controls3D.update();
      renderer3D.render(scene3D, camera3D);
    };

    // Rotation speed control
    window.vidSetSpeed = function(val) {
      const speed = parseFloat(val);
      document.getElementById('vidSpeedLabel').textContent = speed.toFixed(1) + 'x';
      if (controls3D) controls3D.autoRotateSpeed = speed;
    };

    // Timeline scrubbing for recorded video
    let vidPreviewEl = null;
    let vidDuration = 0;

    function vidSetupPreview(url, duration) {
      vidDuration = duration;
      // Create hidden video element for seeking
      if (vidPreviewEl) { vidPreviewEl.pause(); vidPreviewEl.remove(); }
      vidPreviewEl = document.createElement('video');
      vidPreviewEl.src = url;
      vidPreviewEl.muted = true;
      vidPreviewEl.style.display = 'none';
      document.body.appendChild(vidPreviewEl);

      vidPreviewEl.onloadedmetadata = () => {
        vidDuration = vidPreviewEl.duration || duration;
        const mm = Math.floor(vidDuration / 60);
        const ss = Math.floor(vidDuration % 60).toString().padStart(2, '0');
        document.getElementById('vidTimeDisplay').textContent = `${mm}:${ss} / ${mm}:${ss}`;
      };
    }

    window.vidSeekTimeline = function(val) {
      if (!vidPreviewEl || !vidDuration) return;
      const pct = parseInt(val) / 100;
      const time = pct * vidDuration;
      vidPreviewEl.currentTime = time;
      const mm = Math.floor(time / 60);
      const ss = Math.floor(time % 60).toString().padStart(2, '0');
      const tMM = Math.floor(vidDuration / 60);
      const tSS = Math.floor(vidDuration % 60).toString().padStart(2, '0');
      document.getElementById('vidTimeDisplay').textContent = `${mm}:${ss} / ${tMM}:${tSS}`;
    };

    window.vidDownload = function() {
      if (!vidBlob) { alert('No recording to download'); return; }
      const ext = vidBlob.type.includes('gif') ? 'gif' : vidCurrentFormat.ext;
      const a = document.createElement('a');
      a.href = URL.createObjectURL(vidBlob);
      a.download = `els-matrix-3d-${new Date().toISOString().slice(0,19).replace(/[T:]/g,'-')}.${ext}`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 5000);
    };

    // FFmpeg.wasm MP4 conversion removed — was 32MB download + slow WASM encode.
    // WebM plays natively in Chrome/Firefox/Edge/VLC. GIF works everywhere.

    // Cleanup video state on 3D scene destroy
    function vidCleanup() {
      if (vidRecorder && vidRecorder.state === 'recording') {
        vidRecorder.stop();
      }
      if (vidStream) {
        vidStream.getTracks().forEach(t => t.stop());
        vidStream = null;
      }
      if (vidPreviewEl) {
        vidPreviewEl.pause();
        vidPreviewEl.remove();
        vidPreviewEl = null;
      }
      vidRecorder = null;
      vidChunks = [];
      vidBlob = null;
      vidIsRecording = false;
      vidFrameBlobs = [];
      vidFrameCount = 0;
      vidGifFrames = [];
      if (vidGifInterval) { clearInterval(vidGifInterval); vidGifInterval = null; }
      if (vidTimerInterval) { clearInterval(vidTimerInterval); vidTimerInterval = null; }
    }

    // ============= URL PARAMETER API =============
    // Usage: bible-codes.html?terms=משה,אברהם אברם,ירושלים&skip=500&discover=names
    //   terms   — comma-separated search terms; space within a term = alt spellings
    //   skip    — max skip range (default ±500)
    //   discover — auto-run Discover Terms: 'all', 'names', or 'dates'
    //   tab     — which tab to open: 'scan' (default), 'index', 'dict', 'wrr'
    async function handleUrlParams() {
      const params = new URLSearchParams(window.location.search);
      if (!params.has('terms')) return;

      // Switch to Full Scan tab
      const tabParam = params.get('tab') || 'scan';
      const tabBtn = document.querySelector(`.mode-tab[data-mode="${tabParam}"]`);
      if (tabBtn) tabBtn.click();

      // Set skip range
      const skipVal = parseInt(params.get('skip')) || 500;
      const minSkipEl = document.getElementById('minSkip');
      const maxSkipEl = document.getElementById('maxSkip');
      if (minSkipEl) minSkipEl.value = -Math.abs(skipVal);
      if (maxSkipEl) maxSkipEl.value = Math.abs(skipVal);

      // Fill textarea with terms (comma → newline)
      const termsStr = decodeURIComponent(params.get('terms'));
      const textarea = document.getElementById('batchTextarea');
      if (textarea) {
        textarea.value = termsStr.split(',').map(t => t.trim()).filter(Boolean).join('\n');
      }

      // Wait for init to complete (Torah text + ELS index loaded)
      const waitForInit = () => new Promise(resolve => {
        const check = () => { if (torahText && elsService) resolve(); else setTimeout(check, 200); };
        check();
      });
      await waitForInit();

      // Run search
      await startScan();

      // Auto-discover if requested
      const discoverParam = params.get('discover');
      if (discoverParam && current3DHits && current3DHits.length > 0) {
        // Set filter before discovering
        const fAll = document.getElementById('discFilterAll');
        const fNames = document.getElementById('discFilterNames');
        const fDates = document.getElementById('discFilterDates');
        if (discoverParam === 'names' && fNames) {
          fAll.checked = false; fNames.checked = true; fDates.checked = false;
        } else if (discoverParam === 'dates' && fDates) {
          fAll.checked = false; fNames.checked = false; fDates.checked = true;
        } else if (fAll) {
          fAll.checked = true; if (fNames) fNames.checked = false; if (fDates) fDates.checked = false;
        }

        // Small delay to ensure DOM has updated after scan
        await new Promise(r => setTimeout(r, 100));
        await discoverMatrixTerms();
      }
    }

    // ============= INTRO BLURB PERSISTENCE =============
    (function() {
      const b = document.getElementById('introBlurb');
      if (!b) return;
      if (localStorage.getItem('intro-dismissed') === '1') b.removeAttribute('open');
      b.addEventListener('toggle', () => {
        localStorage.setItem('intro-dismissed', b.open ? '0' : '1');
      });
    })();

    // ============= INIT ON LOAD =============
    init();
    handleUrlParams();
  </script>
  <script src="js/pwa-install.js" async></script>
  <footer class="site-footer">
    <div class="footer-links">
      <a href="text-search.html">Text Search</a>
      <a href="gematria.html">Gematria</a>
      <a href="acronym.html">Acronyms</a>
      <a href="tsirufim.html">Tsirufim</a>
      <a href="matrix-view.html">Matrix View</a>
      <a href="book-view.html">Book View</a>
      <a href="hebrew-date.html">Hebrew Date</a>
      <a href="igeret.html">Igeret HaRamba"n</a>
      <a href="other-resources.html">Resources</a>
      <a href="dashboard.html">All Tools</a>
    </div>
    <p>Bible Codes &mdash; Hebrew Bible Analysis Suite</p>
    <p style="margin-top:0.5em;font-style:italic;opacity:0.85;">Dedicated in loving memory of my Dad and teacher, Shmuel Zbaida z&quot;l</p>
    <p style="margin-top:0.5em;font-size:11px;opacity:0.7;">Sacred Names are redacted in output. Please treat printed materials with reverence.</p>
  </footer>
<script data-goatcounter="https://bible-codes.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>
